[
    {
        "query": "I want to merge a single file using the 'git-merge-one-file' API.",
        "model_answer": "git.merge_one_file()",
        "original": {
            "domain": "git",
            "framework": "Git",
            "functionality": "Merging single file",
            "api_name": "git.merge_one_file",
            "api_call": "git merge-one-file",
            "api_arguments": [],
            "python_environment_requirements": [],
            "example_code": [],
            "description": "The 'git-merge-one-file' API is a standard helper program used with git merge-index to resolve a merge after the trivial merge done with git read-tree -m. This API is specifically used for merging a single file.",
            "api_name_original": "git-merge-one-file",
            "api_arguments_original": []
        }
    },
    {
        "query": "I want to show the canonical name and email address of a contact named Jane Smith using the git-check-mailmap API.",
        "model_answer": "git.check_mailmap(\"Jane Smith\")",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Show canonical names and email addresses of contacts",
            "api_name": "git.check_mailmap",
            "api_call": "git check-mailmap [<options>] <contact>",
            "api_arguments": [
                {
                    "name": "stdin"
                },
                {
                    "name": "contact"
                }
            ],
            "python_environment_requirements": [],
            "example_code": [],
            "description": "The git-check-mailmap API is used to show the canonical names and email addresses of the given contacts. The API takes in a list of contacts as arguments and for each contact, it looks up the person\u2019s canonical name and email address. If found, it prints them; otherwise it prints the input as-is. The --stdin option allows the API to read contacts, one per line, from the standard input after exhausting contacts provided on the command-line.",
            "api_name_original": "git-check-mailmap",
            "api_arguments_original": [
                "--stdin",
                "<contact>"
            ]
        }
    },
    {
        "query": "I would like to display the value of the GIT_COMMITTER_NAME variable using the git-var API.",
        "model_answer": "git.var(\"GIT_COMMITTER_NAME\")",
        "original": {
            "domain": "github",
            "framework": "git",
            "functionality": "showing a git logical variable",
            "api_name": "git.var",
            "api_call": "git var (-l | <variable>)",
            "api_arguments": [
                {
                    "name": "_l"
                },
                {
                    "name": "variable"
                }
            ],
            "python_environment_requirements": [
                "git"
            ],
            "example_code": [
                {
                    "description": "To display the GIT_AUTHOR_IDENT variable",
                    "code": "$ git var GIT_AUTHOR_IDENT"
                }
            ],
            "description": "The git-var API is used to print a Git logical variable. It exits with code 1 if the variable has no value. The '-l' argument causes the logical variables to be listed. In addition, all the variables of the Git configuration file .git/config are listed as well. However, the configuration variables listing functionality is deprecated in favor of git config -l.",
            "api_name_original": "git-var",
            "api_arguments_original": [
                "-l",
                "<variable>"
            ]
        }
    },
    {
        "query": "I want to update the auxiliary info file on my Git repository forcefully.",
        "model_answer": "git.update_server_info(force=True)",
        "original": {
            "domain": "github",
            "framework": "git",
            "functionality": "Update auxiliary info file to help dumb servers",
            "api_name": "git.update_server_info",
            "api_call": "git update-server-info [-f | --force]",
            "api_arguments": [
                {
                    "name": "_f"
                },
                {
                    "name": "force"
                }
            ],
            "python_environment_requirements": "Git Python library",
            "example_code": [],
            "description": "A dumb server that does not do on-the-fly pack generations must have some auxiliary information files in $GIT_DIR/info and $GIT_OBJECT_DIRECTORY/info directories to help clients discover what references and packs the server has. This command generates such auxiliary files.",
            "api_name_original": "git-update-server-info",
            "api_arguments_original": [
                "-f",
                "--force"
            ]
        }
    },
    {
        "query": "I want to retrieve the Git revisions and ranges for a specific repository.",
        "model_answer": "git.gitrevisions()",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Specifying revisions and ranges for Git",
            "api_name": "git.gitrevisions",
            "api_call": "gitrevisions",
            "api_arguments": "None",
            "python_environment_requirements": "None",
            "example_code": "None",
            "description": "The gitrevisions API allows users to specify revisions and ranges in Git. Many Git commands take revision parameters as arguments. Depending on the command, they denote a specific commit or, for commands which walk the revision graph, all commits which are reachable from that commit. For commands that walk the revision graph one can also specify a range of revisions explicitly. Some Git commands can also take revision parameters which denote other objects than commits, e.g. blobs ('files') or trees ('directories of files').",
            "api_name_original": "gitrevisions",
            "api_arguments_original": "None"
        }
    },
    {
        "query": "I want to count the number of unpacked object files and their disk consumption in a git repository and display the output in a human-readable format.",
        "model_answer": "git.count_objects(v=True, H=True)",
        "original": {
            "domain": "github",
            "framework": "git",
            "functionality": "Count unpacked number of objects and their disk consumption",
            "api_name": "git.count_objects",
            "api_call": "git count-objects [-v] [-H | --human-readable]",
            "api_arguments": [
                {
                    "name": "_v"
                },
                {
                    "name": "_h"
                },
                {
                    "name": "human_readable"
                }
            ],
            "python_environment_requirements": [
                "git"
            ],
            "example_code": [],
            "description": "The git-count-objects API is used to count the number of unpacked object files and the disk space consumed by them. This is useful in deciding when it is a good time to repack. It provides options for verbose reporting and for printing sizes in a human-readable format.",
            "api_name_original": "git-count-objects",
            "api_arguments_original": [
                "-v",
                "-H",
                "--human-readable"
            ]
        }
    },
    {
        "query": "I want to build a pack index file for an existing packed archive in Git using the 'git-index-pack' command, and save the index file as \"my_index.idx\".",
        "model_answer": "git.index_pack(pack_file=\"<pack-file>\", index_file=\"my_index.idx\")",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Build pack index file for an existing packed archive",
            "api_name": "git.index_pack",
            "api_call": "git index-pack [-v] [-o <index-file>] [--[no-]rev-index] <pack-file>",
            "api_arguments": [
                {
                    "name": "_v"
                },
                {
                    "name": "_o_index_file"
                },
                {
                    "name": "[no_]rev_index"
                },
                {
                    "name": "pack_file"
                }
            ],
            "python_environment_requirements": [
                "git"
            ],
            "example_code": [],
            "description": "The git-index-pack command reads a packed archive (.pack) from the specified file, and builds a pack index file (.idx) for it. Optionally writes a reverse-index (.rev) for the specified pack. The packed archive together with the pack index can then be placed in the objects/pack/ directory of a Git repository. This is useful for managing and organizing large codebases in Git.",
            "api_name_original": "git-index-pack",
            "api_arguments_original": [
                "-v",
                "-o <index-file>",
                "--[no-]rev-index",
                "<pack-file>"
            ]
        }
    },
    {
        "query": "I want to verify the signature of a commit with SHA-1 identifier \"def456\" in a Git repository using GPG.",
        "model_answer": "git.verify_commit(commit=\"def456\")",
        "original": {
            "domain": "github",
            "framework": "git",
            "functionality": "Verify commit signatures",
            "api_name": "git.verify_commit",
            "api_call": "git verify-commit [-v | --verbose] [--raw] <commit>",
            "api_arguments": [
                {
                    "name": "_v_|_verbose"
                },
                {
                    "name": "raw"
                },
                {
                    "name": "commit"
                }
            ],
            "python_environment_requirements": [],
            "example_code": [],
            "description": "The git-verify-commit API is used to check the GPG signature of commits. It validates the GPG signature created by git commit -S. The API call is 'git verify-commit [-v | --verbose] [--raw] <commit>'. The arguments are optional and include '-v | --verbose' to print the contents of the commit object before validating it, '--raw' to print the raw gpg status output to standard error instead of the normal human-readable output, and '<commit>' which is the SHA-1 identifiers of Git commit objects.",
            "api_name_original": "git-verify-commit",
            "api_arguments_original": [
                "-v | --verbose",
                "--raw",
                "<commit>"
            ]
        }
    },
    {
        "query": "I want to push my local git repository to another remote repository using HTTP/DAV protocol.",
        "model_answer": "\"git.http_push(<URL>, <ref>)\"",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Push objects over HTTP/DAV to another repository",
            "api_name": "\"git.http_push",
            "api_call": "git http-push [--all] [--dry-run] [--force] [--verbose] <URL> <ref> [<ref>\u2026\u200b]",
            "api_arguments": [
                {
                    "name": "all"
                },
                {
                    "name": "dry_run"
                },
                {
                    "name": "force"
                },
                {
                    "name": "verbose"
                },
                {
                    "name": "url"
                },
                {
                    "name": "ref"
                }
            ],
            "python_environment_requirements": [
                "libcurl version 7.16 or higher"
            ],
            "example_code": [],
            "description": "The git-http-push API is used to push objects over HTTP/DAV to another repository. It sends missing objects to the remote repository, and updates the remote branch. This command is temporarily disabled if your libcurl is older than 7.16, as the combination has been reported not to work and sometimes corrupts repository.",
            "api_name_original": "git-http-push",
            "api_arguments_original": [
                "--all",
                "--dry-run",
                "--force",
                "--verbose",
                "<URL>",
                "<ref>"
            ]
        }
    },
    {
        "query": "I want to run the pre-commit hook for my git repository.",
        "model_answer": "git.hook.run(\"pre-commit\")",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Run git hooks",
            "api_name": "git.hook.run",
            "api_call": "git hook run [--ignore-missing] [--to-stdin=<path>] <hook-name> [-- <hook-args>]",
            "api_arguments": [
                {
                    "name": "ignore_missing"
                },
                {
                    "name": "to_stdin"
                },
                {
                    "name": "hook_name"
                },
                {
                    "name": "hook_args"
                }
            ],
            "python_environment_requirements": [
                "git"
            ],
            "example_code": [],
            "description": "The git-hook API is a command interface for running git hooks. This is used by other scripted git commands. It allows for the running of hooks with specified names and optional arguments. Options include specifying a file to be streamed into the hook's stdin and ignoring any missing hook by quietly returning zero.",
            "api_name_original": "git-hook",
            "api_arguments_original": [
                "--ignore-missing",
                "--to-stdin",
                "<hook-name>",
                "<hook-args>"
            ]
        }
    },
    {
        "query": "I want to send a collection of patches as emails using git-send-email. The patches are stored in a directory called \"new-patches\".",
        "model_answer": "git.send_email(file_or_directory=\"new-patches\")",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Send a collection of patches as emails",
            "api_name": "git.send_email",
            "api_call": "git send-email [<options>] <file|directory>\u2026\u200b",
            "api_arguments": [
                {
                    "name": "options"
                },
                {
                    "name": "file|directory"
                }
            ],
            "python_environment_requirements": [
                "MIME::Base64",
                "MIME::QuotedPrint",
                "Net::Domain",
                "Net::SMTP",
                "Authen::SASL",
                "Mail::Address"
            ],
            "example_code": [
                {
                    "description": "Use gmail as the smtp server",
                    "code": "git format-patch --cover-letter -M origin/master -o outgoing/\nedit outgoing/0000-*\ngit send-email outgoing/*"
                }
            ],
            "description": "The git-send-email command takes the patches given on the command line and emails them out. Patches can be specified as files, directories (which will send all files in the directory), or directly as a revision list. The header of the email is configurable via command-line options. If not specified on the command line, the user will be prompted with a ReadLine enabled interface to provide the necessary information.",
            "api_name_original": "git-send-email",
            "api_arguments_original": [
                "options",
                "file|directory"
            ]
        }
    },
    {
        "query": "I want to add a submodule with the URL \"https://github.com/sample/repo.git\" to the path \"submodules/sample\" in my git repository.",
        "model_answer": "git.submodule.add(\"https://github.com/sample/repo.git\", \"submodules/sample\")",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Embedding one repository inside another",
            "api_name": "git.submodule.add(\"https://github.com/example/repo.git\", \"submodules/repo\"",
            "api_call": "git submodule add <URL> <path>",
            "api_arguments": [
                {
                    "name": "url"
                },
                {
                    "name": "path"
                }
            ],
            "python_environment_requirements": [],
            "example_code": [
                {
                    "description": "Add a submodule",
                    "code": "git submodule add <URL> <path>"
                },
                {
                    "description": "Update the submodule to a new version",
                    "code": "git -C <path> checkout <new version>\ngit add <path>\ngit commit -m 'update submodule to new version'"
                },
                {
                    "description": "See the list of submodules in a superproject",
                    "code": "git submodule status"
                }
            ],
            "description": "A submodule is a repository embedded inside another repository. This allows you to contain the working tree of another project within your own working tree while keeping the history of both projects separate. Also, since submodules are fixed to an arbitrary version, the other project can be independently developed without affecting the superproject, allowing the superproject project to fix itself to new versions only when desired.",
            "api_name_original": "gitsubmodules",
            "api_arguments_original": [
                "URL",
                "path"
            ]
        }
    },
    {
        "query": "I want to repack the unpacked objects in my GitHub repository.",
        "model_answer": "git.repack()",
        "original": {
            "domain": "github",
            "framework": "git",
            "functionality": "Pack unpacked objects in a repository",
            "api_name": "git.repack",
            "api_call": "git repack [-a] [-A] [-d] [-f] [-F] [-l] [-n] [-q] [-b] [-m] [--window=<n>] [--depth=<n>] [--threads=<n>] [--keep-pack=<pack-name>] [--write-midx]",
            "api_arguments": [
                {
                    "name": "_a"
                },
                {
                    "name": "_a"
                },
                {
                    "name": "_d"
                },
                {
                    "name": "_f"
                },
                {
                    "name": "_f"
                },
                {
                    "name": "_l"
                },
                {
                    "name": "_n"
                },
                {
                    "name": "_q"
                },
                {
                    "name": "_b"
                },
                {
                    "name": "_m"
                },
                {
                    "name": "window"
                },
                {
                    "name": "depth"
                },
                {
                    "name": "threads"
                },
                {
                    "name": "keep_pack"
                },
                {
                    "name": "write_midx"
                }
            ],
            "python_environment_requirements": [
                "git"
            ],
            "example_code": [],
            "description": "The git-repack command is used to combine all objects that do not currently reside in a 'pack', into a pack. It can also be used to re-organize existing packs into a single, more efficient pack. A pack is a collection of objects, individually compressed, with delta compression applied, stored in a single file, with an associated index file. Packs are used to reduce the load on mirror systems, backup engines, disk storage, etc.",
            "api_name_original": "git-repack",
            "api_arguments_original": [
                "-a",
                "-A",
                "-d",
                "-f",
                "-F",
                "-l",
                "-n",
                "-q",
                "-b",
                "-m",
                "--window",
                "--depth",
                "--threads",
                "--keep-pack",
                "--write-midx"
            ]
        }
    },
    {
        "query": "I want to verify a packed Git archive file and only show the histogram of delta chain length.",
        "model_answer": "git.verify_pack(stat_only=True)",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Verify packed Git archive files",
            "api_name": "git.verify_pack",
            "api_call": "git verify-pack [-v | --verbose] [-s | --stat-only] [--] <pack>.idx",
            "api_arguments": [
                {
                    "name": "pack.idx"
                },
                {
                    "name": "_v"
                },
                {
                    "name": "verbose"
                },
                {
                    "name": "_s"
                },
                {
                    "name": "stat_only"
                },
                {
                    "name": ""
                }
            ],
            "python_environment_requirements": [
                "git"
            ],
            "example_code": [],
            "description": "The git-verify-pack API is used to validate packed Git archive files. It reads the given idx file for packed Git archive created with the git pack-objects command and verifies idx file and the corresponding pack file. It has options to verify the pack, show list of objects contained in the pack and a histogram of delta chain length, and to not verify the pack contents; only show the histogram of delta chain length.",
            "api_name_original": "git-verify-pack",
            "api_arguments_original": [
                "<pack>.idx",
                "-v",
                "--verbose",
                "-s",
                "--stat-only",
                "--"
            ]
        }
    },
    {
        "query": "Can you please provide a Python function call to extract the commit ID from a tar archive created using git-archive?",
        "model_answer": "git.get_tar_commit_id()",
        "original": {
            "domain": "github",
            "framework": "git",
            "functionality": "Extract commit ID from an archive",
            "api_name": "git.get_tar_commit_id",
            "api_call": "git get-tar-commit-id",
            "api_arguments": [],
            "python_environment_requirements": [],
            "example_code": [],
            "description": "The git-get-tar-commit-id API is used to extract the commit ID from an archive created using git-archive. It reads a tar archive from the standard input and extracts the commit ID stored in it. The API reads only the first 1024 bytes of input, thus its runtime is not influenced by the size of the tar archive very much. If no commit ID is found, git get-tar-commit-id quietly exists with a return code of 1. This can happen if the archive had not been created using git archive or if the first parameter of git archive had been a tree ID instead of a commit ID or tag.",
            "api_name_original": "git-get-tar-commit-id",
            "api_arguments_original": []
        }
    },
    {
        "query": "I want to merge the files 'file3.txt' and 'file4.txt' using the git merge-index command.",
        "model_answer": "git.merge_index('<merge-program>', '-a', 'file3.txt', 'file4.txt')",
        "original": {
            "domain": "github",
            "framework": "git",
            "functionality": "merge files needing merging",
            "api_name": "git.merge_index('<merge_program>', '_a', 'file1.txt', 'file2.txt'",
            "api_call": "git merge-index [-o] [-q] <merge-program> (-a | ( [--] <file>\u2026\u200b) )",
            "api_arguments": [
                {
                    "name": "_o"
                },
                {
                    "name": "_q"
                },
                {
                    "name": "merge_program"
                },
                {
                    "name": "_a"
                },
                {
                    "name": "file"
                }
            ],
            "python_environment_requirements": [
                "git"
            ],
            "example_code": [
                {
                    "description": "Merge MM file",
                    "code": "git merge-index cat MM"
                },
                {
                    "description": "Merge AA and MM files",
                    "code": "git merge-index cat AA MM"
                }
            ],
            "description": "The git-merge-index command is used to run a merge for files that need merging. It looks up the specified files in the index and, if there are any merge entries, passes the SHA-1 hash for those files as arguments. If git merge-index is called with multiple files, it processes them in turn, stopping if a merge returns a non-zero exit code. This command is typically run with a script calling Git\u2019s imitation of the merge command from the RCS package.",
            "api_name_original": "git-merge-index",
            "api_arguments_original": [
                "-o",
                "-q",
                "<merge-program>",
                "-a",
                "<file>"
            ]
        }
    },
    {
        "query": "I want to configure the username for the example.com authentication context in Git with the username \"myname123\".",
        "model_answer": "git.config.credential('credential.https://example.com.username', 'myname123')",
        "original": {
            "domain": "git",
            "framework": "Git",
            "functionality": "Providing usernames and passwords to Git",
            "api_name": "git.config.credential('credential.https://example.com.username', 'myusername'",
            "api_call": "git config credential.https://example.com.username myusername",
            "api_arguments": [
                {
                    "name": "credential.https//example.com.username"
                },
                {
                    "name": "myusername"
                }
            ],
            "python_environment_requirements": [
                "Git"
            ],
            "example_code": [
                {
                    "description": "Configuring username for a given authentication context",
                    "code": "git config credential.https://example.com.username myusername"
                },
                {
                    "description": "Using credential helper",
                    "code": "git config --global credential.helper foo"
                }
            ],
            "description": "The gitcredentials API is used to provide usernames and passwords to Git. It is used when Git needs to ask for a username and password to access a remote repository over HTTP. The API includes mechanisms to request these credentials, as well as features to avoid inputting these credentials repeatedly. It provides methods to reduce the need to input the same credentials over and over, like static configuration of usernames for a given authentication context and credential helpers to cache or store passwords, or to interact with a system password wallet or keychain.",
            "api_name_original": "gitcredentials",
            "api_arguments_original": [
                "credential.https://example.com.username",
                "myusername"
            ]
        }
    },
    {
        "query": "I want to check the version of Git installed on my system.",
        "model_answer": "git.version()",
        "original": {
            "domain": "git",
            "framework": "Git",
            "functionality": "Data transfer in packfiles over various protocols",
            "api_name": "git.version",
            "api_call": "git --version",
            "api_arguments": [
                {
                    "name": "version"
                }
            ],
            "python_environment_requirements": [
                "GitPython"
            ],
            "example_code": [
                {
                    "description": "Checking Git version",
                    "code": "git --version"
                }
            ],
            "description": "The gitprotocol-pack API is part of the Git suite and it is used to transfer data in packfiles over the ssh://, git://, http:// and file:// transports. There exist two sets of protocols, one for pushing data from a client to a server and another for fetching data from a server to a client. The three transports (ssh, git, file) use the same protocol to transfer data. The processes invoked in the canonical Git implementation are upload-pack on the server side and fetch-pack on the client side for fetching data; then receive-pack on the server and send-pack on the client for pushing data. The protocol functions to have a server tell a client what is currently on the server, then for the two to negotiate the smallest amount of data to send in order to fully update one or the other.",
            "api_name_original": "gitprotocol-pack",
            "api_arguments_original": [
                "version"
            ]
        }
    },
    {
        "query": "Apply a patch to the index in Git without checking if it is applicable to the current working tree or the index file.",
        "model_answer": "git.apply(\"<patch>\", \"--index\", \"--check\")",
        "original": {
            "domain": "git",
            "framework": "Git",
            "functionality": "Apply a patch to files and/or to the index",
            "api_name": "git.apply",
            "api_call": "git apply <patch>",
            "api_arguments": [
                {
                    "name": "stat"
                },
                {
                    "name": "numstat"
                },
                {
                    "name": "summary"
                },
                {
                    "name": "check"
                },
                {
                    "name": "index"
                },
                {
                    "name": "intent_to_add"
                },
                {
                    "name": "3way"
                },
                {
                    "name": "apply"
                },
                {
                    "name": "no_add"
                },
                {
                    "name": "build_fake_ancestor"
                },
                {
                    "name": "_r"
                },
                {
                    "name": "reject"
                },
                {
                    "name": "_z"
                },
                {
                    "name": "_p"
                },
                {
                    "name": "_c"
                },
                {
                    "name": "inaccurate_eof"
                },
                {
                    "name": "recount"
                },
                {
                    "name": "cached"
                },
                {
                    "name": "ignore_space_change"
                },
                {
                    "name": "whitespace"
                },
                {
                    "name": "exclude"
                },
                {
                    "name": "include"
                },
                {
                    "name": "directory"
                },
                {
                    "name": "verbose"
                },
                {
                    "name": "quiet"
                },
                {
                    "name": "unsafe_paths"
                },
                {
                    "name": "allow_empty"
                }
            ],
            "python_environment_requirements": [
                "Git"
            ],
            "example_code": [],
            "description": "The git-apply command reads the supplied diff output (a patch) and applies it to files. It has options to apply the patch to both the index and the working tree, or just the index, without touching the working tree. It can also check if the patch is applicable to the current working tree and/or the index file and detects errors. This command applies the patch but does not create a commit. Use git-am[1] to create commits from patches generated by git-format-patch[1] and/or received by email.",
            "api_name_original": "git-apply",
            "api_arguments_original": [
                "--stat",
                "--numstat",
                "--summary",
                "--check",
                "--index",
                "--intent-to-add",
                "--3way",
                "--apply",
                "--no-add",
                "--build-fake-ancestor",
                "-R",
                "--reject",
                "-z",
                "-p",
                "-C",
                "--inaccurate-eof",
                "--recount",
                "--cached",
                "--ignore-space-change",
                "--whitespace",
                "--exclude",
                "--include",
                "--directory",
                "--verbose",
                "--quiet",
                "--unsafe-paths",
                "--allow-empty"
            ]
        }
    },
    {
        "query": "I want to use the git-read-tree command to read tree information into the index, performing a 3-way merge with the specified tree-ish1 as tree1, tree-ish2 as tree2, and tree-ish3 as tree3.",
        "model_answer": "git.read_tree(\"-m\", \"tree1\", \"tree2\", \"tree3\")",
        "original": {
            "domain": "git",
            "framework": "Git",
            "functionality": "Read tree information into the index",
            "api_name": "git.read_tree",
            "api_call": "git read-tree [(-m [--trivial] [--aggressive] | --reset | --prefix=<prefix>) [-u | -i]] [--index-output=<file>] [--no-sparse-checkout] (--empty | <tree-ish1> [<tree-ish2> [<tree-ish3>]])",
            "api_arguments": [
                {
                    "name": "_m"
                },
                {
                    "name": "trivial"
                },
                {
                    "name": "aggressive"
                },
                {
                    "name": "reset"
                },
                {
                    "name": "prefix"
                },
                {
                    "name": "_u"
                },
                {
                    "name": "_i"
                },
                {
                    "name": "index_output"
                },
                {
                    "name": "no_sparse_checkout"
                },
                {
                    "name": "empty"
                },
                {
                    "name": "tree_ish1"
                },
                {
                    "name": "tree_ish2"
                },
                {
                    "name": "tree_ish3"
                }
            ],
            "python_environment_requirements": [
                "GitPython"
            ],
            "example_code": [],
            "description": "The git-read-tree command reads the tree information given by <tree-ish> into the index, but does not actually update any of the files it 'caches'. Optionally, it can merge a tree into the index, perform a fast-forward (i.e. 2-way) merge, or a 3-way merge, with the -m flag. When used with -m, the -u flag causes it to also update the files in the work tree with the result of the merge. Trivial merges are done by git read-tree itself. Only conflicting paths will be in unmerged state when git read-tree returns.",
            "api_name_original": "git-read-tree",
            "api_arguments_original": [
                "-m",
                "--trivial",
                "--aggressive",
                "--reset",
                "--prefix",
                "-u",
                "-i",
                "--index-output",
                "--no-sparse-checkout",
                "--empty",
                "<tree-ish1>",
                "<tree-ish2>",
                "<tree-ish3>"
            ]
        }
    },
    {
        "query": "I want to remove unnecessary whitespace and strip comments from a git repository.",
        "model_answer": "git.stripspace(strip_comments=True)",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Remove unnecessary whitespace",
            "api_name": "git.stripspace",
            "api_call": "git stripspace [-s | --strip-comments] OR git stripspace [-c | --comment-lines]",
            "api_arguments": [
                {
                    "name": "_s_or_strip_comments"
                },
                {
                    "name": "_c_or_comment_lines"
                }
            ],
            "python_environment_requirements": "Git installed",
            "example_code": [
                {
                    "description": "Use git stripspace with no arguments to clean input",
                    "code": "git stripspace"
                },
                {
                    "description": "Use git stripspace --strip-comments to remove lines starting with comment character",
                    "code": "git stripspace --strip-comments"
                }
            ],
            "description": "git-stripspace is a git functionality that reads text, such as commit messages, notes, tags and branch descriptions, from the standard input and cleans it in the manner used by Git. This includes removing trailing whitespace from all lines, collapsing multiple consecutive empty lines into one, removing empty lines from the beginning and end of the input, and adding a missing new line to the last line if necessary. In the case where the input consists entirely of whitespace characters, no output will be produced. It also provides options to skip and remove all lines starting with comment character or prepend comment character and blank to each line.",
            "api_name_original": "git-stripspace",
            "api_arguments_original": [
                "-s OR --strip-comments",
                "-c OR --comment-lines"
            ]
        }
    },
    {
        "query": "I want to check if a bundle file named \"my_bundle\" is valid and will apply cleanly to my Git repository.",
        "model_answer": "git.bundle.verify(file=\"my_bundle\")",
        "original": {
            "domain": "git",
            "framework": "Python",
            "functionality": "Create, unpack, and manipulate 'bundle' files",
            "api_name": "git.bundle.create",
            "api_call": "git bundle create [-q | --quiet | --progress] [--version=<version>] <file> <git-rev-list-args>",
            "api_arguments": [
                {
                    "name": "_q"
                },
                {
                    "name": "quiet"
                },
                {
                    "name": "progress"
                },
                {
                    "name": "version"
                },
                {
                    "name": "file"
                },
                {
                    "name": "git_rev_list_args"
                }
            ],
            "python_environment_requirements": [
                "Python 3.x",
                "GitPython library"
            ],
            "example_code": [
                {
                    "description": "Create a bundle named file",
                    "code": "git bundle create [-q | --quiet | --progress] [--version=<version>] <file> <git-rev-list-args>"
                },
                {
                    "description": "Check that a bundle file is valid and will apply cleanly to the current repository",
                    "code": "git bundle verify [-q | --quiet] <file>"
                },
                {
                    "description": "Lists the references defined in the bundle",
                    "code": "git bundle list-heads <file> [<refname>\u2026\u200b]"
                },
                {
                    "description": "Passes the objects in the bundle to git index-pack for storage in the repository",
                    "code": "git bundle unbundle [--progress] <file> [<refname>\u2026\u200b]"
                }
            ],
            "description": "The git-bundle API allows users to create, unpack, and manipulate 'bundle' files. Bundles are used for the 'offline' transfer of Git objects without an active 'server' sitting on the other side of the network connection. They can be used to create both incremental and full backups of a repository, and to relay the state of the references in one repository to another.",
            "api_name_original": "git-bundle",
            "api_arguments_original": [
                "-q",
                "--quiet",
                "--progress",
                "--version=<version>",
                "<file>",
                "<git-rev-list-args>"
            ]
        }
    },
    {
        "query": "I want to set up a sparse checkout in my Git repository to include all files under the directories 'MY/DIR1/' and 'SUB/DIR2/' in my working copy.",
        "model_answer": "git.sparse_checkout.set('MY/DIR1', 'SUB/DIR2')",
        "original": {
            "domain": "git",
            "framework": "Git",
            "functionality": "Sparse Checkout",
            "api_name": "git.sparse_checkout.set",
            "api_call": "git sparse-checkout <init | list | set | add | reapply | disable | check-rules>",
            "api_arguments": [
                {
                    "name": "init"
                },
                {
                    "name": "list"
                },
                {
                    "name": "set"
                },
                {
                    "name": "add"
                },
                {
                    "name": "reapply"
                },
                {
                    "name": "disable"
                },
                {
                    "name": "check_rules"
                }
            ],
            "python_environment_requirements": [],
            "example_code": [
                {
                    "description": "Change to a sparse checkout with all files under MY/DIR1/ and SUB/DIR2/ present in the working copy.",
                    "code": "git sparse-checkout set MY/DIR1 SUB/DIR2"
                },
                {
                    "description": "Repopulate the working directory with all files, disabling sparse checkouts.",
                    "code": "git sparse-checkout disable"
                },
                {
                    "description": "Add all files under SOME/DIR/ECTORY/ to the sparse checkout.",
                    "code": "git sparse-checkout add SOME/DIR/ECTORY"
                },
                {
                    "description": "Reapply the existing sparse directory specifications to make the working directory match.",
                    "code": "git sparse-checkout reapply"
                }
            ],
            "description": "The Git Sparse-Checkout API is used to create sparse checkouts, which change the working tree from having all tracked files present to only having a subset of those files. It can also switch which subset of files are present, or undo and go back to having all tracked files present in the working copy. The subset of files is chosen by providing a list of directories in cone mode (the default), or by providing a list of patterns in non-cone mode. When in a sparse-checkout, other Git commands behave a bit differently. For example, switching branches will not update paths outside the sparse-checkout directories/patterns, and git commit -a will not record paths outside the sparse-checkout directories/patterns as deleted.",
            "api_name_original": "Git Sparse-Checkout",
            "api_arguments_original": [
                "init",
                "list",
                "set",
                "add",
                "reapply",
                "disable",
                "check-rules"
            ]
        }
    },
    {
        "query": "I want to extract patch and authorship details from a single email message using the git-mailinfo command. The email message is stored in a file called 'email.txt' and the patch information should be written to a file called 'patch.txt'.",
        "model_answer": "git.mailinfo(msg='email.txt', patch='patch.txt')",
        "original": {
            "domain": "github",
            "framework": "git",
            "functionality": "Extracts patch and authorship from a single e-mail message",
            "api_name": "git.mailinfo(msg='email.txt', patch='patch.txt'",
            "api_call": "git mailinfo [-k|-b] [-u | --encoding=<encoding> | -n] [--[no-]scissors] [--quoted-cr=<action>] <msg> <patch>",
            "api_arguments": [
                {
                    "name": "_k"
                },
                {
                    "name": "_b"
                },
                {
                    "name": "_u"
                },
                {
                    "name": "encoding"
                },
                {
                    "name": "_n"
                },
                {
                    "name": "scissors"
                },
                {
                    "name": "quoted_cr"
                },
                {
                    "name": "msg"
                },
                {
                    "name": "patch"
                }
            ],
            "python_environment_requirements": [
                "Git"
            ],
            "example_code": [],
            "description": "The git-mailinfo command is used to extract patch and authorship details from a single email message. It reads an email message from the standard input, writes the commit log message in the <msg> file, and the patches in the <patch> file. The author name, email, and email subject are written out to the standard output to be used by git am to create a commit. The command has several options to customize its behavior, such as -k to prevent removal of email cruft from the Subject header line, -u to recode the commit log message, author name, and author email in a specified charset, among others.",
            "api_name_original": "git-mailinfo",
            "api_arguments_original": [
                "-k",
                "-b",
                "-u",
                "--encoding",
                "-n",
                "--scissors",
                "--quoted-cr",
                "<msg>",
                "<patch>"
            ]
        }
    },
    {
        "query": "I want to serve the contents of a Git repository over HTTP and HTTPS protocols.",
        "model_answer": "git.http-backend()",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Serves the contents of a Git repository to Git clients over HTTP and HTTPS protocols",
            "api_name": "git.http_backend",
            "api_call": "git http-backend",
            "api_arguments": [
                {
                    "name": "git_project_root"
                },
                {
                    "name": "git_http_export_all"
                },
                {
                    "name": "http.getanyfile"
                },
                {
                    "name": "http.uploadpack"
                },
                {
                    "name": "http.receivepack"
                }
            ],
            "python_environment_requirements": [
                "CGI environment"
            ],
            "example_code": [
                {
                    "description": "Apache 2.x configuration",
                    "code": "SetEnv GIT_PROJECT_ROOT /var/www/git\nSetEnv GIT_HTTP_EXPORT_ALL\nScriptAlias /git/ /usr/libexec/git-core/git-http-backend/\nSetEnvIf Git-Protocol \".*\" GIT_PROTOCOL=$0"
                },
                {
                    "description": "Lighttpd configuration",
                    "code": "alias.url += ( \"/git\" => \"/usr/lib/git-core/git-http-backend\" )\n$HTTP[\"url\"] =~ \"^/git\" {\ncgi.assign = (\"\" => \"\")\nsetenv.add-environment = (\n\"GIT_PROJECT_ROOT\" => \"/var/www/git\",\n\"GIT_HTTP_EXPORT_ALL\" => \"\"\n)\n}"
                }
            ],
            "description": "The git-http-backend is a server-side implementation of Git over HTTP. It serves the contents of a Git repository to Git clients accessing the repository over HTTP and HTTPS protocols. The program supports fetching using both the smart HTTP protocol and the backwards-compatible dumb HTTP protocol, as well as pushing using the smart HTTP protocol. It also supports Git\u2019s more-efficient \"v2\" protocol if properly configured.",
            "api_name_original": "git-http-backend",
            "api_arguments_original": [
                "GIT_PROJECT_ROOT",
                "GIT_HTTP_EXPORT_ALL",
                "http.getanyfile",
                "http.uploadpack",
                "http.receivepack"
            ]
        }
    },
    {
        "query": "I want to use the git-gui tool to perform a blame operation on the README.md file in the current working directory.",
        "model_answer": "git.gui.blame(\"README.md\")",
        "original": {
            "domain": "github",
            "framework": "Tcl/Tk",
            "functionality": "Provides a graphical interface for git operations",
            "api_name": "git.gui.blame",
            "api_call": "git gui [<command>] [<arguments>]",
            "api_arguments": [
                {
                    "name": "command"
                },
                {
                    "name": "arguments"
                }
            ],
            "python_environment_requirements": [
                "Tcl/Tk"
            ],
            "example_code": [
                {
                    "description": "Show the contents of the file Makefile in the current working directory, and provide annotations for both the original author of each line, and who moved the line to its current location. The uncommitted file is annotated, and uncommitted changes (if any) are explicitly attributed to Not Yet Committed.",
                    "code": "git gui blame Makefile"
                },
                {
                    "description": "Make one commit and return to the shell when it is complete. This command returns a non-zero exit code if the window was closed in any way other than by making a commit.",
                    "code": "git gui citool"
                },
                {
                    "description": "Show a browser for the tree of the maint branch. Files selected in the browser can be viewed with the internal blame viewer.",
                    "code": "git gui browser maint"
                }
            ],
            "description": "git-gui is a Tcl/Tk based graphical user interface to Git. It allows users to make changes to their repository by making new commits, amending existing ones, creating branches, performing local merges, and fetching/pushing to remote repositories. It is known to work on all popular UNIX systems, Mac OS X, and Windows (under both Cygwin and MSYS).",
            "api_name_original": "git-gui",
            "api_arguments_original": [
                "<command>",
                "<arguments>"
            ]
        }
    },
    {
        "query": "I want to show the packed archive index in Git using the SHA-1 hash algorithm.",
        "model_answer": "git.show_index(\"--object-format=sha1\")",
        "original": {
            "domain": "git",
            "framework": "Git",
            "functionality": "Show packed archive index",
            "api_name": "git.show_index",
            "api_call": "git show-index [--object-format=<hash-algorithm>]",
            "api_arguments": [
                {
                    "name": "object_format"
                }
            ],
            "python_environment_requirements": [],
            "example_code": [],
            "description": "The git-show-index API reads the .idx file for a Git packfile (created with git-pack-objects[1] or git-index-pack[1]) from the standard input, and dumps its contents. The output consists of one object per line, with each line containing two or three space-separated columns: the first column is the offset in bytes of the object within the corresponding packfile, the second column is the object id of the object. If the index version is 2 or higher, the third column contains the CRC32 of the object data. The objects are output in the order in which they are found in the index file, which should be (in a correctly constructed file) sorted by object id.",
            "api_name_original": "git-show-index",
            "api_arguments_original": [
                "--object-format=<hash-algorithm>"
            ]
        }
    },
    {
        "query": "I want to reset the recorded resolution of conflicted merges in Git and clear the rerere metadata.",
        "model_answer": "git.rerere.clear()",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Reuse recorded resolution of conflicted merges",
            "api_name": "git.rerere.clear",
            "api_call": "git rerere [clear | forget <pathspec>\u2026\u200b | diff | status | remaining | gc]",
            "api_arguments": [
                {
                    "name": "clear"
                },
                {
                    "name": "forget"
                },
                {
                    "name": "diff"
                },
                {
                    "name": "status"
                },
                {
                    "name": "remaining"
                },
                {
                    "name": "gc"
                }
            ],
            "python_environment_requirements": "Git",
            "example_code": [
                {
                    "description": "Reset the metadata used by rerere if a merge resolution is to be aborted.",
                    "code": "git rerere clear"
                },
                {
                    "description": "Reset the conflict resolutions which rerere has recorded for the current conflict in <pathspec>.",
                    "code": "git rerere forget <pathspec>"
                },
                {
                    "description": "Display diffs for the current state of the resolution.",
                    "code": "git rerere diff"
                },
                {
                    "description": "Print paths with conflicts whose merge resolution rerere will record.",
                    "code": "git rerere status"
                },
                {
                    "description": "Print paths with conflicts that have not been autoresolved by rerere.",
                    "code": "git rerere remaining"
                },
                {
                    "description": "Prune records of conflicted merges that occurred a long time ago.",
                    "code": "git rerere gc"
                }
            ],
            "description": "The git-rerere command is used to reuse recorded resolution of conflicted merges. This command assists the developer in this process by recording conflicted automerge results and corresponding hand resolve results on the initial manual merge, and applying previously recorded hand resolutions to their corresponding automerge results. It is particularly useful in a workflow employing relatively long lived topic branches, where the developer sometimes needs to resolve the same conflicts over and over again until the topic branches are done.",
            "api_name_original": "git-rerere",
            "api_arguments_original": [
                "clear",
                "forget",
                "diff",
                "status",
                "remaining",
                "gc"
            ]
        }
    },
    {
        "query": "I want to generate a summary of pending changes and send a pull request to my upstream project. The branch I want to merge is 'feature-branch', and the upstream repository URL is 'https://github.com/upstream-repo'. The commit I started my work from is 'abc123' and the commit I want to end the changes at is 'def456'.",
        "model_answer": "git.request_pull(start=\"abc123\", URL=\"https://github.com/upstream-repo\", end=\"def456\")",
        "original": {
            "domain": "github",
            "framework": "git",
            "functionality": "Generates a summary of pending changes",
            "api_name": "git.request_pull",
            "api_call": "git request-pull [-p] <start> <URL> [<end>]",
            "api_arguments": [
                {
                    "name": "_p"
                },
                {
                    "name": "start"
                },
                {
                    "name": "url"
                },
                {
                    "name": "end"
                }
            ],
            "python_environment_requirements": [],
            "example_code": [
                {
                    "description": "Imagine that you built your work on your master branch on top of the v1.0 release, and want it to be integrated to the project. First you push that change to your public repository for others to see.",
                    "code": "git push https://git.ko.xz/project master"
                },
                {
                    "description": "Then, you run this command:",
                    "code": "git request-pull v1.0 https://git.ko.xz/project master"
                },
                {
                    "description": "If you pushed your change to a branch whose name is different from the one you have locally, e.g.",
                    "code": "git push https://git.ko.xz/project master:for-linus"
                },
                {
                    "description": "then you can ask that to be pulled with",
                    "code": "git request-pull v1.0 https://git.ko.xz/project master:for-linus"
                }
            ],
            "description": "The git-request-pull API generates a request asking your upstream project to pull changes into their tree. The request, printed to the standard output, begins with the branch description, summarizes the changes and indicates from where they can be pulled. The upstream project is expected to have the commit named by <start> and the output asks it to integrate the changes you made since that commit, up to the commit named by <end>, by visiting the repository named by <URL>.",
            "api_name_original": "git-request-pull",
            "api_arguments_original": [
                "-p",
                "<start>",
                "<URL>",
                "<end>"
            ]
        }
    },
    {
        "query": "I want to search for the pattern \"print\" in all python files in the current working directory and its subdirectories using the git grep command.",
        "model_answer": "git.grep(search_pattern=\"print\")",
        "original": {
            "domain": "git",
            "framework": "Git",
            "functionality": "Search for specified patterns in tracked files",
            "api_name": "git.grep",
            "api_call": "git grep 'search_pattern'",
            "api_arguments": [
                {
                    "name": "search_pattern",
                    "description": "The pattern to search for"
                }
            ],
            "python_environment_requirements": "Git must be installed and the user must have the necessary permissions to execute git commands",
            "example_code": [
                {
                    "description": "Looks for time_t in all tracked .c and .h files in the working directory and its subdirectories.",
                    "code": "git grep 'time_t' -- '*.[ch]'"
                },
                {
                    "description": "Looks for a line that has #define and either MAX_PATH or PATH_MAX.",
                    "code": "git grep -e '#define' --and \\( -e MAX_PATH -e PATH_MAX \\)"
                },
                {
                    "description": "Looks for a line that has NODE or Unexpected in files that have lines that match both.",
                    "code": "git grep --all-match -e NODE -e Unexpected"
                },
                {
                    "description": "Looks for solution, excluding files in Documentation.",
                    "code": "git grep solution -- :^Documentation"
                }
            ],
            "description": "The git-grep command is used to print lines matching a specified pattern. It can search in tracked files in the work tree, blobs registered in the index file, or blobs in given tree objects. The command supports various options for controlling the search, such as ignoring case differences, processing binary files as text, limiting the depth of directory descent, and many more.",
            "api_name_original": "git-grep",
            "api_arguments_original": {
                "search_pattern": "The pattern to search for"
            }
        }
    },
    {
        "query": "I want to get the detailed data for a service instance named instance-one for the service simple-svc on AWS Proton.",
        "model_answer": "aws.proton.get_service_instance(name=\"instance-one\", service_name=\"simple-svc\")",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Ignore specific files",
            "api_name": "aws.proton.get_service_instance",
            "api_call": "git ls-files --others --ignored --exclude-standard",
            "api_arguments": [
                {
                    "name": "file_patterns"
                }
            ],
            "python_environment_requirements": [
                "gitpython"
            ],
            "example_code": [
                {
                    "description": "Example to exclude everything except a specific directory foo/bar",
                    "code": "$ cat .gitignore\n# exclude everything except directory foo/bar\n/*\n!/foo\n/foo/*\n!/foo/bar"
                }
            ],
            "description": "A gitignore file specifies intentionally untracked files that Git should ignore. Files already tracked by Git are not affected. Each line in a gitignore file specifies a pattern. When deciding whether to ignore a path, Git normally checks gitignore patterns from multiple sources, with the following order of precedence, from highest to lowest (within one level of precedence, the last matching pattern decides the outcome): Patterns read from the command line for those commands that support them. Patterns read from a .gitignore file in the same directory as the path, or in any parent directory (up to the top-level of the working tree), with patterns in the higher level files being overridden by those in lower level files down to the directory containing the file. These patterns match relative to the location of the .gitignore file. A project normally includes such .gitignore files in its repository, containing patterns for files generated as part of the project build. Patterns read from $GIT_DIR/info/exclude. Patterns read from the file specified by the configuration variable core.excludesFile.",
            "api_name_original": "gitignore",
            "api_arguments_original": [
                "file patterns"
            ]
        }
    },
    {
        "query": "I want to compare and edit files between revisions using git difftool, and I want to use the tool 'kdiff3' for the comparison.",
        "model_answer": "git.difftool(tool='kdiff3')",
        "original": {
            "domain": "github",
            "framework": "git",
            "functionality": "Compare and edit files between revisions",
            "api_name": "git.difftool",
            "api_call": "git difftool [<options>] [<commit> [<commit>]] [--] [<path>\u2026\u200b]",
            "api_arguments": [
                {
                    "name": "_d,_dir_diff"
                },
                {
                    "name": "_y,_no_prompt"
                },
                {
                    "name": "prompt"
                },
                {
                    "name": "rotate_to"
                },
                {
                    "name": "skip_to"
                },
                {
                    "name": "_t_tool,_tool"
                },
                {
                    "name": "tool_help"
                },
                {
                    "name": "[no_]symlinks"
                },
                {
                    "name": "_x_command,_extcmd"
                },
                {
                    "name": "_g,_[no_]gui"
                },
                {
                    "name": "[no_]trust_exit_code"
                }
            ],
            "python_environment_requirements": [
                "git"
            ],
            "example_code": [],
            "description": "git difftool is a Git command that allows you to compare and edit files between revisions using common diff tools. It is a frontend to git diff and accepts the same options and arguments. It can use different diff tools specified by the user, and can be configured to run an alternative program by specifying the command line to invoke in a configuration variable. It can also be configured to use a GUI diff tool instead of a command line one. The tool can be invoked with various options to modify its behavior.",
            "api_name_original": "git-difftool",
            "api_arguments_original": [
                "-d, --dir-diff",
                "-y, --no-prompt",
                "--prompt",
                "--rotate-to=<file>",
                "--skip-to=<file>",
                "-t <tool>, --tool=<tool>",
                "--tool-help",
                "--[no-]symlinks",
                "-x <command>, --extcmd=<command>",
                "-g, --[no-]gui",
                "--[no-]trust-exit-code"
            ]
        }
    },
    {
        "query": "I want to know the capabilities of the git protocol.",
        "model_answer": "git.protocol_capabilities()",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Protocol v0 and v1 capabilities",
            "api_name": "git.protocol_capabilities",
            "api_call": "No direct api call",
            "api_arguments": "No direct arguments",
            "python_environment_requirements": "No specific requirements",
            "example_code": "No example code",
            "description": "This document describes capabilities for versions 0 and 1 of the pack protocol. Servers should support all capabilities defined in this document. Capabilities allow the server to declare what it can and cannot support to the client. Client will then send a list of capabilities it wants to be in effect. The client must not ask for capabilities the server did not say it supports. Server must diagnose and abort if capabilities it does not understand was sent. Server must not ignore capabilities that client requested and server advertised. As a consequence of these rules, server must not advertise capabilities it does not understand.",
            "api_name_original": "gitprotocol-capabilities",
            "api_arguments_original": "No direct arguments"
        }
    },
    {
        "query": "I want to update the index in a git repository by adding a new file with mode 100644, SHA1 \"ab4a5daef\", and path \"path/to/file.txt\".",
        "model_answer": "git.update_index(\"--add\", \"--cacheinfo\", \"100644,ab4a5daef,path/to/file.txt\")",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Update index",
            "api_name": "git.update_index(\"__add\", \"__cacheinfo\", \"100644,ab4a5daef,path/to/file.txt\"",
            "api_call": "git update-index --add --cacheinfo <mode>,<sha1>,<path>",
            "api_arguments": [
                {
                    "name": "add"
                },
                {
                    "name": "remove"
                },
                {
                    "name": "force_remove"
                },
                {
                    "name": "replace"
                },
                {
                    "name": "refresh"
                },
                {
                    "name": "_q"
                },
                {
                    "name": "unmerged"
                },
                {
                    "name": "ignore_missing"
                },
                {
                    "name": "cacheinfo_mode,object,file"
                },
                {
                    "name": "chmod"
                },
                {
                    "name": "[no_]assume_unchanged"
                },
                {
                    "name": "[no_]skip_worktree"
                },
                {
                    "name": "[no_]ignore_skip_worktree_entries"
                },
                {
                    "name": "[no_]fsmonitor_valid"
                },
                {
                    "name": "ignore_submodules"
                },
                {
                    "name": "[no_]split_index"
                },
                {
                    "name": "[no_|test_|force_]untracked_cache"
                },
                {
                    "name": "[no_]fsmonitor"
                },
                {
                    "name": "really_refresh"
                },
                {
                    "name": "unresolve"
                },
                {
                    "name": "again_|__g"
                },
                {
                    "name": "info_only"
                },
                {
                    "name": "index_info"
                },
                {
                    "name": "_z"
                },
                {
                    "name": "stdin"
                },
                {
                    "name": "index_version_n"
                },
                {
                    "name": "verbose"
                },
                {
                    "name": ""
                },
                {
                    "name": "file"
                }
            ],
            "python_environment_requirements": [
                "gitpython"
            ],
            "example_code": [
                {
                    "description": "To update and refresh only the files already checked out:",
                    "code": "git checkout-index -n -f -a && git update-index --ignore-missing --refresh"
                }
            ],
            "description": "The git-update-index command registers file contents in the working tree to the index. It is used to update the index with the latest changes in the working tree. It can add, remove, or replace entries in the index, and can also be used to refresh the index without changing its contents. It supports a wide range of options for controlling its behavior.",
            "api_name_original": "git-update-index",
            "api_arguments_original": [
                "--add",
                "--remove",
                "--force-remove",
                "--replace",
                "--refresh",
                "-q",
                "--unmerged",
                "--ignore-missing",
                "--cacheinfo <mode>,<object>,<file>",
                "--chmod=(+|-)x",
                "--[no-]assume-unchanged",
                "--[no-]skip-worktree",
                "--[no-]ignore-skip-worktree-entries",
                "--[no-]fsmonitor-valid",
                "--ignore-submodules",
                "--[no-]split-index",
                "--[no-|test-|force-]untracked-cache",
                "--[no-]fsmonitor",
                "--really-refresh",
                "--unresolve",
                "--again | -g",
                "--info-only",
                "--index-info",
                "-z",
                "--stdin",
                "--index-version <n>",
                "--verbose",
                "--",
                "<file>"
            ]
        }
    },
    {
        "query": "I want to add a new worktree called \"bug-fix\" with a new branch to the path \"../workspace\" and checkout the branch on the local git repository.",
        "model_answer": "git.worktree.add(\"-b\", \"bug-fix\", \"../workspace\", \"<commit-ish>\")",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Manage multiple working trees",
            "api_name": "git.worktree.add(\"_b\", \"emergency_fix\", \"../temp\", \"<commit_ish>\"",
            "api_call": "git worktree add [-f] [--detach] [--checkout] [--lock [--reason <string>]] [-b <new-branch>] <path> [<commit-ish>]",
            "api_arguments": [
                {
                    "name": "_f"
                },
                {
                    "name": "detach"
                },
                {
                    "name": "checkout"
                },
                {
                    "name": "lock"
                },
                {
                    "name": "reason"
                },
                {
                    "name": "_b"
                },
                {
                    "name": "new_branch"
                },
                {
                    "name": "path"
                },
                {
                    "name": "commit_ish"
                }
            ],
            "python_environment_requirements": [],
            "example_code": [
                {
                    "description": "You are in the middle of a refactoring session and your boss comes in and demands that you fix something immediately. You might typically use git-stash[1] to store your changes away temporarily, however, your working tree is in such a state of disarray (with new, moved, and removed files, and other bits and pieces strewn around) that you don\u2019t want to risk disturbing any of it. Instead, you create a temporary linked worktree to make the emergency fix, remove it when done, and then resume your earlier refactoring session.",
                    "code": "$ git worktree add -b emergency-fix ../temp master\n$ pushd ../temp\n# ... hack hack hack ...\n$ git commit -a -m 'emergency fix for boss'\n$ popd\n$ git worktree remove ../temp"
                }
            ],
            "description": "The git-worktree API allows you to manage multiple working trees attached to the same repository. This is useful when you want to work on more than one branch at a time. Each working tree will have its own index and working directory, separate from the others. You can add, list, lock, move, prune, remove, repair and unlock worktrees. The API is part of the Git suite and is used via the command line.",
            "api_name_original": "git-worktree",
            "api_arguments_original": [
                "-f",
                "--detach",
                "--checkout",
                "--lock",
                "--reason",
                "-b",
                "<new-branch>",
                "<path>",
                "<commit-ish>"
            ]
        }
    },
    {
        "query": "I want to generate a merge commit message for a merge of the 'dev' branch from the 'origin' remote, with a custom message, and store the result in a file called \"merge_msg.txt\".",
        "model_answer": "git.fmt_merge_msg(\"-m 'Merge commit for dev branch from origin' -F merge_msg.txt\")",
        "original": {
            "domain": "git",
            "framework": "Git",
            "functionality": "Generate a merge commit message",
            "api_name": "git.fmt_merge_msg(\"_m 'Merge commit for master branch from origin' _F merge_msg.txt\"",
            "api_call": "git fmt-merge-msg [--log[=<n>] | --no-log] -F <file>",
            "api_arguments": [
                {
                    "name": "log["
                },
                {
                    "name": "no_log"
                },
                {
                    "name": "_m_message"
                },
                {
                    "name": "into_name_branch"
                },
                {
                    "name": "_f_file"
                }
            ],
            "python_environment_requirements": [],
            "example_code": [
                {
                    "description": "Print a log message describing a merge of the 'master' branch from the 'origin' remote.",
                    "code": "git fetch origin master\ngit fmt-merge-msg --log <$GIT_DIR/FETCH_HEAD"
                }
            ],
            "description": "The git-fmt-merge-msg API is used to generate a suitable commit message for a merge commit. It takes the list of merged objects on stdin and produces a message usually to be passed as the <merge-message> argument of git merge. This command is intended mostly for internal use by scripts automatically invoking git merge. It has various options to customize the message including adding branch names, one-line descriptions from the actual commits that are being merged, using a custom message instead of the branch names, preparing the message as if merging to a specific branch, and taking the list of merged objects from a file instead of stdin.",
            "api_name_original": "git-fmt-merge-msg",
            "api_arguments_original": [
                "--log[=<n>]",
                "--no-log",
                "-m <message>",
                "--into-name <branch>",
                "-F <file>"
            ]
        }
    },
    {
        "query": "I want to add a new remote to my git repository with the name \"production\" and the URL \"git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git\".",
        "model_answer": "git.remote.add(name=\"production\", URL=\"git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git\")",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Manage set of tracked repositories",
            "api_name": "git.remote.add(name=\"staging\", URL=\"git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging.git\"",
            "api_call": "git remote add [-t <branch>] [-m <master>] [-f] [--[no-]tags] [--mirror=(fetch|push)] <name> <URL>",
            "api_arguments": [
                {
                    "name": "_v_|_verbose"
                },
                {
                    "name": "_t_branch"
                },
                {
                    "name": "_m_master"
                },
                {
                    "name": "_f"
                },
                {
                    "name": "[no_]tags"
                },
                {
                    "name": "mirror"
                },
                {
                    "name": "name"
                },
                {
                    "name": "url"
                }
            ],
            "python_environment_requirements": [
                "git"
            ],
            "example_code": [
                {
                    "description": "Add a new remote, fetch, and check out a branch from it",
                    "code": "$ git remote\norigin\n$ git branch -r\n origin/HEAD -> origin/master\n origin/master\n$ git remote add staging git://git.kernel.org/.../gregkh/staging.git\n$ git remote\norigin\nstaging\n$ git fetch staging\n...\nFrom git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging\n * [new branch] master -> staging/master\n * [new branch] staging-linus -> staging/staging-linus\n * [new branch] staging-next -> staging/staging-next\n$ git branch -r\n origin/HEAD -> origin/master\n origin/master\n staging/master\n staging/staging-linus\n staging/staging-next\n$ git switch -c staging staging/master\n..."
                },
                {
                    "description": "Imitate git clone but track only selected branches",
                    "code": "$ mkdir project.git\n$ cd project.git\n$ git init\n$ git remote add -f -t master -m master origin git://example.com/git.git/\n$ git merge origin"
                }
            ],
            "description": "The git-remote command allows you to manage the set of repositories ('remotes') whose branches you track. You can add a new remote, rename an existing one, remove a remote, and perform other related operations. This command is particularly useful when you need to work with multiple remote repositories, as it allows you to easily switch between different project contexts.",
            "api_name_original": "git-remote",
            "api_arguments_original": [
                "-v | --verbose",
                "-t <branch>",
                "-m <master>",
                "-f",
                "--[no-]tags",
                "--mirror=(fetch|push)",
                "<name>",
                "<URL>"
            ]
        }
    },
    {
        "query": "I want to get the information for a specific git repository using the Git HTTP protocols.",
        "model_answer": "requests.get(\"$GIT_URL/info/refs?service=git-upload-pack\")",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Git HTTP-based protocols",
            "api_name": "requests.get",
            "api_call": "GET $GIT_URL/info/refs?service=git-upload-pack HTTP/1.0",
            "api_arguments": [
                {
                    "name": "$git_url"
                }
            ],
            "python_environment_requirements": [],
            "example_code": [
                {
                    "description": "Example of a smart request to a catch-all gateway",
                    "code": "$GIT_URL: http://example.com/daemon.cgi?svc=git&q=\nURL request: http://example.com/daemon.cgi?svc=git&q=/info/refs&service=git-receive-pack"
                }
            ],
            "description": "Git supports two HTTP based transfer protocols. A 'dumb' protocol which requires only a standard HTTP server on the server end of the connection, and a 'smart' protocol which requires a Git aware CGI (or server module). This document describes both protocols. As a design feature smart clients can automatically upgrade 'dumb' protocol URLs to smart URLs. This permits all users to have the same published URL, and the peers automatically select the most efficient transport available to them.",
            "api_name_original": "Git HTTP Protocols",
            "api_arguments_original": [
                "$GIT_URL"
            ]
        }
    },
    {
        "query": "I want to display the version information about Git and also get the build options for diagnostic purposes.",
        "model_answer": "git.version(build_options=True)",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Display version information about Git",
            "api_name": "git.version",
            "api_call": "git --version",
            "api_arguments": [
                {
                    "name": "build_options"
                }
            ],
            "python_environment_requirements": [],
            "example_code": [
                {
                    "description": "Check your version of git by running",
                    "code": "git --version"
                }
            ],
            "description": "With no options given, the version of git is printed on the standard output. Note that git --version is identical to git version because the former is internally converted into the latter. The '--build-options' argument includes additional information about how git was built for diagnostic purposes.",
            "api_name_original": "git-version",
            "api_arguments_original": [
                "--build-options"
            ]
        }
    },
    {
        "query": "I want to apply a series of patches from a mailbox to the current branch using git-am.",
        "model_answer": "git.am()",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Apply a series of patches from a mailbox",
            "api_name": "git.am",
            "api_call": "git am [--signoff] [--keep] [--[no-]keep-cr] [--[no-]utf8] [--no-verify] [--[no-]3way] [--interactive] [--committer-date-is-author-date] [--ignore-date] [--ignore-space-change | --ignore-whitespace] [--whitespace=<option>] [-C<n>] [-p<n>] [--directory=<dir>] [--exclude=<path>] [--include=<path>] [--reject] [-q | --quiet] [--[no-]scissors] [-S[<keyid>]] [--patch-format=<format>] [--quoted-cr=<action>] [--empty=(stop|drop|keep)] [(<mbox> | <Maildir>)\u2026\u200b]",
            "api_arguments": [
                {
                    "name": "signoff"
                },
                {
                    "name": "keep"
                },
                {
                    "name": "[no_]keep_cr"
                },
                {
                    "name": "[no_]utf8"
                },
                {
                    "name": "no_verify"
                },
                {
                    "name": "[no_]3way"
                },
                {
                    "name": "interactive"
                },
                {
                    "name": "committer_date_is_author_date"
                },
                {
                    "name": "ignore_date"
                },
                {
                    "name": "ignore_space_change_|_ignore_whitespace"
                },
                {
                    "name": "whitespace"
                },
                {
                    "name": "_cn"
                },
                {
                    "name": "_pn"
                },
                {
                    "name": "directory"
                },
                {
                    "name": "exclude"
                },
                {
                    "name": "include"
                },
                {
                    "name": "reject"
                },
                {
                    "name": "_q_|_quiet"
                },
                {
                    "name": "[no_]scissors"
                },
                {
                    "name": "_s[keyid]"
                },
                {
                    "name": "patch_format"
                },
                {
                    "name": "quoted_cr"
                },
                {
                    "name": "empty"
                },
                {
                    "name": "mbox_|_maildir\u2026\u200b"
                }
            ],
            "python_environment_requirements": [
                "git"
            ],
            "example_code": [],
            "description": "The git-am command applies a series of patches from a mailbox to the current branch. It splits mail messages into commit log message, authorship information and patches. It's a reverse operation of git-format-patch run on a branch with a straight history without merges. If a patch does not apply cleanly, it can fall back on 3-way merge if the patch records the identity of blobs it is supposed to apply to and we have those blobs available locally.",
            "api_name_original": "git-am",
            "api_arguments_original": [
                "--signoff",
                "--keep",
                "--[no-]keep-cr",
                "--[no-]utf8",
                "--no-verify",
                "--[no-]3way",
                "--interactive",
                "--committer-date-is-author-date",
                "--ignore-date",
                "--ignore-space-change | --ignore-whitespace",
                "--whitespace=<option>",
                "-C<n>",
                "-p<n>",
                "--directory=<dir>",
                "--exclude=<path>",
                "--include=<path>",
                "--reject",
                "-q | --quiet",
                "--[no-]scissors",
                "-S[<keyid>]",
                "--patch-format=<format>",
                "--quoted-cr=<action>",
                "--empty=(stop|drop|keep)",
                "(<mbox> | <Maildir>)\u2026\u200b"
            ]
        }
    },
    {
        "query": "I want to map author and committer names and email addresses to canonical real names and email addresses using the gitmailmap API. The .mailmap file exists at the top level of the repository and is used to map the names. Provide the path to the .mailmap file.",
        "model_answer": "git.mailmap(\"$GIT_WORK_TREE/.mailmap\")",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Map author/committer names and/or E-Mail addresses",
            "api_name": "git.mailmap(\"$GIT_WORK_TREE/.mailmap\"",
            "api_call": "$GIT_WORK_TREE/.mailmap",
            "api_arguments": [
                {
                    "name": "$git_work_tree/.mailmap"
                }
            ],
            "python_environment_requirements": [
                "git"
            ],
            "example_code": [
                {
                    "description": "Your history contains commits by two authors, Jane and Joe, whose names appear in the repository under several forms",
                    "code": "Joe Developer <joe@example.com>\nJoe R. Developer <joe@example.com>\nJane Doe <jane@example.com>\nJane Doe <jane@laptop.(none)>\nJane D. <jane@desktop.(none)>"
                }
            ],
            "description": "The gitmailmap API is used to map author and committer names and email addresses to canonical real names and email addresses. The .mailmap file exists at the top level of the repository and is used to map the names. The file can also be located by the mailmap.file or mailmap.blob configuration options. The API is part of the git suite and is accessed via the command line interface.",
            "api_name_original": "gitmailmap",
            "api_arguments_original": [
                "$GIT_WORK_TREE/.mailmap"
            ]
        }
    },
    {
        "query": "What is the version of Python installed on my system?",
        "model_answer": "python.version()",
        "original": {
            "domain": "git",
            "framework": "Git",
            "functionality": "Version Control",
            "api_name": "git.version",
            "api_call": "git --version",
            "api_arguments": "version",
            "python_environment_requirements": "gitpython",
            "example_code": [
                {
                    "description": "Check your version of git by running",
                    "code": "git --version"
                }
            ],
            "description": "The Git FAQ API provides answers to frequently asked questions about using Git. It covers various topics such as configuration, credentials, hooks, merging and rebasing, cross-platform issues and more. The API is designed to assist users in understanding and troubleshooting common issues encountered while using Git. It also provides advice on best practices for using Git and handling specific scenarios.",
            "api_name_original": "Git FAQ",
            "api_arguments_original": "version"
        }
    },
    {
        "query": "I want to remove all the *.csv files from the index that are under the Data directory and any of its subdirectories.",
        "model_answer": "git.rm(pathspec='Data/*.csv')",
        "original": {
            "domain": "github",
            "framework": "git",
            "functionality": "Remove files from the working tree and from the index",
            "api_name": "git.rm(pathspec='Documentation/*.txt'",
            "api_call": "git rm [<options>] [<file>...]",
            "api_arguments": [
                {
                    "name": "_f_|_force",
                    "description": "Override the up-to-date check."
                },
                {
                    "name": "_n_|_dry_run",
                    "description": "Don\u2019t actually remove any file(s). Instead, just show if they exist in the index and would otherwise be removed by the command."
                },
                {
                    "name": "_r",
                    "description": "Allow recursive removal when a leading directory name is given."
                },
                {
                    "name": "cached",
                    "description": "Use this option to unstage and remove paths only from the index. Working tree files, whether modified or not, will be left alone."
                },
                {
                    "name": "ignore_unmatch",
                    "description": "Exit with a zero status even if no files matched."
                },
                {
                    "name": "sparse",
                    "description": "Allow updating index entries outside of the sparse-checkout cone."
                },
                {
                    "name": "_q_|_quiet",
                    "description": "git rm normally outputs one line (in the form of an rm command) for each file removed. This option suppresses that output."
                },
                {
                    "name": "pathspec_from_file",
                    "description": "Pathspec is passed in <file> instead of commandline args."
                },
                {
                    "name": "pathspec_file_nul",
                    "description": "Only meaningful with --pathspec-from-file. Pathspec elements are separated with NUL character and all other characters are taken literally (including newlines and quotes)."
                }
            ],
            "python_environment_requirements": "Git version 1.7.8 or newer",
            "example_code": [
                {
                    "description": "Removes all *.txt files from the index that are under the Documentation directory and any of its subdirectories.",
                    "code": "git rm Documentation/\\*.txt"
                },
                {
                    "description": "Because this example lets the shell expand the asterisk (i.e. you are listing the files explicitly), it does not remove subdir/git-foo.sh.",
                    "code": "git rm -f git-*.sh"
                }
            ],
            "description": "The 'git rm' command is used to remove files from the working tree and from the index. The files being removed have to be identical to the tip of the branch, and no updates to their contents can be staged in the index. When --cached is given, the staged content has to match either the tip of the branch or the file on disk, allowing the file to be removed from just the index.",
            "api_name_original": "git-rm",
            "api_arguments_original": {
                "-f | --force": "Override the up-to-date check.",
                "-n | --dry-run": "Don\u2019t actually remove any file(s). Instead, just show if they exist in the index and would otherwise be removed by the command.",
                "-r": "Allow recursive removal when a leading directory name is given.",
                "--cached": "Use this option to unstage and remove paths only from the index. Working tree files, whether modified or not, will be left alone.",
                "--ignore-unmatch": "Exit with a zero status even if no files matched.",
                "--sparse": "Allow updating index entries outside of the sparse-checkout cone.",
                "-q | --quiet": "git rm normally outputs one line (in the form of an rm command) for each file removed. This option suppresses that output.",
                "--pathspec-from-file=<file>": "Pathspec is passed in <file> instead of commandline args.",
                "--pathspec-file-nul": "Only meaningful with --pathspec-from-file. Pathspec elements are separated with NUL character and all other characters are taken literally (including newlines and quotes)."
            }
        }
    },
    {
        "query": "I want to display gitattributes information for a file named org/example/MyClass.java.",
        "model_answer": "git.check_attr(pathname=\"org/example/MyClass.java\")",
        "original": {
            "domain": "github",
            "framework": "git",
            "functionality": "Display gitattributes information",
            "api_name": "git.check_attr(pathname=\"org/example/MyClass.java\"",
            "api_call": "git check-attr [--source <tree-ish>] [-a | --all | <attr>\u2026\u200b] [--] <pathname>\u2026\u200b",
            "api_arguments": [
                {
                    "name": "source_tree_ish"
                },
                {
                    "name": "_a,_all"
                },
                {
                    "name": "attr"
                },
                {
                    "name": "pathname"
                }
            ],
            "python_environment_requirements": [],
            "example_code": [
                {
                    "description": "Listing a single attribute",
                    "code": "$ git check-attr diff org/example/MyClass.java"
                },
                {
                    "description": "Listing multiple attributes for a file",
                    "code": "$ git check-attr crlf diff myAttr -- org/example/MyClass.java"
                },
                {
                    "description": "Listing all attributes for a file",
                    "code": "$ git check-attr --all -- org/example/MyClass.java"
                },
                {
                    "description": "Listing an attribute for multiple files",
                    "code": "$ git check-attr myAttr -- org/example/MyClass.java org/example/NoMyAttr.java"
                },
                {
                    "description": "Not all values are equally unambiguous",
                    "code": "$ git check-attr caveat README"
                }
            ],
            "description": "The git-check-attr API is used to display gitattributes information for every pathname. It lists if each attribute is unspecified, set, or unset as a gitattribute on that pathname. It also provides options to list all attributes associated with the specified paths, consider .gitattributes in the index only, read pathnames from the standard input, modify the output format to be machine-parsable, and check attributes against a specified tree-ish.",
            "api_name_original": "git-check-attr",
            "api_arguments_original": [
                "--source <tree-ish>",
                "-a, --all",
                "<attr>",
                "<pathname>"
            ]
        }
    },
    {
        "query": "I want to start the git daemon on port 9418 and serve the repositories located in the directory /var/git.",
        "model_answer": "git.daemon(verbose=True, listen='0.0.0.0', port=9418, directory='/var/git')",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Provides a simple server for Git repositories",
            "api_name": "git.daemon(verbose=True, listen='0.0.0.0', port=9418, directory='/var/git'",
            "api_call": "git daemon [--verbose] [--syslog] [--export-all] [--timeout=<n>] [--init-timeout=<n>] [--max-connections=<n>] [--strict-paths] [--base-path=<path>] [--base-path-relaxed] [--user-path | --user-path=<path>] [--interpolated-path=<pathtemplate>] [--reuseaddr] [--detach] [--pid-file=<file>] [--enable=<service>] [--disable=<service>] [--allow-override=<service>] [--forbid-override=<service>] [--access-hook=<path>] [--[no-]informative-errors] [--inetd | [--listen=<host_or_ipaddr>] [--port=<n>] [--user=<user> [--group=<group>]]] [--log-destination=(stderr|syslog|none)] [<directory>\u2026\u200b]",
            "api_arguments": [
                {
                    "name": "verbose"
                },
                {
                    "name": "syslog"
                },
                {
                    "name": "export_all"
                },
                {
                    "name": "timeout"
                },
                {
                    "name": "init_timeout"
                },
                {
                    "name": "max_connections"
                },
                {
                    "name": "strict_paths"
                },
                {
                    "name": "base_path"
                },
                {
                    "name": "base_path_relaxed"
                },
                {
                    "name": "user_path"
                },
                {
                    "name": "interpolated_path"
                },
                {
                    "name": "reuseaddr"
                },
                {
                    "name": "detach"
                },
                {
                    "name": "pid_file"
                },
                {
                    "name": "enable"
                },
                {
                    "name": "disable"
                },
                {
                    "name": "allow_override"
                },
                {
                    "name": "forbid_override"
                },
                {
                    "name": "access_hook"
                },
                {
                    "name": "informative_errors"
                },
                {
                    "name": "inetd"
                },
                {
                    "name": "listen"
                },
                {
                    "name": "port"
                },
                {
                    "name": "user"
                },
                {
                    "name": "group"
                },
                {
                    "name": "log_destination"
                },
                {
                    "name": "directory"
                }
            ],
            "python_environment_requirements": [
                "git"
            ],
            "example_code": [
                {
                    "description": "git daemon as regular daemon for virtual hosts",
                    "code": "git daemon --verbose --export-all --interpolated-path=/pub/%IP/%D /pub/192.168.1.200/software /pub/10.10.220.23/software"
                }
            ],
            "description": "The git-daemon is a simple TCP Git daemon that listens on a specified port and serves a specified service if it is enabled. It is ideal for read-only updates, such as pulling from Git repositories. It also supports virtual hosting and can be set up as a regular, non-inetd service that handles repositories for multiple virtual hosts based on their IP addresses.",
            "api_name_original": "git-daemon",
            "api_arguments_original": [
                "--verbose",
                "--syslog",
                "--export-all",
                "--timeout",
                "--init-timeout",
                "--max-connections",
                "--strict-paths",
                "--base-path",
                "--base-path-relaxed",
                "--user-path",
                "--interpolated-path",
                "--reuseaddr",
                "--detach",
                "--pid-file",
                "--enable",
                "--disable",
                "--allow-override",
                "--forbid-override",
                "--access-hook",
                "--informative-errors",
                "--inetd",
                "--listen",
                "--port",
                "--user",
                "--group",
                "--log-destination",
                "<directory>"
            ]
        }
    },
    {
        "query": "I want to list all the branches in a local git repository.",
        "model_answer": "git.show_ref(\"--heads\")",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "List references in a local repository",
            "api_name": "git.show_ref",
            "api_call": "git show-ref",
            "api_arguments": [
                {
                    "name": "_q_|_quiet"
                },
                {
                    "name": "verify"
                },
                {
                    "name": "head"
                },
                {
                    "name": "_d_|_dereference"
                },
                {
                    "name": "_s_|_hash["
                },
                {
                    "name": "abbrev["
                },
                {
                    "name": "tags"
                },
                {
                    "name": "heads"
                },
                {
                    "name": ""
                },
                {
                    "name": "[pattern\u2026\u200b]"
                },
                {
                    "name": "exclude_existing["
                }
            ],
            "python_environment_requirements": "git",
            "example_code": [
                {
                    "description": "To show all references called 'master', whether tags or heads or anything else, and regardless of how deep in the reference naming hierarchy they are",
                    "code": "git show-ref master"
                },
                {
                    "description": "When using the --verify flag, the command requires an exact path",
                    "code": "git show-ref --verify refs/heads/master"
                },
                {
                    "description": "For scripting, you can ask it to be quiet with the '--quiet' flag",
                    "code": "git show-ref --quiet --verify -- 'refs/heads/$headname' || echo '$headname is not a valid branch'"
                },
                {
                    "description": "To show only tags, or only proper branch heads, use '--tags' and/or '--heads' respectively",
                    "code": "git show-ref --tags --dereference"
                }
            ],
            "description": "The git-show-ref API is used to list references available in a local repository along with the associated commit IDs. Results can be filtered using a pattern and tags can be dereferenced into object IDs. It can also be used to test whether a particular ref exists. By default, it shows the tags, heads, and remote refs. The --exclude-existing form is a filter that does the inverse. It reads refs from stdin, one ref per line, and shows those that don\u2019t exist in the local repository. Use of this utility is encouraged in favor of directly accessing files under the .git directory.",
            "api_name_original": "git-show-ref",
            "api_arguments_original": [
                "-q | --quiet",
                "--verify",
                "--head",
                "-d | --dereference",
                "-s | --hash[=<n>]",
                "--abbrev[=<n>]",
                "--tags",
                "--heads",
                "--",
                "[<pattern>\u2026\u200b]",
                "--exclude-existing[=<pattern>]"
            ]
        }
    },
    {
        "query": "I want to get the path and currently checked out commit for each submodule in my Git repository.",
        "model_answer": "git.submodule.foreach('echo $sm_path `git rev-parse HEAD`')",
        "original": {
            "domain": "git",
            "framework": "Git",
            "functionality": "Submodule management",
            "api_name": "git.submodule.foreach",
            "api_call": "git submodule [--quiet] [--cached]",
            "api_arguments": [
                {
                    "name": "quiet"
                },
                {
                    "name": "cached"
                }
            ],
            "python_environment_requirements": [],
            "example_code": [
                {
                    "description": "Show the path and currently checked out commit for each submodule",
                    "code": "git submodule foreach 'echo $sm_path `git rev-parse HEAD`'"
                }
            ],
            "description": "The git-submodule provides functionality to manage, inspect and update submodules in a Git repository. It supports multiple subcommands for different operations such as adding a new submodule, initializing or deinitializing existing submodules, updating submodules, etc. The submodules are like nested git repositories which can be managed independently or in correlation with the main repository.",
            "api_name_original": "git-submodule",
            "api_arguments_original": [
                "--quiet",
                "--cached"
            ]
        }
    },
    {
        "query": "Please provide information about the structure and contents of a Git repository.",
        "model_answer": "gitrepository_layout()",
        "original": {
            "domain": "git",
            "framework": "Git",
            "functionality": "Git Repository Layout",
            "api_name": "gitrepository_layout(",
            "api_call": "git --version",
            "api_arguments": [],
            "python_environment_requirements": [],
            "example_code": [],
            "description": "The gitrepository-layout API provides information about the layout of a Git repository. It includes details about the structure and contents of a repository, such as branches, hooks, logs, and configuration files. It also provides information about the different versions of the Git repository format. This API is typically used for understanding the structure of a Git repository and for troubleshooting issues.",
            "api_name_original": "gitrepository-layout",
            "api_arguments_original": []
        }
    },
    {
        "query": "Add a sign trailer with a Signed-off-by key, and then add two of these trailers to a message file named \"message.txt\".",
        "model_answer": "git.interpret_trailers(trailer=[\"sign: Alice <alice@example.com>\", \"sign: Bob <bob@example.com>\"], file=\"message.txt\")",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Add or parse structured information in commit messages",
            "api_name": "git.interpret_trailers(trailer=[\"sign: Alice <alice@example.com>\", \"sign: Bob <bob@example.com>\"], file=\"msg.txt\"",
            "api_call": "git interpret-trailers [--in-place] [--trim-empty] [(--trailer <token>[(=|:)<value>])\u2026\u200b] [--parse] [<file>\u2026\u200b]",
            "api_arguments": [
                {
                    "name": "in_place"
                },
                {
                    "name": "trim_empty"
                },
                {
                    "name": "trailer"
                },
                {
                    "name": "parse"
                },
                {
                    "name": "file"
                }
            ],
            "python_environment_requirements": [],
            "example_code": [
                {
                    "description": "Configure a sign trailer with a Signed-off-by key, and then add two of these trailers to a message:",
                    "code": "$ git config trailer.sign.key \"Signed-off-by\"\n$ cat msg.txt\nsubject\nmessage\n$ git interpret-trailers --trailer 'sign: Alice <alice@example.com>' --trailer 'sign: Bob <bob@example.com>' <msg.txt\nsubject\nmessage\nSigned-off-by: Alice <alice@example.com>\nSigned-off-by: Bob <bob@example.com>"
                },
                {
                    "description": "Use the --in-place option to edit a message file in place:",
                    "code": "$ cat msg.txt\nsubject\nmessage\nSigned-off-by: Bob <bob@example.com>\n$ git interpret-trailers --trailer 'Acked-by: Alice <alice@example.com>' --in-place msg.txt\n$ cat msg.txt\nsubject\nmessage\nSigned-off-by: Bob <bob@example.com>\nAcked-by: Alice <alice@example.com>"
                },
                {
                    "description": "Extract the last commit as a patch, and add a Cc and a Reviewed-by trailer to it:",
                    "code": "$ git format-patch -1\n0001-foo.patch\n$ git interpret-trailers --trailer 'Cc: Alice <alice@example.com>' --trailer 'Reviewed-by: Bob <bob@example.com>' 0001-foo.patch >0001-bar.patch"
                }
            ],
            "description": "The git-interpret-trailers command is used to add or parse structured information in commit messages. This command reads some patches or commit messages from either the <file> arguments or the standard input if no <file> is specified. If --parse is specified, the output consists of the parsed trailers. Otherwise, this command applies the arguments passed using the --trailer option, if any, to the commit message part of each input file. The result is emitted on the standard output.",
            "api_name_original": "git-interpret-trailers",
            "api_arguments_original": [
                "--in-place",
                "--trim-empty",
                "--trailer",
                "--parse",
                "<file>"
            ]
        }
    },
    {
        "query": "I want to see the reflog for the branch \"feature/add-login\" in Git.",
        "model_answer": "git.reflog.show('feature/add-login')",
        "original": {
            "domain": "git",
            "framework": "Git",
            "functionality": "Manage reflog information",
            "api_name": "git.reflog.show",
            "api_call": "git reflog [show] [<log-options>] [<ref>]",
            "api_arguments": [
                {
                    "name": "show"
                },
                {
                    "name": "log_options"
                },
                {
                    "name": "ref"
                }
            ],
            "python_environment_requirements": "Git",
            "example_code": [],
            "description": "The git-reflog command is used to manage the information recorded in the reflogs. Reflogs record when the tips of branches and other references were updated in the local repository. They are used in various Git commands to specify the old value of a reference. The command takes various subcommands and different options depending on the subcommand. The 'show' subcommand shows the log of the reference provided in the command-line. The 'expire' subcommand prunes older reflog entries. The 'delete' subcommand deletes single entries from the reflog. The 'exists' subcommand checks whether a ref has a reflog.",
            "api_name_original": "git-reflog",
            "api_arguments_original": [
                "show",
                "<log-options>",
                "<ref>"
            ]
        }
    },
    {
        "query": "I want to switch to a different branch called \"feature/new-branch\" in my Git repository.",
        "model_answer": "git.checkout(\"feature/new-branch\")",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Switch branches or restore working tree files",
            "api_name": "git.checkout",
            "api_call": "git checkout [<branch>]",
            "api_arguments": [
                {
                    "name": "_q"
                },
                {
                    "name": "_f"
                },
                {
                    "name": "_m"
                },
                {
                    "name": "branch"
                },
                {
                    "name": "detach"
                },
                {
                    "name": "commit"
                },
                {
                    "name": "new_branch"
                },
                {
                    "name": "start_point"
                },
                {
                    "name": "tree_ish"
                },
                {
                    "name": "pathspec"
                },
                {
                    "name": "_p"
                },
                {
                    "name": "patch"
                }
            ],
            "python_environment_requirements": [],
            "example_code": [
                {
                    "description": "Switch to a different branch",
                    "code": "git checkout my_new_branch"
                },
                {
                    "description": "Create a new branch and switch to it",
                    "code": "git checkout -b my_new_branch"
                },
                {
                    "description": "Restore a file to its state at the last commit",
                    "code": "git checkout -- my_file.txt"
                }
            ],
            "description": "The git-checkout command is used to switch between different branches or restore files in your working tree to their state at a specific commit. This can be useful for testing changes in a separate branch before merging them into the main branch, or for undoing changes to specific files. You can specify a branch to switch to, a commit to restore files from, or a pathspec to limit the files affected by the checkout operation. You can also use various flags to modify the behavior of the command, such as -q to suppress output, -f to force the checkout operation even if there are uncommitted changes, or -m to attempt a three-way merge when switching branches.",
            "api_name_original": "git-checkout",
            "api_arguments_original": [
                "-q",
                "-f",
                "-m",
                "<branch>",
                "--detach",
                "<commit>",
                "<new-branch>",
                "<start-point>",
                "<tree-ish>",
                "<pathspec>",
                "-p",
                "--patch"
            ]
        }
    },
    {
        "query": "I want to create a symbolic reference in Git named \"my-ref\" that points to the branch \"my-branch\".",
        "model_answer": "git.symbolic_ref(\"my-ref\", \"refs/heads/my-branch\")",
        "original": {
            "domain": "github",
            "framework": "git",
            "functionality": "Read, modify and delete symbolic refs",
            "api_name": "git.symbolic_ref",
            "api_call": "git symbolic-ref [-m <reason>] <name> <ref>",
            "api_arguments": [
                {
                    "name": "_m_reason"
                },
                {
                    "name": "name"
                },
                {
                    "name": "ref"
                }
            ],
            "python_environment_requirements": "git",
            "example_code": [],
            "description": "The git-symbolic-ref API is used to read, modify, and delete symbolic refs. Given one argument, it reads which branch head the given symbolic ref refers to and outputs its path, relative to the .git/ directory. Given two arguments, it creates or updates a symbolic ref to point at the given branch. Given --delete and an additional argument, it deletes the given symbolic ref.",
            "api_name_original": "git-symbolic-ref",
            "api_arguments_original": [
                "-m <reason>",
                "<name>",
                "<ref>"
            ]
        }
    },
    {
        "query": "I want to send objects packed back to git-fetch-pack.",
        "model_answer": "git_upload_pack()",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Send objects packed back to git-fetch-pack",
            "api_name": "git_upload_pack(",
            "api_call": "git-upload-pack [--[no-]strict] [--timeout=<n>] [--stateless-rpc] [--advertise-refs] <directory>",
            "api_arguments": [
                {
                    "name": "[no_]strict"
                },
                {
                    "name": "timeout"
                },
                {
                    "name": "stateless_rpc"
                },
                {
                    "name": "advertise_refs"
                },
                {
                    "name": "directory"
                }
            ],
            "python_environment_requirements": [],
            "example_code": [],
            "description": "The git-upload-pack API is invoked by git fetch-pack, it learns what objects the other side is missing, and sends them after packing. This command is usually not invoked directly by the end user. The UI for the protocol is on the git fetch-pack side, and the program pair is meant to be used to pull updates from a remote repository. For push operations, see git send-pack.",
            "api_name_original": "git-upload-pack",
            "api_arguments_original": [
                "--[no-]strict",
                "--timeout=<n>",
                "--stateless-rpc",
                "--advertise-refs",
                "<directory>"
            ]
        }
    },
    {
        "query": "I would like to collect information for a bug report in Git and save it in the directory \"/path/to/output\".",
        "model_answer": "git.bugreport(\"-o\", \"/path/to/output\")",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Collects information for bug report",
            "api_name": "git.bugreport",
            "api_call": "git bugreport [(-o | --output-directory) <path>] [(-s | --suffix) <format>] [--diagnose[=<mode>]]",
            "api_arguments": [
                {
                    "name": "_o_|_output_directory_path"
                },
                {
                    "name": "_s_|_suffix_format"
                },
                {
                    "name": "diagnose["
                }
            ],
            "python_environment_requirements": "git",
            "example_code": [],
            "description": "This API collects information about the user\u2019s machine, Git client, and repository state, as well as a form requesting information about the behavior the user observed, into a single text file which the user can then share, for example to the Git mailing list, in order to report an observed bug.",
            "api_name_original": "git-bugreport",
            "api_arguments_original": [
                "-o | --output-directory <path>",
                "-s | --suffix <format>",
                "--diagnose[=<mode>]"
            ]
        }
    },
    {
        "query": "Can you please check if the file named \"example.txt\" is ignored by .gitignore?",
        "model_answer": "git.check_ignore('example.txt')",
        "original": {
            "domain": "github",
            "framework": "git",
            "functionality": "Check if files are ignored by gitignore",
            "api_name": "git.check_ignore('example.txt'",
            "api_call": "git check-ignore [<options>] <pathname>",
            "api_arguments": [
                {
                    "name": "_q,_quiet"
                },
                {
                    "name": "_v,_verbose"
                },
                {
                    "name": "stdin"
                },
                {
                    "name": "_z"
                },
                {
                    "name": "_n,_non_matching"
                },
                {
                    "name": "no_index"
                }
            ],
            "python_environment_requirements": [
                "git"
            ],
            "example_code": [],
            "description": "The git-check-ignore command is used to check if specific files are ignored by .gitignore or other input files to the exclude mechanism. It can be useful for debugging why a path became tracked by git add and was not ignored by the rules as expected by the user. The command outputs the paths that are excluded, and with the verbose option, it prints the exclude pattern along with the path.",
            "api_name_original": "git-check-ignore",
            "api_arguments_original": [
                "-q, --quiet",
                "-v, --verbose",
                "--stdin",
                "-z",
                "-n, --non-matching",
                "--no-index"
            ]
        }
    },
    {
        "query": "What is the command to find the commits that are yet to be applied to the original repository?",
        "model_answer": "git.cherry()",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Find commits yet to be applied to upstream",
            "api_name": "git.cherry",
            "api_call": "git cherry [-v] [<upstream> [<head> [<limit>]]]",
            "api_arguments": [
                {
                    "name": "_v"
                },
                {
                    "name": "upstream"
                },
                {
                    "name": "head"
                },
                {
                    "name": "limit"
                }
            ],
            "python_environment_requirements": [],
            "example_code": [
                {
                    "description": "Patch workflows",
                    "code": "$ git checkout -b topic origin/master\n# work and create some commits\n$ git format-patch origin/master\n$ git send-email ... 00*\n$ git fetch # update your notion of origin/master\n$ git cherry -v"
                },
                {
                    "description": "Concrete example",
                    "code": "$ git log --graph --oneline --decorate --boundary origin/master...topic\n$ git cherry origin/master topic\n- cccc000... commit C\n+ bbbb000... commit B\n- aaaa000... commit A"
                },
                {
                    "description": "Using a limit",
                    "code": "$ git log --graph --oneline --decorate --boundary origin/master...topic\n$ git cherry origin/master topic base\n- cccc000... commit C\n+ bbbb000... commit B\n- aaaa000... commit A"
                }
            ],
            "description": "The git-cherry command is used to find commits that are yet to be applied to the upstream. It determines whether there are commits in <head>..<upstream> that are equivalent to those in the range <limit>..<head>. The equivalence test is based on the diff, after removing whitespace and line numbers. git-cherry detects when commits have been 'copied' by means of git-cherry-pick, git-am, or git-rebase. It outputs the SHA1 of every commit in <limit>..<head>, prefixed with - for commits that have an equivalent in <upstream>, and + for commits that do not.",
            "api_name_original": "git-cherry",
            "api_arguments_original": [
                "-v",
                "<upstream>",
                "<head>",
                "<limit>"
            ]
        }
    },
    {
        "query": "I want to clone a Perforce repository located at \"//depot/path/project\" into a new Git repository.",
        "model_answer": "git.p4.clone(\"//depot/path/project\")",
        "original": {
            "domain": "git",
            "framework": "git-p4",
            "functionality": "Interact with p4 repositories using Git",
            "api_name": "git.p4.clone",
            "api_call": "git p4 <command> [<options>] [<arguments>]",
            "api_arguments": [
                {
                    "name": "clone"
                },
                {
                    "name": "sync"
                },
                {
                    "name": "rebase"
                },
                {
                    "name": "submit"
                },
                {
                    "name": "unshelve"
                },
                {
                    "name": "git_dir"
                },
                {
                    "name": "verbose"
                },
                {
                    "name": "branch"
                },
                {
                    "name": "detect_branches"
                },
                {
                    "name": "changesfile"
                },
                {
                    "name": "silent"
                },
                {
                    "name": "detect_labels"
                },
                {
                    "name": "import_labels"
                },
                {
                    "name": "import_local"
                },
                {
                    "name": "max_changes"
                },
                {
                    "name": "changes_block_size"
                },
                {
                    "name": "keep_path"
                },
                {
                    "name": "use_client_spec"
                },
                {
                    "name": "destination"
                },
                {
                    "name": "bare"
                },
                {
                    "name": "origin"
                },
                {
                    "name": "preserve_user"
                },
                {
                    "name": "export_labels"
                },
                {
                    "name": "dry_run"
                },
                {
                    "name": "prepare_p4_only"
                },
                {
                    "name": "shelve"
                },
                {
                    "name": "update_shelve"
                },
                {
                    "name": "conflict"
                },
                {
                    "name": "commit"
                },
                {
                    "name": "disable_rebase"
                },
                {
                    "name": "disable_p4sync"
                }
            ],
            "python_environment_requirements": [
                "git"
            ],
            "example_code": [
                {
                    "description": "Clone a repository",
                    "code": "git p4 clone //depot/path/project"
                },
                {
                    "description": "Update the Git repository with recent changes from p4",
                    "code": "git p4 rebase"
                },
                {
                    "description": "Submit your commits back to p4",
                    "code": "git p4 submit"
                }
            ],
            "description": "The git-p4 is a tool that allows git to interact with Perforce repositories. It provides various functionalities such as cloning an existing p4 repository into a new git repository, syncing new commits from p4 changes, rebasing the current branch onto the updated p4 remote branch and submitting git changes back to p4. It also supports unshelving a shelved P4 changelist and producing the equivalent git commit.",
            "api_name_original": "git-p4",
            "api_arguments_original": [
                "clone",
                "sync",
                "rebase",
                "submit",
                "unshelve",
                "--git-dir",
                "--verbose",
                "--branch",
                "--detect-branches",
                "--changesfile",
                "--silent",
                "--detect-labels",
                "--import-labels",
                "--import-local",
                "--max-changes",
                "--changes-block-size",
                "--keep-path",
                "--use-client-spec",
                "--destination",
                "--bare",
                "--origin",
                "--preserve-user",
                "--export-labels",
                "--dry-run",
                "--prepare-p4-only",
                "--shelve",
                "--update-shelve",
                "--conflict",
                "--commit",
                "--disable-rebase",
                "--disable-p4sync"
            ]
        }
    },
    {
        "query": "I want to move the file \"example.txt\" to a different location \"folder/new_example.txt\".",
        "model_answer": "git.mv(\"example.txt\", \"folder/new_example.txt\")",
        "original": {
            "domain": "github",
            "framework": "git",
            "functionality": "Move or rename a file, directory or symlink",
            "api_name": "git.mv(\"example.txt\", \"folder/new_example.txt\"",
            "api_call": "git mv [<options>] <source>\u2026\u200b <destination>",
            "api_arguments": [
                {
                    "name": "source",
                    "description": "The file, directory or symlink to be moved or renamed"
                },
                {
                    "name": "destination",
                    "description": "The new location or name for the file, directory or symlink"
                },
                {
                    "name": "options",
                    "description": "Optional arguments that modify the behavior of the command"
                }
            ],
            "python_environment_requirements": [],
            "example_code": [],
            "description": "The 'git-mv' API is used to move or rename a file, directory or symlink in a git repository. It updates the index after successful completion, but the change must still be committed. The API accepts optional arguments that modify its behavior, such as '-f' to force the operation even if the destination exists, '-n' to do a dry run, and '-v' to report the names of files as they are moved.",
            "api_name_original": "git-mv",
            "api_arguments_original": [
                {
                    "name": "<source>",
                    "description": "The file, directory or symlink to be moved or renamed"
                },
                {
                    "name": "<destination>",
                    "description": "The new location or name for the file, directory or symlink"
                },
                {
                    "name": "<options>",
                    "description": "Optional arguments that modify the behavior of the command"
                }
            ]
        }
    },
    {
        "query": "I want to track changes in a specific section of a file using git-blame.",
        "model_answer": "git.blame(\"-L 10,20\", \"<file>\")",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Track changes in a file",
            "api_name": "git.blame",
            "api_call": "git blame <file>",
            "api_arguments": [
                {
                    "name": "_l_start,end"
                },
                {
                    "name": "_s_revs_file"
                },
                {
                    "name": "reverse_rev..rev"
                },
                {
                    "name": "first_parent"
                },
                {
                    "name": "_p"
                },
                {
                    "name": "porcelain"
                },
                {
                    "name": "line_porcelain"
                },
                {
                    "name": "incremental"
                },
                {
                    "name": "encoding"
                },
                {
                    "name": "contents_file"
                },
                {
                    "name": "date_format"
                },
                {
                    "name": "[no_]progress"
                },
                {
                    "name": "_m[num]"
                },
                {
                    "name": "_c[num]"
                },
                {
                    "name": "ignore_rev_rev"
                },
                {
                    "name": "ignore_revs_file_file"
                },
                {
                    "name": "color_lines"
                },
                {
                    "name": "color_by_age"
                },
                {
                    "name": "_h"
                },
                {
                    "name": "_c"
                },
                {
                    "name": "score_debug"
                },
                {
                    "name": "_f"
                },
                {
                    "name": "show_name"
                },
                {
                    "name": "_n"
                },
                {
                    "name": "show_number"
                },
                {
                    "name": "_s"
                },
                {
                    "name": "_e"
                },
                {
                    "name": "show_email"
                },
                {
                    "name": "_w"
                },
                {
                    "name": "abbrev"
                }
            ],
            "python_environment_requirements": [
                "gitpython"
            ],
            "example_code": [
                {
                    "description": "Annotate a file",
                    "code": "git blame <file>"
                },
                {
                    "description": "Annotate a specific line range in a file",
                    "code": "git blame -L <start>,<end> <file>"
                },
                {
                    "description": "Annotate a file with specific revisions",
                    "code": "git blame -S <revs-file> <file>"
                }
            ],
            "description": "The git-blame API is used to track the changes in a file. It annotates each line in the given file with information from the revision which last modified the line. This can be used to track when a code snippet was added to a file, moved or copied between files, and eventually deleted or replaced. It has several options to customize the output and the range of lines and revisions to consider. It can be called from Python using the gitpython library.",
            "api_name_original": "git-blame",
            "api_arguments_original": [
                "-L <start>,<end>",
                "-S <revs-file>",
                "--reverse <rev>..<rev>",
                "--first-parent",
                "-p",
                "--porcelain",
                "--line-porcelain",
                "--incremental",
                "--encoding=<encoding>",
                "--contents <file>",
                "--date <format>",
                "--[no-]progress",
                "-M[<num>]",
                "-C[<num>]",
                "--ignore-rev <rev>",
                "--ignore-revs-file <file>",
                "--color-lines",
                "--color-by-age",
                "-h",
                "-c",
                "--score-debug",
                "-f",
                "--show-name",
                "-n",
                "--show-number",
                "-s",
                "-e",
                "--show-email",
                "-w",
                "--abbrev=<n>"
            ]
        }
    },
    {
        "query": "How can I view the example of a post-merge hook in Git?",
        "model_answer": "githooks()",
        "original": {
            "domain": "github",
            "framework": "git",
            "functionality": "Hooks used by Git",
            "api_name": "githooks(",
            "api_call": "$GIT_DIR/hooks/* (or `git config core.hooksPath`/*)",
            "api_arguments": [
                {
                    "name": "core.hookspath"
                }
            ],
            "python_environment_requirements": [
                "Python",
                "Git"
            ],
            "example_code": [
                {
                    "description": "Example of a pre-commit hook",
                    "code": "pre-commit\nThis hook is invoked by git-commit[1], and can be bypassed\nwith the --no-verify option. It takes no parameters, and is\ninvoked before obtaining the proposed commit log message and\nmaking a commit. Exiting with a non-zero status from this script\ncauses the git commit command to abort before creating a commit."
                }
            ],
            "description": "Hooks are programs you can place in a hooks directory to trigger actions at certain points in git\u2019s execution. Hooks that don\u2019t have the executable bit set are ignored. By default the hooks directory is $GIT_DIR/hooks, but that can be changed via the core.hooksPath configuration variable. Hooks can get their arguments via the environment, command-line arguments, and stdin.",
            "api_name_original": "githooks",
            "api_arguments_original": [
                "core.hooksPath"
            ]
        }
    },
    {
        "query": "I want to check if the branch name \"feature/1234-new-feature\" is acceptable according to Git's naming rules.",
        "model_answer": "git.check_ref_format(\"--normalize\", \"--allow-onelevel\", \"--refspec-pattern\", \"feature/1234-new-feature\")",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Check the format of branch and tag names",
            "api_name": "git.check_ref_format",
            "api_call": "git check-ref-format [--normalize] [--[no-]allow-onelevel] [--refspec-pattern] <refname>",
            "api_arguments": [
                {
                    "name": "normalize"
                },
                {
                    "name": "[no_]allow_onelevel"
                },
                {
                    "name": "refspec_pattern"
                },
                {
                    "name": "refname"
                }
            ],
            "python_environment_requirements": [
                "git"
            ],
            "example_code": [
                {
                    "description": "Print the name of the previous thing checked out",
                    "code": "git check-ref-format --branch @{-1}"
                },
                {
                    "description": "Determine the reference name to use for a new branch",
                    "code": "$ ref=$(git check-ref-format --normalize \"refs/heads/$newbranch\")|| { echo \"we do not like '$newbranch' as a branch name.\" >&2 ; exit 1 ; }"
                }
            ],
            "description": "The git-check-ref-format API is used to check if a given reference name (branch or tag name) is acceptable according to Git's naming rules. If the name is not acceptable, the command will exit with a non-zero status. The API enforces several rules for naming, including the requirement for at least one '/', the prohibition of two consecutive dots, ASCII control characters, certain special characters, and certain sequences of characters. The API also provides options to control whether one-level refnames are accepted, to interpret the refname as a reference name pattern for a refspec, and to normalize the refname by removing any leading slash characters and collapsing runs of adjacent slashes between name components into a single slash.",
            "api_name_original": "git-check-ref-format",
            "api_arguments_original": [
                "--normalize",
                "--[no-]allow-onelevel",
                "--refspec-pattern",
                "<refname>"
            ]
        }
    },
    {
        "query": "I want to reset the current HEAD in Git to the previous commit state.",
        "model_answer": "git.reset('--soft', 'HEAD^')",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "resetting the current HEAD to a specified state",
            "api_name": "git.reset",
            "api_call": "git reset [--soft | --mixed [-N] | --hard | --merge | --keep] [-q] [<commit>]",
            "api_arguments": [
                {
                    "name": "soft"
                },
                {
                    "name": "mixed"
                },
                {
                    "name": "_n"
                },
                {
                    "name": "hard"
                },
                {
                    "name": "merge"
                },
                {
                    "name": "keep"
                },
                {
                    "name": "_q"
                },
                {
                    "name": "commit"
                }
            ],
            "python_environment_requirements": "gitpython",
            "example_code": [
                {
                    "description": "Undo add",
                    "code": "$ git add frotz.c filfre.c\n$ git reset"
                },
                {
                    "description": "Undo a commit and redo",
                    "code": "$ git commit ...\n$ git reset --soft HEAD^"
                },
                {
                    "description": "Undo a commit, making it a topic branch",
                    "code": "$ git branch topic/wip\n$ git reset --hard HEAD~3"
                },
                {
                    "description": "Undo commits permanently",
                    "code": "$ git commit ...\n$ git reset --hard HEAD~3"
                },
                {
                    "description": "Undo a merge or pull",
                    "code": "$ git pull\n$ git reset --hard"
                }
            ],
            "description": "The git-reset command allows you to reset your current HEAD to a specified state. You can do this in several ways depending on the options you choose. For example, the --soft option does not touch the index file or the working tree at all but resets the head to <commit>. The --mixed option resets the index but not the working tree. The --hard option resets the index and working tree. Any changes to tracked files in the working tree since <commit> are discarded. The --merge and --keep options have their own behaviors as well. This API is part of the Git suite and can be used for a variety of tasks such as undoing adds, commits, merges, and pulls.",
            "api_name_original": "git-reset",
            "api_arguments_original": [
                "--soft",
                "--mixed",
                "-N",
                "--hard",
                "--merge",
                "--keep",
                "-q",
                "<commit>"
            ]
        }
    },
    {
        "query": "I want to create a signed tag in Git with the tag name \"v2.0\" and the message \"Release version 2.0\".",
        "model_answer": "git.tag('-s', 'v2.0', '-m', 'Release version 2.0')",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Cryptographic Signatures",
            "api_name": "git.tag('_s', 'v1.0', '_m', 'Release version 1.0'",
            "api_call": "git tag -s [tagname] -m [message]",
            "api_arguments": [
                {
                    "name": "tagname"
                },
                {
                    "name": "message"
                }
            ],
            "python_environment_requirements": [
                "gitpython"
            ],
            "example_code": [
                {
                    "description": "Create a signed tag",
                    "code": "from git import Repo\n\nrepo = Repo('/path/to/repo')\nrepo.git.tag('-s', 'tagname', '-m', 'message')"
                }
            ],
            "description": "The gitformat-signature API is used to create cryptographic signatures for Git objects (tags, commits, mergetags) and transactions (pushes). The command which is about to create an object or transaction determines a payload from that, calls an external program to obtain a detached signature for the payload (gpg -bsa in the case of PGP signatures), and embeds the signature into the object or transaction. This API is useful for ensuring the integrity and authenticity of Git objects and transactions.",
            "api_name_original": "gitformat-signature",
            "api_arguments_original": [
                "tagname",
                "message"
            ]
        }
    },
    {
        "query": "I want to add a note to a commit in a git repository with the message \"Reviewed-by: Jane Smith <jane@example.com>\".",
        "model_answer": "git.notes.add('-m', 'Reviewed-by: Jane Smith <jane@example.com>', '72a144e2')",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Add or inspect object notes",
            "api_name": "git.notes.add('_m', 'Tested_by: Johannes Sixt <j6t@kdbg.org>', '72a144e2'",
            "api_call": "git notes [subcommand] [options] [<object>]",
            "api_arguments": [
                {
                    "name": "subcommand"
                },
                {
                    "name": "options"
                },
                {
                    "name": "object"
                }
            ],
            "python_environment_requirements": "N/A",
            "example_code": [
                {
                    "description": "Add a note to a commit",
                    "code": "$ git notes add -m 'Tested-by: Johannes Sixt <j6t@kdbg.org>' 72a144e2"
                }
            ],
            "description": "The git-notes API allows you to add, inspect, edit, or remove notes attached to objects in a git repository. These notes are stored in a separate ref, and do not modify the objects themselves. This is useful for adding supplementary information to a commit, such as additional commentary or metadata. The notes can be displayed alongside the original commit message with the git log command. The API also includes functionality to merge note refs and to copy or append to existing notes.",
            "api_name_original": "git-notes",
            "api_arguments_original": [
                "subcommand",
                "options",
                "object"
            ]
        }
    },
    {
        "query": "I want to clean the working tree by removing all untracked files and directories.",
        "model_answer": "git.clean(\"-f\", \"-d\")",
        "original": {
            "domain": "github",
            "framework": "git",
            "functionality": "Remove untracked files from the working tree",
            "api_name": "git.clean",
            "api_call": "git clean [-d] [-f] [-i] [-n] [-q] [-e <pattern>] [-x | -X] [--] [<pathspec>\u2026\u200b]",
            "api_arguments": [
                {
                    "name": "_d"
                },
                {
                    "name": "_f"
                },
                {
                    "name": "_i"
                },
                {
                    "name": "_n"
                },
                {
                    "name": "_q"
                },
                {
                    "name": "_e_pattern"
                },
                {
                    "name": "_x_|__x"
                },
                {
                    "name": ""
                },
                {
                    "name": "pathspec\u2026\u200b"
                }
            ],
            "python_environment_requirements": "git",
            "example_code": [],
            "description": "The git-clean API is used to clean the working tree by recursively removing files that are not under version control, starting from the current directory. Normally, only files unknown to Git are removed, but if the -x option is specified, ignored files are also removed. This can, for example, be useful to remove all build products. If any optional <pathspec>... arguments are given, only those paths that match the pathspec are affected.",
            "api_name_original": "git-clean",
            "api_arguments_original": [
                "-d",
                "-f",
                "-i",
                "-n",
                "-q",
                "-e <pattern>",
                "-x | -X",
                "--",
                "<pathspec>\u2026\u200b"
            ]
        }
    },
    {
        "query": "I want to bisect a broken build between v1.3 and HEAD in my git repository.",
        "model_answer": "git.bisect(subcommand=\"start\", options=\"HEAD v1.3 --\")",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Find the commit that introduced a bug",
            "api_name": "git.bisect(subcommand=\"start\", options=\"HEAD v1.2 __\"",
            "api_call": "git bisect <subcommand> <options>",
            "api_arguments": [
                {
                    "name": "subcommand"
                },
                {
                    "name": "options"
                }
            ],
            "python_environment_requirements": "Python not required",
            "example_code": [
                {
                    "description": "Automatically bisect a broken build between v1.2 and HEAD:",
                    "code": "$ git bisect start HEAD v1.2 -- # HEAD is bad, v1.2 is good\n$ git bisect run make # 'make' builds the app\n$ git bisect reset # quit the bisect session"
                },
                {
                    "description": "Automatically bisect a test failure between origin and HEAD:",
                    "code": "$ git bisect start HEAD origin -- # HEAD is bad, origin is good\n$ git bisect run make test # 'make test' builds and tests\n$ git bisect reset # quit the bisect session"
                }
            ],
            "description": "The 'git-bisect' API uses a binary search algorithm to find which commit in your project\u2019s history introduced a bug. You use it by first telling it a 'bad' commit that is known to contain the bug, and a 'good' commit that is known to be before the bug was introduced. Then 'git bisect' picks a commit between those two endpoints and asks you whether the selected commit is 'good' or 'bad'. It continues narrowing down the range until it finds the exact commit that introduced the change.",
            "api_name_original": "git-bisect",
            "api_arguments_original": [
                "subcommand",
                "options"
            ]
        }
    },
    {
        "query": "I want to verify the GPG signature of the tag \"v1.0\" in my git repository.",
        "model_answer": "git.verify_tag(\"v1.0\")",
        "original": {
            "domain": "github",
            "framework": "git",
            "functionality": "Verify the GPG signature of tags",
            "api_name": "git.verify_tag",
            "api_call": "git verify-tag [-v | --verbose] [--format=<format>] [--raw] <tag>",
            "api_arguments": [
                {
                    "name": "_v"
                },
                {
                    "name": "verbose"
                },
                {
                    "name": "format"
                },
                {
                    "name": "raw"
                },
                {
                    "name": "tag"
                }
            ],
            "python_environment_requirements": "git installed",
            "example_code": [],
            "description": "The git-verify-tag API is used to validate the gpg signature created by git tag. It provides options to print the raw gpg status output to standard error instead of the normal human-readable output, and to print the contents of the tag object before validating it. The tag argument is the SHA-1 identifiers of Git tag objects.",
            "api_name_original": "git-verify-tag",
            "api_arguments_original": [
                "-v",
                "--verbose",
                "--format",
                "--raw",
                "<tag>"
            ]
        }
    },
    {
        "query": "I want to pack the heads and tags for efficient repository access in my Git repository.",
        "model_answer": "git.pack_refs()",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Pack heads and tags for efficient repository access",
            "api_name": "git.pack_refs",
            "api_call": "git pack-refs [--all] [--no-prune]",
            "api_arguments": [
                {
                    "name": "all"
                },
                {
                    "name": "no_prune"
                }
            ],
            "python_environment_requirements": "git",
            "example_code": [],
            "description": "This command is used to solve the storage and performance problem by storing the refs in a single file, $GIT_DIR/packed-refs. When a ref is missing from the traditional $GIT_DIR/refs directory hierarchy, it is looked up in this file and used if found. Subsequent updates to branches always create new files under $GIT_DIR/refs directory hierarchy. A recommended practice to deal with a repository with too many refs is to pack its refs with --all once, and occasionally run git pack-refs. Tags are by definition stationary and are not expected to change. Branch heads will be packed with the initial pack-refs --all, but only the currently active branch heads will become unpacked, and the next pack-refs (without --all) will leave them unpacked.",
            "api_name_original": "git-pack-refs",
            "api_arguments_original": [
                "--all",
                "--no-prune"
            ]
        }
    },
    {
        "query": "I want to create a tag object with extra validation in git and tag it as 'v1.0'.",
        "model_answer": "git.mktag(\"--strict\", \"v1.0\")",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Create a tag object with extra validation",
            "api_name": "git.mktag",
            "api_call": "git mktag <my-tag",
            "api_arguments": [
                {
                    "name": "strict"
                },
                {
                    "name": "my_tag"
                }
            ],
            "python_environment_requirements": [
                "git"
            ],
            "example_code": [
                {
                    "description": "Create a tag object",
                    "code": "git mktag <my-tag"
                }
            ],
            "description": "The git-mktag API reads a tag contents on standard input and creates a tag object. The output is the new tag\u2019s object identifier. It is mostly equivalent to git-hash-object invoked with -t tag -w --stdin. The difference is that mktag will die before writing the tag if the tag doesn\u2019t pass a git-fsck check. All fsck.<msg-id> messages are promoted from warnings to errors. Extra headers in the object are also an error under mktag, but ignored by git-fsck. This extra check can be turned off by setting the appropriate fsck.<msg-id> variable.",
            "api_name_original": "git-mktag",
            "api_arguments_original": [
                "--strict",
                "<my-tag>"
            ]
        }
    },
    {
        "query": "How can I unpack objects from a packed archive in git using the git-unpack-objects API?",
        "model_answer": "git.unpack_objects()",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Unpack objects from a packed archive",
            "api_name": "git.unpack_objects",
            "api_call": "git unpack-objects [-n] [-q] [-r] [--strict]",
            "api_arguments": [
                {
                    "name": "_n"
                },
                {
                    "name": "_q"
                },
                {
                    "name": "_r"
                },
                {
                    "name": "strict"
                }
            ],
            "python_environment_requirements": [],
            "example_code": [],
            "description": "The git-unpack-objects API is used to unpack objects from a packed archive (.pack) read from the standard input. It expands the objects contained within and writes them into the repository in a 'loose' format (one object per file). Objects that already exist in the repository will not be unpacked from the packfile. Therefore, nothing will be unpacked if you use this command on a packfile that exists within the target repository.",
            "api_name_original": "git-unpack-objects",
            "api_arguments_original": [
                "-n",
                "-q",
                "-r",
                "--strict"
            ]
        }
    },
    {
        "query": "I want to store my Git credentials on disk for future use.",
        "model_answer": "git.config.credential_helper(store)",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Store credentials on disk",
            "api_name": "git.config.credential_helper",
            "api_call": "git config credential.helper 'store [<options>]'",
            "api_arguments": [
                {
                    "name": "file"
                }
            ],
            "python_environment_requirements": [],
            "example_code": [
                {
                    "description": "The point of this helper is to reduce the number of times you must type your username or password. For example:",
                    "code": "$ git config credential.helper store\n$ git push http://example.com/repo.git\nUsername: <type your username>\nPassword: <type your password>\n[several days later]\n$ git push http://example.com/repo.git\n[your credentials are used automatically]"
                }
            ],
            "description": "The git-credential-store is a helper program that stores credentials indefinitely on disk for use by future Git programs. It is not meant to be invoked directly; it is meant to be used as a credential helper by other parts of git. The credentials are stored unencrypted on disk, protected only by filesystem permissions. If this is not an acceptable security tradeoff, other helpers that integrate with secure storage provided by the operating system should be used.",
            "api_name_original": "git-credential-store",
            "api_arguments_original": [
                "--file=<path>"
            ]
        }
    },
    {
        "query": "I want to push a branch named \"bug-fix\" to a remote repository named \"upstream\" in Git.",
        "model_answer": "git.push('upstream', 'bug-fix')",
        "original": {
            "domain": "git-scm.com",
            "framework": "Git",
            "functionality": "Branching and Merging",
            "api_name": "git.push",
            "api_call": "git <command> <arguments>",
            "api_arguments": [
                {
                    "name": "command"
                },
                {
                    "name": "arguments"
                }
            ],
            "python_environment_requirements": "GitPython library",
            "example_code": [
                {
                    "description": "Pushing a branch to a remote repository",
                    "code": "git push <remote> <branch>"
                },
                {
                    "description": "Fetching remote branches to your repository",
                    "code": "git fetch <remote>"
                },
                {
                    "description": "Merging remote topics",
                    "code": "git pull <URL> <branch>"
                },
                {
                    "description": "Formatting patches",
                    "code": "git format-patch -M upstream..topic"
                },
                {
                    "description": "Sending patches via email",
                    "code": "git send-email --to=<recipient> <patches>"
                },
                {
                    "description": "Keeping topics up to date",
                    "code": "git pull --rebase <URL> <branch>"
                },
                {
                    "description": "Importing patches",
                    "code": "git am < patch"
                }
            ],
            "description": "The gitworkflows API provides a set of workflows for Git, including branching and merging, managing branches, and distributed workflows. It allows users to create branches, merge changes from one branch to another, push branches to remote repositories, fetch remote branches, format patches, and send patches via email. It also provides workflows for keeping topics up to date and importing patches.",
            "api_name_original": "gitworkflows",
            "api_arguments_original": [
                "command",
                "arguments"
            ]
        }
    },
    {
        "query": "I want to replace commit 'old' with commit 'new' in a git repository.",
        "model_answer": "git.replace('-f', 'old', 'new')",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Create, list, delete refs to replace objects",
            "api_name": "git.replace",
            "api_call": "git replace [-f] <object> <replacement>",
            "api_arguments": [
                {
                    "name": "_f"
                },
                {
                    "name": "object"
                },
                {
                    "name": "replacement"
                }
            ],
            "python_environment_requirements": [],
            "example_code": [
                {
                    "description": "Replace commit foo with commit bar",
                    "code": "git replace -f foo bar"
                },
                {
                    "description": "Delete existing replace refs for the given objects",
                    "code": "git replace -d <object>"
                },
                {
                    "description": "Edit an object\u2019s content interactively",
                    "code": "git replace --edit <object>"
                },
                {
                    "description": "Create a graft commit",
                    "code": "git replace --graft <commit> [<parent>]"
                },
                {
                    "description": "List replace refs for objects that match the given pattern",
                    "code": "git replace -l <pattern>"
                }
            ],
            "description": "The git-replace command allows you to create, list, or delete refs to replace objects. It adds a replace reference in the refs/replace/ namespace. The name of the replace reference is the SHA-1 of the object that is replaced, and the content of the replace reference is the SHA-1 of the replacement object. The replaced object and the replacement object must be of the same type. This command is useful for manipulating the git history and objects.",
            "api_name_original": "git-replace",
            "api_arguments_original": [
                "-f",
                "<object>",
                "<replacement>"
            ]
        }
    },
    {
        "query": "I want to create a Git bundle file with the given ref and Git objects.",
        "model_answer": "git.bundler()",
        "original": {
            "domain": "git",
            "framework": "Git",
            "functionality": "Create and read Git Bundle",
            "api_name": "git.bundler",
            "api_call": "git bundle <command> [<args>]",
            "api_arguments": [
                {
                    "name": "command"
                },
                {
                    "name": "args"
                }
            ],
            "python_environment_requirements": [
                "gitpython"
            ],
            "example_code": [],
            "description": "The Git bundle format is a format that represents both refs and Git objects. A bundle is a header in a format similar to git-show-ref[1] followed by a pack in *.pack format. The format is created and read by the git-bundle[1] command, and supported by e.g. git-fetch[1] and git-clone[1].",
            "api_name_original": "gitformat-bundle",
            "api_arguments_original": [
                "command",
                "args"
            ]
        }
    },
    {
        "query": "I want to update the object name stored in the ref \"develop\" with the new value \"xyz789\" on Git.",
        "model_answer": "git.update_ref(\"--create-reflog\", \"refs/heads/develop\", \"xyz789\")",
        "original": {
            "domain": "github",
            "framework": "git",
            "functionality": "Update the object name stored in a ref safely",
            "api_name": "git.update_ref",
            "api_call": "git update-ref [-m <reason>] [--no-deref] (-d <ref> [<oldvalue>] | [--create-reflog] <ref> <newvalue> [<oldvalue>] | --stdin [-z])",
            "api_arguments": [
                {
                    "name": "_m_reason"
                },
                {
                    "name": "no_deref"
                },
                {
                    "name": "_d_ref_[oldvalue]"
                },
                {
                    "name": "create_reflog_ref_newvalue_[oldvalue]"
                },
                {
                    "name": "stdin_[_z]"
                }
            ],
            "python_environment_requirements": [
                "git"
            ],
            "example_code": [],
            "description": "The git-update-ref command updates the object name stored in a ref safely. It can update the current branch head to a new object, update the master branch head to a new value only if its current value is a certain old value, or overwrite a ref itself rather than the result of following symbolic pointers. It can also delete a named ref after verifying it still contains a certain old value, or read instructions from standard input and perform all modifications together. If all refs can be locked with matching old values simultaneously, all modifications are performed. Otherwise, no modifications are performed.",
            "api_name_original": "git-update-ref",
            "api_arguments_original": [
                "-m <reason>",
                "--no-deref",
                "-d <ref> [<oldvalue>]",
                "--create-reflog <ref> <newvalue> [<oldvalue>]",
                "--stdin [-z]"
            ]
        }
    },
    {
        "query": "I want to cherry-pick a specific commit with the hash \"abc123\" in my Git repository.",
        "model_answer": "git.cherry_pick(commit=\"abc123\")",
        "original": {
            "domain": "git",
            "framework": "Git",
            "functionality": "Apply changes from existing commits",
            "api_name": "git.cherry_pick",
            "api_call": "git cherry-pick <commit>\u2026\u200b",
            "api_arguments": [
                {
                    "name": "commit"
                },
                {
                    "name": "edit"
                },
                {
                    "name": "cleanup"
                },
                {
                    "name": "x"
                },
                {
                    "name": "r"
                },
                {
                    "name": "mainline"
                },
                {
                    "name": "no_commit"
                },
                {
                    "name": "signoff"
                },
                {
                    "name": "gpg_sign"
                },
                {
                    "name": "ff"
                },
                {
                    "name": "allow_empty"
                },
                {
                    "name": "allow_empty_message"
                },
                {
                    "name": "keep_redundant_commits"
                },
                {
                    "name": "strategy"
                },
                {
                    "name": "strategy_option"
                },
                {
                    "name": "rerere_autoupdate"
                },
                {
                    "name": "continue"
                },
                {
                    "name": "skip"
                },
                {
                    "name": "quit"
                },
                {
                    "name": "abort"
                }
            ],
            "python_environment_requirements": [],
            "example_code": [
                {
                    "description": "Apply the change introduced by the commit at the tip of the master branch and create a new commit with this change.",
                    "code": "git cherry-pick master"
                },
                {
                    "description": "Apply the changes introduced by all commits that are ancestors of master but not of HEAD to produce new commits.",
                    "code": "git cherry-pick ..master"
                }
            ],
            "description": "The git-cherry-pick command applies changes from existing commits and records a new commit for each. It requires your working tree to be clean with no modifications from the HEAD commit. The command is useful for applying changes from one branch to another without merging the entire branches.",
            "api_name_original": "git-cherry-pick",
            "api_arguments_original": [
                "commit",
                "edit",
                "cleanup",
                "x",
                "r",
                "mainline",
                "no-commit",
                "signoff",
                "gpg-sign",
                "ff",
                "allow-empty",
                "allow-empty-message",
                "keep-redundant-commits",
                "strategy",
                "strategy-option",
                "rerere-autoupdate",
                "continue",
                "skip",
                "quit",
                "abort"
            ]
        }
    },
    {
        "query": "I want to view the changes made to the file 'main.py' in all branches using gitk.",
        "model_answer": "gitk(max_count=100, all=True, path='main.py')",
        "original": {
            "domain": "git",
            "framework": "gitk",
            "functionality": "Repository Browser",
            "api_name": "gitk(max_count=100, all=True, path='Makefile'",
            "api_call": "gitk [<options>] [<revision range>] [--] [<path>\u2026\u200b]",
            "api_arguments": [
                {
                    "name": "options"
                },
                {
                    "name": "revision_range"
                },
                {
                    "name": "path"
                }
            ],
            "python_environment_requirements": [
                "Python 2.7 or 3.5+",
                "GitPython 2.1.8+",
                "PyGithub 1.43.3+"
            ],
            "example_code": [
                {
                    "description": "Show the changes since version v2.6.12 that changed any file in the include/scsi or drivers/scsi subdirectories",
                    "code": "gitk v2.6.12.. include/scsi drivers/scsi"
                },
                {
                    "description": "Show the changes during the last two weeks to the file gitk.",
                    "code": "gitk --since=\"2 weeks ago\" -- gitk"
                },
                {
                    "description": "Show at most 100 changes made to the file Makefile. Instead of only looking for changes in the current branch look in all branches.",
                    "code": "gitk --max-count=100 --all -- Makefile"
                }
            ],
            "description": "Gitk is a repository browser that displays changes in a repository or a selected set of commits. This includes visualizing the commit graph, showing information related to each commit, and the files in the trees of each revision. Gitk supports most options applicable to the git rev-list command and a few options applicable to the git diff-* commands to control how the changes each commit introduces are shown.",
            "api_name_original": "gitk",
            "api_arguments_original": [
                "<options>",
                "<revision range>",
                "<path>"
            ]
        }
    },
    {
        "query": "I want to manipulate the differences in unconventional ways using the git diff command.",
        "model_answer": "git.diff(\"*\")",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Manipulate differences in unconventional ways",
            "api_name": "git.diff",
            "api_call": "git diff *",
            "api_arguments": [
                {
                    "name": "*"
                }
            ],
            "python_environment_requirements": [],
            "example_code": [],
            "description": "The diff commands git diff-index, git diff-files, and git diff-tree can be told to manipulate differences they find in unconventional ways before showing diff output. The manipulation is collectively called 'diffcore transformation'. This short note describes what they are and how to use them to produce diff output that is easier to understand than the conventional kind.",
            "api_name_original": "gitdiffcore",
            "api_arguments_original": [
                "*"
            ]
        }
    },
    {
        "query": "I want to verify the connectivity and validity of objects in the git database.",
        "model_answer": "git.fsck()",
        "original": {
            "domain": "github",
            "framework": "git",
            "functionality": "Verify the connectivity and validity of objects in the database",
            "api_name": "git.fsck",
            "api_call": "git fsck",
            "api_arguments": [
                {
                    "name": "tags"
                },
                {
                    "name": "root"
                },
                {
                    "name": "unreachable"
                },
                {
                    "name": "cache"
                },
                {
                    "name": "no_reflogs"
                },
                {
                    "name": "[no_]full"
                },
                {
                    "name": "strict"
                },
                {
                    "name": "verbose"
                },
                {
                    "name": "lost_found"
                },
                {
                    "name": "[no_]dangling"
                },
                {
                    "name": "[no_]progress"
                },
                {
                    "name": "connectivity_only"
                },
                {
                    "name": "[no_]name_objects"
                },
                {
                    "name": "object"
                }
            ],
            "python_environment_requirements": [
                "gitpython"
            ],
            "example_code": [],
            "description": "The git-fsck command verifies the connectivity and validity of the objects in the database. It can be used to check for corruption, unreachable objects, dangling objects, and other potential issues. The command takes a number of optional arguments that can be used to customize its behavior.",
            "api_name_original": "git-fsck",
            "api_arguments_original": [
                "--tags",
                "--root",
                "--unreachable",
                "--cache",
                "--no-reflogs",
                "--[no-]full",
                "--strict",
                "--verbose",
                "--lost-found",
                "--[no-]dangling",
                "--[no-]progress",
                "--connectivity-only",
                "--[no-]name-objects",
                "<object>"
            ]
        }
    },
    {
        "query": "I want to annotate the lines of a Python script named \"script.py\" with commit information using git-annotate.",
        "model_answer": "git.annotate(file=\"script.py\")",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "annotate file lines with commit information",
            "api_name": "git.annotate",
            "api_call": "git annotate [<options>] [<rev-opts>] [<rev>] [--] <file>",
            "api_arguments": [
                {
                    "name": "options"
                },
                {
                    "name": "rev_opts"
                },
                {
                    "name": "rev"
                },
                {
                    "name": "file"
                }
            ],
            "python_environment_requirements": [
                "git"
            ],
            "example_code": [],
            "description": "The git-annotate API allows you to annotate each line in a given file with information from the commit that introduced the line. You can also annotate from a given revision. This command exists for backward compatibility to support existing scripts, and provide a more familiar command name for people coming from other SCM systems. It offers several options to customize the output format and the information displayed.",
            "api_name_original": "git-annotate",
            "api_arguments_original": [
                "options",
                "rev-opts",
                "rev",
                "file"
            ]
        }
    },
    {
        "query": "I want to fetch missing objects from a Git repository named \"my_repository\".",
        "model_answer": "git.fetch_pack(repository=\"my_repository\")",
        "original": {
            "domain": "git",
            "framework": "Git",
            "functionality": "Fetch missing objects from a repository",
            "api_name": "git.fetch_pack",
            "api_call": "git fetch-pack <repository> [<refs>\u2026\u200b]",
            "api_arguments": [
                {
                    "name": "all"
                },
                {
                    "name": "stdin"
                },
                {
                    "name": "_q"
                },
                {
                    "name": "quiet"
                },
                {
                    "name": "_k"
                },
                {
                    "name": "keep"
                },
                {
                    "name": "thin"
                },
                {
                    "name": "include_tag"
                },
                {
                    "name": "upload_pack"
                },
                {
                    "name": "depth"
                },
                {
                    "name": "shallow_since"
                },
                {
                    "name": "shallow_exclude"
                },
                {
                    "name": "deepen_relative"
                },
                {
                    "name": "refetch"
                },
                {
                    "name": "no_progress"
                },
                {
                    "name": "check_self_contained_and_connected"
                },
                {
                    "name": "_v"
                },
                {
                    "name": "repository"
                },
                {
                    "name": "refs"
                }
            ],
            "python_environment_requirements": [
                "Git"
            ],
            "example_code": [],
            "description": "The git-fetch-pack command is used to fetch objects from another repository that are missing from the current repository. It's a lower-level command that is usually wrapped by the git fetch command. The command can take a number of arguments to modify its behavior, including options to fetch all remote refs, limit the depth of the fetch, and specify the path to git-upload-pack on the remote side.",
            "api_name_original": "git-fetch-pack",
            "api_arguments_original": [
                "--all",
                "--stdin",
                "-q",
                "--quiet",
                "-k",
                "--keep",
                "--thin",
                "--include-tag",
                "--upload-pack",
                "--depth",
                "--shallow-since",
                "--shallow-exclude",
                "--deepen-relative",
                "--refetch",
                "--no-progress",
                "--check-self-contained-and-connected",
                "-v",
                "<repository>",
                "<refs>"
            ]
        }
    },
    {
        "query": "I want to export a single commit with the SHA-1 value 'commit-sha1' to a CVS checkout located in the directory '~/project_cvs_checkout'.",
        "model_answer": "git.cvsexportcommit(verbose=True, conflict=True, working_directory='~/project_cvs_checkout', commit_id='commit-sha1')",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Export a single commit to a CVS checkout",
            "api_name": "git.cvsexportcommit",
            "api_call": "git cvsexportcommit -v -c -w ~/project_cvs_checkout <commit-sha1>",
            "api_arguments": [
                {
                    "name": "_h"
                },
                {
                    "name": "_u"
                },
                {
                    "name": "_v"
                },
                {
                    "name": "_c"
                },
                {
                    "name": "_p"
                },
                {
                    "name": "_p"
                },
                {
                    "name": "_a"
                },
                {
                    "name": "_d_cvsroot"
                },
                {
                    "name": "_w_cvs_workdir"
                },
                {
                    "name": "_w"
                },
                {
                    "name": "_f"
                },
                {
                    "name": "_m_msgprefix"
                },
                {
                    "name": "parent_commit"
                },
                {
                    "name": "commit_id"
                }
            ],
            "python_environment_requirements": [
                "git"
            ],
            "example_code": [
                {
                    "description": "Merge one patch into CVS",
                    "code": "$ export GIT_DIR=~/project/.git\n$ cd ~/project_cvs_checkout\n$ git cvsexportcommit -v <commit-sha1>\n$ cvs commit -F .msg <files>"
                },
                {
                    "description": "Merge one patch into CVS (-c and -w options). The working directory is within the Git Repo",
                    "code": "$ git cvsexportcommit -v -c -w ~/project_cvs_checkout <commit-sha1>"
                },
                {
                    "description": "Merge pending patches into CVS automatically\u2009\u2014\u2009only if you really know what you are doing",
                    "code": "$ export GIT_DIR=~/project/.git\n$ cd ~/project_cvs_checkout\n$ git cherry cvshead myhead | sed -n 's/^+ //p' | xargs -l1 git cvsexportcommit -c -p -v"
                }
            ],
            "description": "The git-cvsexportcommit API enables the export of a single commit from Git to a CVS checkout. This makes it easier to merge patches from a Git repository into a CVS repository. The API supports file additions, removals, and commits that affect binary files. If the commit is a merge commit, you must tell git cvsexportcommit what parent the changeset should be done against.",
            "api_name_original": "git-cvsexportcommit",
            "api_arguments_original": [
                "-h",
                "-u",
                "-v",
                "-c",
                "-P",
                "-p",
                "-a",
                "-d <cvsroot>",
                "-w <cvs-workdir>",
                "-W",
                "-f",
                "-m <msgprefix>",
                "<parent-commit>",
                "<commit-id>"
            ]
        }
    },
    {
        "query": "I want to remove extra objects that are already in pack files on GitHub using the git-prune-packed command.",
        "model_answer": "git.prune_packed()",
        "original": {
            "domain": "github",
            "framework": "git",
            "functionality": "Remove extra objects that are already in pack files",
            "api_name": "git.prune_packed",
            "api_call": "git prune-packed [-n | --dry-run] [-q | --quiet]",
            "api_arguments": [
                {
                    "name": "_n_|_dry_run"
                },
                {
                    "name": "_q_|_quiet"
                }
            ],
            "python_environment_requirements": "git",
            "example_code": [],
            "description": "This program searches the $GIT_OBJECT_DIRECTORY for all objects that currently exist in a pack file as well as the independent object directories. All such extra objects are removed. A pack is a collection of objects, individually compressed, with delta compression applied, stored in a single file, with an associated index file. Packs are used to reduce the load on mirror systems, backup engines, disk storage, etc.",
            "api_name_original": "git-prune-packed",
            "api_arguments_original": [
                "-n | --dry-run",
                "-q | --quiet"
            ]
        }
    },
    {
        "query": "I want to find the symbolic name for the commit \"a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0u1v2w3x4y5z\" in my git repository.",
        "model_answer": "git.name_rev('a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0u1v2w3x4y5z')",
        "original": {
            "domain": "https://git-scm.com/docs/git-name-rev",
            "framework": "git",
            "functionality": "Find symbolic names for given revisions",
            "api_name": "git.name_rev",
            "api_call": "git name-rev <commit-ish>",
            "api_arguments": [
                {
                    "name": "tags"
                },
                {
                    "name": "refs"
                },
                {
                    "name": "exclude"
                },
                {
                    "name": "all"
                },
                {
                    "name": "annotate_stdin"
                },
                {
                    "name": "name_only"
                },
                {
                    "name": "no_undefined"
                },
                {
                    "name": "always"
                }
            ],
            "python_environment_requirements": "git",
            "example_code": [
                {
                    "description": "Given a commit, find out where it is relative to the local refs.",
                    "code": "git name-rev 33db5f4d9027a10e477ccf054b2c1ab94f74c85a"
                },
                {
                    "description": "Annotate stdin with symbolic names",
                    "code": "git log | git name-rev --annotate-stdin"
                }
            ],
            "description": "The git-name-rev API is used to find symbolic names suitable for human digestion for revisions given in any format parsable by git rev-parse. This can be useful to understand the context of a commit relative to local refs. The API provides various options for filtering and formatting the output.",
            "api_name_original": "git-name-rev",
            "api_arguments_original": [
                "--tags",
                "--refs=<pattern>",
                "--exclude=<pattern>",
                "--all",
                "--annotate-stdin",
                "--name-only",
                "--no-undefined",
                "--always"
            ]
        }
    },
    {
        "query": "I want to stash my changes in Git to switch to a different branch and work on it.",
        "model_answer": "git.stash()",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Stashing changes",
            "api_name": "git.stash",
            "api_call": "git stash",
            "api_arguments": [
                {
                    "name": "list"
                },
                {
                    "name": "show"
                },
                {
                    "name": "drop"
                },
                {
                    "name": "pop"
                },
                {
                    "name": "apply"
                },
                {
                    "name": "branch"
                },
                {
                    "name": "push"
                },
                {
                    "name": "save"
                },
                {
                    "name": "clear"
                },
                {
                    "name": "create"
                },
                {
                    "name": "store"
                }
            ],
            "python_environment_requirements": [
                "gitpython"
            ],
            "example_code": [
                {
                    "description": "Pulling into a dirty tree",
                    "code": "$ git pull\n$ git stash\n$ git pull\n$ git stash pop"
                },
                {
                    "description": "Interrupted workflow",
                    "code": "$ git stash\n$ edit emergency fix\n$ git commit -a -m \"Fix in a hurry\"\n$ git stash pop"
                },
                {
                    "description": "Testing partial commits",
                    "code": "$ git add --patch foo\n$ git stash push --keep-index\n$ edit/build/test first part\n$ git commit -m 'First part'\n$ git stash pop"
                },
                {
                    "description": "Saving unrelated changes for future use",
                    "code": "$ git add --patch foo\n$ git stash push --staged\n$ git commit -m 'Massive'\n$ git switch fixup-branch\n$ git stash pop"
                },
                {
                    "description": "Recovering stash entries that were cleared/dropped erroneously",
                    "code": "git fsck --unreachable |\ngrep commit | cut -d\\ -f3 |\nxargs git log --merges --no-walk --grep=WIP"
                }
            ],
            "description": "The git-stash command allows you to save changes that you have made but do not want to commit immediately. You can stash the changes, switch to a different branch and work on it, then come back and re-apply the stashed changes. This is useful when you want to switch context without losing your work.",
            "api_name_original": "git-stash",
            "api_arguments_original": [
                "list",
                "show",
                "drop",
                "pop",
                "apply",
                "branch",
                "push",
                "save",
                "clear",
                "create",
                "store"
            ]
        }
    },
    {
        "query": "I want to run a Git maintenance command on a list of repositories stored in a config variable named \"maintenance.repo\" and pass the arguments \"maintenance run\".",
        "model_answer": "git.for_each_repo(config=\"maintenance.repo\", arguments=\"maintenance run\")",
        "original": {
            "domain": "git",
            "framework": "Git",
            "functionality": "Run a Git command on a list of repositories",
            "api_name": "git.for_each_repo(config=\"maintenance.repo\", arguments=\"maintenance run\"",
            "api_call": "git for-each-repo --config=<config> [--] <arguments>",
            "api_arguments": [
                {
                    "name": "config",
                    "description": "Use the given config variable as a multi-valued list storing absolute path names. Iterate on that list of paths to run the given arguments."
                },
                {
                    "name": "arguments",
                    "description": "The arguments after the known options or -- indicator are used as the arguments for the Git subprocess."
                }
            ],
            "python_environment_requirements": "Git version 2.41.0 or higher",
            "example_code": [
                {
                    "description": "For example, we could run maintenance on each of a list of repositories stored in a maintenance.repo config variable using",
                    "code": "git for-each-repo --config=maintenance.repo maintenance run"
                }
            ],
            "description": "The git-for-each-repo API is used to run a Git command on a list of repositories. It takes a config variable that stores absolute path names as a multi-valued list and iterates on that list of paths to run the given arguments. This command is experimental and the behavior may change.",
            "api_name_original": "git-for-each-repo",
            "api_arguments_original": {
                "config": "Use the given config variable as a multi-valued list storing absolute path names. Iterate on that list of paths to run the given arguments.",
                "arguments": "The arguments after the known options or -- indicator are used as the arguments for the Git subprocess."
            }
        }
    },
    {
        "query": "Display help information about Git including the manual page.",
        "model_answer": "git.help(man=True)",
        "original": {
            "domain": "git",
            "framework": "Git",
            "functionality": "Display help information about Git",
            "api_name": "git.help",
            "api_call": "git help [<command>|<doc>]",
            "api_arguments": [
                {
                    "name": "_a|all"
                },
                {
                    "name": "[no_]verbose"
                },
                {
                    "name": "[no_]external_commands"
                },
                {
                    "name": "[no_]aliases"
                },
                {
                    "name": "_i|info"
                },
                {
                    "name": "_m|man"
                },
                {
                    "name": "_w|web"
                },
                {
                    "name": "_g|guides"
                },
                {
                    "name": "_c|config"
                },
                {
                    "name": "user_interfaces"
                },
                {
                    "name": "developer_interfaces"
                }
            ],
            "python_environment_requirements": [
                "Git"
            ],
            "example_code": [
                {
                    "description": "Display help information about Git",
                    "code": "git help"
                }
            ],
            "description": "The git-help command is used to display help information about Git. It can list all available commands, show guides, list all configuration variables, and more. It can also display the manual page for a specific command or other documentation. The output format and viewer can be customized through command-line options or configuration variables.",
            "api_name_original": "git-help",
            "api_arguments_original": [
                "-a|--all",
                "--[no-]verbose",
                "--[no-]external-commands",
                "--[no-]aliases",
                "-i|--info",
                "-m|--man",
                "-w|--web",
                "-g|--guides",
                "-c|--config",
                "--user-interfaces",
                "--developer-interfaces"
            ]
        }
    },
    {
        "query": "I want to create a tree object from the current index in my git repository.",
        "model_answer": "git.write_tree()",
        "original": {
            "domain": "github",
            "framework": "git",
            "functionality": "Create a tree object from the current index",
            "api_name": "git.write_tree",
            "api_call": "git write-tree [--missing-ok] [--prefix=<prefix>/]",
            "api_arguments": [
                {
                    "name": "missing_ok"
                },
                {
                    "name": "prefix"
                }
            ],
            "python_environment_requirements": [
                "git"
            ],
            "example_code": [],
            "description": "The git-write-tree API is a part of the git suite. It creates a tree object using the current index and prints the name of the new tree object to standard output. The index must be in a fully merged state. Conceptually, git write-tree sync()s the current index contents into a set of tree files. In order to have that match what is actually in your directory right now, you need to have done a git update-index phase before you did the git write-tree. It ensures that the objects referenced by the directory exist in the object database and can write a tree object that represents a subdirectory.",
            "api_name_original": "git-write-tree",
            "api_arguments_original": [
                "--missing-ok",
                "--prefix=<prefix>/"
            ]
        }
    },
    {
        "query": "I want to import a Git repository from a GNU Arch repository called \"repo1/main\" into Git.",
        "model_answer": "git.archimport(\"repo1/main\")",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Import a GNU Arch repository into Git",
            "api_name": "git.archimport",
            "api_call": "git archimport [-h] [-v] [-o] [-a] [-f] [-T] [-D <depth>] [-t <tempdir>] <archive>/<branch>[:<git-branch>]\u2026\u200b",
            "api_arguments": [
                {
                    "name": "_h"
                },
                {
                    "name": "_v"
                },
                {
                    "name": "_o"
                },
                {
                    "name": "_a"
                },
                {
                    "name": "_f"
                },
                {
                    "name": "_t"
                },
                {
                    "name": "_d_depth"
                },
                {
                    "name": "_t_tempdir"
                },
                {
                    "name": "archive/branch[git_branch]"
                }
            ],
            "python_environment_requirements": [
                "tla"
            ],
            "example_code": [],
            "description": "The 'git-archimport' API is a command in Git that imports a project from one or more GNU Arch repositories. It follows branches and repositories within the namespaces defined by the <archive>/<branch> parameters supplied. If it cannot find the remote branch a merge comes from, it will just import it as a regular commit. If it can find it, it will mark it as a merge whenever possible. The script expects you to provide the key roots where it can start the import from an initial import or tag type of Arch commit. It will follow and import new branches within the provided roots.",
            "api_name_original": "git-archimport",
            "api_arguments_original": [
                "-h",
                "-v",
                "-o",
                "-a",
                "-f",
                "-T",
                "-D <depth>",
                "-t <tempdir>",
                "<archive>/<branch>[:<git-branch>]"
            ]
        }
    },
    {
        "query": "Can you please provide a Python function call to access and manipulate the Git index format?",
        "model_answer": "git.format_index()",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Access and manipulate Git index format",
            "api_name": "git.format_index",
            "api_call": "N/A",
            "api_arguments": "N/A",
            "python_environment_requirements": "N/A",
            "example_code": [],
            "description": "The gitformat-index API is part of the Git suite and provides functionality to access and manipulate the Git index format. The Git index format is a binary file (network byte order) that stores the information about the repository, such as branches and merges, changes, and extensions. The API provides detailed information about the structure and interpretation of the index format.",
            "api_name_original": "gitformat-index",
            "api_arguments_original": "N/A"
        }
    },
    {
        "query": "I want to cleanup and optimize my local Git repository using git-gc, including aggressive pruning and quiet mode.",
        "model_answer": "git.gc(aggressive=True, quiet=True)",
        "original": {
            "domain": "git",
            "framework": "Git",
            "functionality": "Cleanup and optimize local repository",
            "api_name": "gcloud.compute.instances().list",
            "api_call": "git gc [--aggressive] [--auto] [--quiet] [--prune=<date> | --no-prune] [--force] [--keep-largest-pack]",
            "api_arguments": [
                {
                    "name": "aggressive"
                },
                {
                    "name": "auto"
                },
                {
                    "name": "quiet"
                },
                {
                    "name": "prune"
                },
                {
                    "name": "no_prune"
                },
                {
                    "name": "force"
                },
                {
                    "name": "keep_largest_pack"
                }
            ],
            "python_environment_requirements": "GitPython library",
            "example_code": [
                {
                    "description": "Optimize the repository with git gc",
                    "code": "git gc --aggressive"
                }
            ],
            "description": "The git-gc command is used to cleanup unnecessary files and optimize the local repository. It runs a number of housekeeping tasks within the current repository, such as compressing file revisions (to reduce disk space and increase performance), removing unreachable objects which may have been created from prior invocations of git add, packing refs, pruning reflog, rerere metadata or stale working trees. It may also update ancillary indexes such as the commit-graph.",
            "api_name_original": "git-gc",
            "api_arguments_original": [
                "--aggressive",
                "--auto",
                "--quiet",
                "--prune",
                "--no-prune",
                "--force",
                "--keep-largest-pack"
            ]
        }
    },
    {
        "query": "I want to list and format the references in a git repository, showing the most recent 10 tagged commits.",
        "model_answer": "git.for_each_ref(count=10, sort=\"-authordate\", format=\"'From: %(*authorname) %(*authoremail) Subject: %(*subject) Date: %(*authordate) Ref: %(*refname) %(*body)' 'refs/tags'\")",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "List and format references",
            "api_name": "git.for_each_ref",
            "api_call": "git for-each-ref [options]",
            "api_arguments": [
                {
                    "name": "count"
                },
                {
                    "name": "shell|perl|python|tcl"
                },
                {
                    "name": "sort"
                },
                {
                    "name": "format"
                },
                {
                    "name": "stdin_|_pattern\u2026\u200b"
                },
                {
                    "name": "points_at"
                },
                {
                    "name": "merged["
                },
                {
                    "name": "no_merged["
                },
                {
                    "name": "contains["
                },
                {
                    "name": "no_contains["
                }
            ],
            "python_environment_requirements": [
                "git"
            ],
            "example_code": [
                {
                    "description": "Show the most recent 3 tagged commits",
                    "code": "git for-each-ref --count=3 --sort='-authordate' --format='From: %(*authorname) %(*authoremail) Subject: %(*subject) Date: %(*authordate) Ref: %(*refname) %(*body)' 'refs/tags'"
                },
                {
                    "description": "List the prefixes of all heads",
                    "code": "git for-each-ref --shell --format='ref=%(refname)' refs/heads | while read entry do eval '$entry' echo `dirname $ref` done"
                }
            ],
            "description": "The git-for-each-ref API is used to output information on each ref. It iterates over all refs that match a given pattern and shows them according to a specified format, after sorting them according to a given set of keys. If a count is given, it stops after showing that many refs. The interpolated values in the format can optionally be quoted as string literals in the specified host language allowing their direct evaluation in that language.",
            "api_name_original": "git-for-each-ref",
            "api_arguments_original": [
                "--count=<count>",
                "--shell|--perl|--python|--tcl",
                "(--sort=<key>)\u2026\u200b",
                "--format=<format>",
                "--stdin | <pattern>\u2026\u200b",
                "--points-at=<object>",
                "--merged[=<object>]",
                "--no-merged[=<object>]",
                "--contains[=<object>]",
                "--no-contains[=<object>]"
            ]
        }
    },
    {
        "query": "Please provide me with a python function call to show information about files in the index and the working tree using the git-ls-tree API.",
        "model_answer": "git.ls_files()",
        "original": {
            "domain": "git",
            "framework": "Git",
            "functionality": "Show information about files in the index and the working tree",
            "api_name": "git.ls_files",
            "api_call": "git ls-files [-z] [-t] [-v] [-f] [-c|--cached] [-d|--deleted] [-o|--others] [-i|--ignored] [-s|--stage] [-u|--unmerged] [-k|--killed] [-m|--modified] [--resolve-undo] [--directory [--no-empty-directory]] [--eol] [--deduplicate] [-x <pattern>|--exclude=<pattern>] [-X <file>|--exclude-from=<file>] [--exclude-per-directory=<file>] [--exclude-standard] [--error-unmatch] [--with-tree=<tree-ish>] [--full-name] [--recurse-submodules] [--abbrev[=<n>]] [--format=<format>] [--] [<file>\u2026\u200b]",
            "api_arguments": [
                {
                    "name": "_z"
                },
                {
                    "name": "_t"
                },
                {
                    "name": "_v"
                },
                {
                    "name": "_f"
                },
                {
                    "name": "_c|cached"
                },
                {
                    "name": "_d|deleted"
                },
                {
                    "name": "_o|others"
                },
                {
                    "name": "_i|ignored"
                },
                {
                    "name": "_s|stage"
                },
                {
                    "name": "_u|unmerged"
                },
                {
                    "name": "_k|killed"
                },
                {
                    "name": "_m|modified"
                },
                {
                    "name": "resolve_undo"
                },
                {
                    "name": "directory_[no_empty_directory]"
                },
                {
                    "name": "eol"
                },
                {
                    "name": "deduplicate"
                },
                {
                    "name": "_x_pattern|exclude"
                },
                {
                    "name": "_x_file|exclude_from"
                },
                {
                    "name": "exclude_per_directory"
                },
                {
                    "name": "exclude_standard"
                },
                {
                    "name": "error_unmatch"
                },
                {
                    "name": "with_tree"
                },
                {
                    "name": "full_name"
                },
                {
                    "name": "recurse_submodules"
                },
                {
                    "name": "abbrev["
                },
                {
                    "name": "format"
                },
                {
                    "name": ""
                },
                {
                    "name": "file"
                }
            ],
            "python_environment_requirements": [
                "Git"
            ],
            "example_code": [],
            "description": "The git-ls-files API is used to show information about files in the index and the working tree. It merges the file listing in the index with the actual working directory list, and shows different combinations of the two. One or more of the options may be used to determine the files shown, and each file may be printed multiple times if there are multiple entries in the index or multiple statuses are applicable for the relevant file selection options.",
            "api_name_original": "git-ls-files",
            "api_arguments_original": [
                "-z",
                "-t",
                "-v",
                "-f",
                "-c|--cached",
                "-d|--deleted",
                "-o|--others",
                "-i|--ignored",
                "-s|--stage",
                "-u|--unmerged",
                "-k|--killed",
                "-m|--modified",
                "--resolve-undo",
                "--directory [--no-empty-directory]",
                "--eol",
                "--deduplicate",
                "-x <pattern>|--exclude=<pattern>",
                "-X <file>|--exclude-from=<file>",
                "--exclude-per-directory=<file>",
                "--exclude-standard",
                "--error-unmatch",
                "--with-tree=<tree-ish>",
                "--full-name",
                "--recurse-submodules",
                "--abbrev[=<n>]",
                "--format=<format>",
                "--",
                "<file>"
            ]
        }
    },
    {
        "query": "I would like to check the status of my git repository.",
        "model_answer": "git.status()",
        "original": {
            "domain": "github",
            "framework": "git",
            "functionality": "Show the working tree status",
            "api_name": "git.status",
            "api_call": "git status [<options>] [--] [<pathspec>\u2026\u200b]",
            "api_arguments": [
                {
                    "name": "options"
                },
                {
                    "name": "pathspec"
                }
            ],
            "python_environment_requirements": [],
            "example_code": [],
            "description": "The git-status API displays paths that have differences between the index file and the current HEAD commit, paths that have differences between the working tree and the index file, and paths in the working tree that are not tracked by Git (and are not ignored by gitignore[5]). The first are what you would commit by running git commit; the second and third are what you could commit by running git add before running git commit.",
            "api_name_original": "git-status",
            "api_arguments_original": [
                "<options>",
                "<pathspec>"
            ]
        }
    },
    {
        "query": "I want to start gitweb and a web server to browse my local repository using git-instaweb.",
        "model_answer": "git.instaweb()",
        "original": {
            "domain": "git",
            "framework": "Git",
            "functionality": "Instantly browse your working repository in gitweb",
            "api_name": "git.instaweb",
            "api_call": "git instaweb [--local] [--httpd=<httpd>] [--port=<port>] [--browser=<browser>]",
            "api_arguments": [
                {
                    "name": "local"
                },
                {
                    "name": "httpd"
                },
                {
                    "name": "port"
                },
                {
                    "name": "browser"
                },
                {
                    "name": "start"
                },
                {
                    "name": "stop"
                },
                {
                    "name": "restart"
                }
            ],
            "python_environment_requirements": [],
            "example_code": [],
            "description": "git-instaweb is a simple script to set up gitweb and a web server for browsing the local repository. It allows to start, stop and restart the httpd instance. You can specify the HTTP daemon, port number, and the web browser to view the gitweb page. Configuration can be specified in your .git/config.",
            "api_name_original": "git-instaweb",
            "api_arguments_original": [
                "--local",
                "--httpd",
                "--port",
                "--browser",
                "--start",
                "--stop",
                "--restart"
            ]
        }
    },
    {
        "query": "I want to compute the object ID for a file named \"myfile.txt\" and create a blob using the git-hash-object API.",
        "model_answer": "git.hash_object(\"--path=myfile.txt\")",
        "original": {
            "domain": "git",
            "framework": "Git",
            "functionality": "Compute object ID and optionally creates a blob from a file",
            "api_name": "git.hash_object",
            "api_call": "git hash-object [-t <type>] [-w] [--path=<file> | --no-filters] [--stdin [--literally]] [--] <file>",
            "api_arguments": [
                {
                    "name": "_t_type"
                },
                {
                    "name": "_w"
                },
                {
                    "name": "path"
                },
                {
                    "name": "no_filters"
                },
                {
                    "name": "stdin"
                },
                {
                    "name": "stdin_paths"
                },
                {
                    "name": "literally"
                }
            ],
            "python_environment_requirements": [
                "Git"
            ],
            "example_code": [],
            "description": "The git-hash-object API computes the object ID value for an object with specified type with the contents of the named file (which can be outside of the work tree), and optionally writes the resulting object into the object database. Reports its object ID to its standard output. When <type> is not specified, it defaults to 'blob'. This API is part of the git suite.",
            "api_name_original": "git-hash-object",
            "api_arguments_original": [
                "-t <type>",
                "-w",
                "--path=<file>",
                "--no-filters",
                "--stdin",
                "--stdin-paths",
                "--literally"
            ]
        }
    },
    {
        "query": "I want to clone a repository from GitLab.",
        "model_answer": "git.clone(repository=\"<repository>\")",
        "original": {
            "domain": "github",
            "framework": "git",
            "functionality": "Cloning a repository",
            "api_name": "git.clone",
            "api_call": "git clone <repository>",
            "api_arguments": [
                {
                    "name": "repository"
                }
            ],
            "python_environment_requirements": [],
            "example_code": [
                {
                    "description": "Clone from upstream",
                    "code": "git clone git://git.kernel.org/pub/scm/.../linux.git my-linux"
                },
                {
                    "description": "Make a local clone that borrows from the current directory, without checking things out",
                    "code": "git clone -l -s -n . ../copy"
                },
                {
                    "description": "Clone from upstream while borrowing from an existing local directory",
                    "code": "git clone --reference /git/linux.git git://git.kernel.org/pub/scm/.../linux.git my-linux"
                },
                {
                    "description": "Create a bare repository to publish your changes to the public",
                    "code": "git clone --bare -l /home/proj/.git /pub/scm/proj.git"
                }
            ],
            "description": "The git-clone API is used to clone a repository into a new directory. It creates remote-tracking branches for each branch in the cloned repository and creates and checks out an initial branch that is forked from the cloned repository\u2019s currently active branch. It is a fundamental functionality in the git API that allows users to copy and work on repositories locally.",
            "api_name_original": "git-clone",
            "api_arguments_original": [
                "repository"
            ]
        }
    },
    {
        "query": "I want to verify the commit-graph file for the packed commits in my local .git directory and show the progress.",
        "model_answer": "git.commit_graph.verify(progress=True)",
        "original": {
            "domain": "github",
            "framework": "git",
            "functionality": "Write and verify Git commit-graph files",
            "api_name": "git.commit_graph.verify",
            "api_call": "git commit-graph write",
            "api_arguments": [
                {
                    "name": "object_dir"
                },
                {
                    "name": "append"
                },
                {
                    "name": "split"
                },
                {
                    "name": "reachable"
                },
                {
                    "name": "stdin_packs"
                },
                {
                    "name": "stdin_commits"
                },
                {
                    "name": "changed_paths"
                },
                {
                    "name": "max_new_filters"
                },
                {
                    "name": "progress"
                }
            ],
            "python_environment_requirements": [
                "git"
            ],
            "example_code": [
                {
                    "description": "Write a commit-graph file for the packed commits in your local .git directory.",
                    "code": "git commit-graph write"
                },
                {
                    "description": "Write a commit-graph file, extending the current commit-graph file using commits in <pack-index>.",
                    "code": "echo <pack-index> | git commit-graph write --stdin-packs"
                },
                {
                    "description": "Write a commit-graph file containing all reachable commits.",
                    "code": "git show-ref -s | git commit-graph write --stdin-commits"
                },
                {
                    "description": "Write a commit-graph file containing all commits in the current commit-graph file along with those reachable from HEAD.",
                    "code": "git rev-parse HEAD | git commit-graph write --stdin-commits --append"
                }
            ],
            "description": "The git-commit-graph API allows you to manage the serialized commit-graph file in your Git repository. You can write a new commit-graph file, append to the existing one, and verify its contents against the object database. It supports a variety of arguments to customize the operation. It also provides options to generate the new commit graph by walking commits starting at all refs, specified pack-indexes or commits specified in stdin. It is part of the Git suite and requires the Git software to be installed in your environment.",
            "api_name_original": "git-commit-graph",
            "api_arguments_original": [
                "--object-dir",
                "--append",
                "--split",
                "--reachable",
                "--stdin-packs",
                "--stdin-commits",
                "--changed-paths",
                "--max-new-filters",
                "--progress"
            ]
        }
    },
    {
        "query": "I want to push updates to my Git repository located at /path/to/my/repository.git.",
        "model_answer": "git.receive_pack(\"/path/to/my/repository.git\")",
        "original": {
            "domain": "git",
            "framework": "Git",
            "functionality": "Receive updates pushed into the repository",
            "api_name": "git.receive_pack",
            "api_call": "git receive-pack <git-dir>",
            "api_arguments": [
                {
                    "name": "git_dir"
                }
            ],
            "python_environment_requirements": [],
            "example_code": [],
            "description": "The git-receive-pack command is invoked by git send-pack and updates the repository with the information fed from the remote end. This command is usually not invoked directly by the end user. The UI for the protocol is on the git send-pack side, and the program pair is meant to be used to push updates to remote repository. For pull operations, see git-fetch-pack. The command allows for creation and fast-forwarding of sha1 refs (heads/tags) on the remote end. git-receive-pack honours the receive.denyNonFastForwards config option, which tells it if updates to a ref should be denied if they are not fast-forwards.",
            "api_name_original": "git-receive-pack",
            "api_arguments_original": [
                "<git-dir>"
            ]
        }
    },
    {
        "query": "I want to retrieve the submodule properties in the .gitmodules file.",
        "model_answer": "git.gitmodules",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Defining submodule properties",
            "api_name": "git.gitmodule",
            "api_call": "$GIT_WORK_TREE/.gitmodules",
            "api_arguments": [
                {
                    "name": "submodule.name.path"
                },
                {
                    "name": "submodule.name.url"
                },
                {
                    "name": "submodule.name.update"
                },
                {
                    "name": "submodule.name.branch"
                },
                {
                    "name": "submodule.name.fetchrecursesubmodules"
                },
                {
                    "name": "submodule.name.ignore"
                },
                {
                    "name": "submodule.name.shallow"
                }
            ],
            "python_environment_requirements": "git",
            "example_code": [
                {
                    "description": "Example .gitmodules file",
                    "code": "[submodule \"libfoo\"]\n\tpath = include/foo\n\turl = git://foo.com/git/lib.git\n[submodule \"libbar\"]\n\tpath = include/bar\n\turl = git://bar.com/git/lib.git"
                }
            ],
            "description": "The .gitmodules file, located in the top-level directory of a Git working tree, is a text file with a syntax matching the requirements of git-config[1]. The file contains one subsection per submodule, and the subsection value is the name of the submodule. The name is set to the path where the submodule has been added unless it was customized with the --name option of git submodule add. Each submodule section also contains the following required keys: submodule.<name>.path, submodule.<name>.url, and a number of optional keys.",
            "api_name_original": "gitmodules",
            "api_arguments_original": [
                "submodule.<name>.path",
                "submodule.<name>.url",
                "submodule.<name>.update",
                "submodule.<name>.branch",
                "submodule.<name>.fetchRecurseSubmodules",
                "submodule.<name>.ignore",
                "submodule.<name>.shallow"
            ]
        }
    },
    {
        "query": "I want to get the content and type of a git object with the SHA-1 hash 'def456'.",
        "model_answer": "git.cat_file('blob', 'def456')",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Provide content or type and size information for repository objects",
            "api_name": "git.cat_file",
            "api_call": "git cat-file <type> <object>",
            "api_arguments": [
                {
                    "name": "type"
                },
                {
                    "name": "object"
                }
            ],
            "python_environment_requirements": [],
            "example_code": [],
            "description": "The git-cat-file command provides the content or type of an object in the repository. It can also provide the size of an object. This command can be used in two forms. In the first form, the command is directly used to get the content or type of an object. In the second form, a list of objects is provided on stdin, and the SHA-1, type, and size of each object is printed on stdout. The output format can be overridden using the optional <format> argument. If either --textconv or --filters was specified, the input is expected to list the object names followed by the path name, separated by a single whitespace, so that the appropriate drivers can be determined.",
            "api_name_original": "git-cat-file",
            "api_arguments_original": [
                "type",
                "object"
            ]
        }
    },
    {
        "query": "I want to switch to the 'develop' branch in my Git repository.",
        "model_answer": "git.switch('develop')",
        "original": {
            "domain": "git",
            "framework": "Git",
            "functionality": "Switch branches",
            "api_name": "git.switch",
            "api_call": "git.switch(branch_name)",
            "api_arguments": [
                {
                    "name": "branch_name"
                }
            ],
            "python_environment_requirements": [
                "gitpython"
            ],
            "example_code": [
                {
                    "description": "Switch to 'master' branch",
                    "code": "git.switch('master')"
                },
                {
                    "description": "Switch to 'mytopic' branch",
                    "code": "git.switch('mytopic')"
                },
                {
                    "description": "Create a new branch 'fixup' from 'HEAD~3'",
                    "code": "git.switch('-c fixup HEAD~3')"
                },
                {
                    "description": "Switch to a new branch 'new-topic' from a remote branch of the same name",
                    "code": "git.switch('new-topic')"
                }
            ],
            "description": "The 'git-switch' API is used to switch to a specified branch. The working tree and the index are updated to match the branch. All new commits will be added to the tip of this branch. Optionally a new branch could be created with either -c, -C, automatically from a remote branch of same name (see --guess), or detach the working tree from any branch with --detach, along with switching.",
            "api_name_original": "git-switch",
            "api_arguments_original": [
                "branch_name"
            ]
        }
    },
    {
        "query": "I want to compare two commit ranges in Git and display the differences between them, where range1 is from commit A to commit B.",
        "model_answer": "git.range_diff(range1=\"A..B\")",
        "original": {
            "domain": "git",
            "framework": "Git",
            "functionality": "Compare two commit ranges",
            "api_name": "git.range_diff(range1=\"rev1..rev2\"",
            "api_call": "git range-diff [--color=[<when>]] [--no-color] [<diff-options>] [--no-dual-color] [--creation-factor=<factor>] [--left-only | --right-only] ( <range1> <range2> | <rev1>\u2026\u200b<rev2> | <base> <rev1> <rev2> ) [[--] <path>\u2026\u200b]",
            "api_arguments": [
                {
                    "name": "color"
                },
                {
                    "name": "no_color"
                },
                {
                    "name": "diff_options"
                },
                {
                    "name": "no_dual_color"
                },
                {
                    "name": "creation_factor"
                },
                {
                    "name": "left_only"
                },
                {
                    "name": "right_only"
                },
                {
                    "name": "range1"
                },
                {
                    "name": "range2"
                },
                {
                    "name": "rev1"
                },
                {
                    "name": "rev2"
                },
                {
                    "name": "base"
                },
                {
                    "name": "path"
                }
            ],
            "python_environment_requirements": [
                "GitPython"
            ],
            "example_code": [
                {
                    "description": "When a rebase required merge conflicts to be resolved, compare the changes introduced by the rebase directly afterwards using",
                    "code": "$ git range-diff @{u} @{1} @"
                }
            ],
            "description": "The git-range-diff command shows the differences between two versions of a patch series, or more generally, two commit ranges (ignoring merge commits). It finds pairs of commits from both commit ranges that correspond with each other. Two commits are said to correspond when the diff between their patches (i.e. the author information, the commit message and the commit diff) is reasonably small compared to the patches' size.",
            "api_name_original": "git-range-diff",
            "api_arguments_original": [
                "--color",
                "--no-color",
                "<diff-options>",
                "--no-dual-color",
                "--creation-factor",
                "--left-only",
                "--right-only",
                "<range1>",
                "<range2>",
                "<rev1>",
                "<rev2>",
                "<base>",
                "<path>"
            ]
        }
    },
    {
        "query": "I want to add the file \"mypresentation.pptx\" to the git repository index.",
        "model_answer": "git.add(\"mypresentation.pptx\")",
        "original": {
            "domain": "git",
            "framework": "Git",
            "functionality": "Add file contents to the index",
            "api_name": "git.add(\"myfile.txt\"",
            "api_call": "git add <file>",
            "api_arguments": [
                {
                    "name": "verbose"
                },
                {
                    "name": "dry_run"
                },
                {
                    "name": "force"
                },
                {
                    "name": "interactive"
                },
                {
                    "name": "patch"
                },
                {
                    "name": "edit"
                },
                {
                    "name": "[no_]all"
                },
                {
                    "name": "[no_]ignore_removal"
                },
                {
                    "name": "update"
                },
                {
                    "name": "sparse"
                },
                {
                    "name": "intent_to_add"
                },
                {
                    "name": "refresh"
                },
                {
                    "name": "ignore_errors"
                },
                {
                    "name": "ignore_missing"
                },
                {
                    "name": "renormalize"
                },
                {
                    "name": "chmod"
                },
                {
                    "name": "pathspec_from_file"
                },
                {
                    "name": "pathspec_file_nul"
                }
            ],
            "python_environment_requirements": [],
            "example_code": [
                {
                    "description": "Adds content from all *.txt files under Documentation directory and its subdirectories",
                    "code": "git add Documentation/\\*.txt"
                },
                {
                    "description": "Considers adding content from all git-*.sh scripts",
                    "code": "git add git-*.sh"
                }
            ],
            "description": "The git-add command updates the index using the current content found in the working tree, to prepare the content staged for the next commit. It typically adds the current content of existing paths as a whole, but with some options it can also be used to add content with only part of the changes made to the working tree files applied, or remove paths that do not exist in the working tree anymore.",
            "api_name_original": "git-add",
            "api_arguments_original": [
                "--verbose",
                "--dry-run",
                "--force",
                "--interactive",
                "--patch",
                "--edit",
                "--[no-]all",
                "--[no-]ignore-removal",
                "--update",
                "--sparse",
                "--intent-to-add",
                "--refresh",
                "--ignore-errors",
                "--ignore-missing",
                "--renormalize",
                "--chmod",
                "--pathspec-from-file",
                "--pathspec-file-nul"
            ]
        }
    },
    {
        "query": "I want to generate a zip archive of diagnostic information for my git repository, and place the resulting archive in the directory '/var/repo/diagnostics'.",
        "model_answer": "git.diagnose(output_directory='/var/repo/diagnostics')",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Generate a zip archive of diagnostic information",
            "api_name": "git.diagnose",
            "api_call": "git diagnose [(-o | --output-directory) <path>] [(-s | --suffix) <format>] [--mode=<mode>]",
            "api_arguments": [
                {
                    "name": "_o_|_output_directory_path",
                    "description": "Place the resulting diagnostics archive in <path> instead of the current directory."
                },
                {
                    "name": "_s_|_suffix_format",
                    "description": "Specify an alternate suffix for the diagnostics archive name."
                },
                {
                    "name": "mode",
                    "description": "Specify the type of diagnostics that should be collected."
                }
            ],
            "python_environment_requirements": "git 2.41.0",
            "example_code": [],
            "description": "The git-diagnose command collects detailed information about the user\u2019s machine, Git client, and repository state and packages that information into a zip archive. This archive can be shared with the Git mailing list to help debug an issue or serve as a reference for independent debugging. The command captures various types of information including git version, path to the repository root, available disk space, name and size of each packfile, total count of loose objects and more. Additional information can be collected by selecting a different diagnostic mode using the --mode option.",
            "api_name_original": "git-diagnose",
            "api_arguments_original": {
                "-o | --output-directory <path>": "Place the resulting diagnostics archive in <path> instead of the current directory.",
                "-s | --suffix <format>": "Specify an alternate suffix for the diagnostics archive name.",
                "--mode=(stats|all)": "Specify the type of diagnostics that should be collected."
            }
        }
    },
    {
        "query": "I want to create a new tag named v2.0 with the message 'my version 2.0' in Git.",
        "model_answer": "git.tag(\"-a\", \"v2.0\", \"-m\", \"'my version 2.0'\")",
        "original": {
            "domain": "git",
            "framework": "Git",
            "functionality": "Create, list, delete, or verify a tag object signed with GPG",
            "api_name": "git.tag(\"_a\", \"v1.0\", \"_m\", \"'my version 1.0'\"",
            "api_call": "git tag [-a | -s | -u <key-id>] [-f] [-m <msg> | -F <file>] [-e] <tagname> [<commit> | <object>]",
            "api_arguments": [
                {
                    "name": "_a"
                },
                {
                    "name": "_s"
                },
                {
                    "name": "_u"
                },
                {
                    "name": "_f"
                },
                {
                    "name": "_m"
                },
                {
                    "name": "_f"
                },
                {
                    "name": "_e"
                },
                {
                    "name": "tagname"
                },
                {
                    "name": "commit"
                },
                {
                    "name": "object"
                }
            ],
            "python_environment_requirements": [
                "git"
            ],
            "example_code": [
                {
                    "description": "Create a new tag",
                    "code": "git tag -a v1.0 -m 'my version 1.0'"
                }
            ],
            "description": "The git-tag API is used for creating, listing, deleting, or verifying a tag object that is signed with GPG. It includes a variety of options for different use cases. For instance, '-a', '-s', or '-u <key-id>' is passed to create a tag object and requires a tag message. '-d' is used to delete existing tags with the given names. '-f' replaces an existing tag with the given name. The API also supports GnuPG signed tag objects, annotated tags, and lightweight tags.",
            "api_name_original": "git-tag",
            "api_arguments_original": [
                "-a",
                "-s",
                "-u",
                "-f",
                "-m",
                "-F",
                "-e",
                "<tagname>",
                "<commit>",
                "<object>"
            ]
        }
    },
    {
        "query": "I want to review modified files, stage them, enter a commit message, and record the new commit using git-citool.",
        "model_answer": "git.citool()",
        "original": {
            "domain": "github",
            "framework": "Tcl/Tk",
            "functionality": "Review modified files, stage them, enter a commit message and record the new commit",
            "api_name": "git.citool",
            "api_call": "git citool",
            "api_arguments": [],
            "python_environment_requirements": [],
            "example_code": [],
            "description": "git-citool is a Tcl/Tk based graphical interface that allows users to review modified files, stage them into the index, enter a commit message and record the new commit onto the current branch. This interface is an alternative to the less interactive git commit program.",
            "api_name_original": "git-citool",
            "api_arguments_original": []
        }
    },
    {
        "query": "I want to use the Git API for source code management.",
        "model_answer": "git()",
        "original": {
            "domain": "git",
            "framework": "Git",
            "functionality": "Source code management",
            "api_name": "git(",
            "api_call": "git",
            "api_arguments": [],
            "python_environment_requirements": [],
            "example_code": [],
            "description": "Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency. It is easy to learn and has a tiny footprint with lightning fast performance. It outclasses SCM tools like Subversion, CVS, Perforce, and ClearCase with features like cheap local branching, convenient staging areas, and multiple workflows.",
            "api_name_original": "Git API",
            "api_arguments_original": []
        }
    },
    {
        "query": "I want to prune all unreachable objects from my git repository.",
        "model_answer": "git.prune()",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Prune unreachable objects",
            "api_name": "git.prune",
            "api_call": "git prune [-n] [-v] [--progress] [--expire <time>] [--] [<head>\u2026\u200b]",
            "api_arguments": [
                {
                    "name": "_n"
                },
                {
                    "name": "_v"
                },
                {
                    "name": "progress"
                },
                {
                    "name": "expire_time"
                },
                {
                    "name": "head"
                }
            ],
            "python_environment_requirements": [
                "git"
            ],
            "example_code": [
                {
                    "description": "To prune objects not used by your repository or another that borrows from your repository via its .git/objects/info/alternates:",
                    "code": "git prune $(cd ../another && git rev-parse --all)"
                }
            ],
            "description": "The git-prune API is used to prune all unreachable objects from the object database. It runs git fsck --unreachable using all the refs available in refs/, optionally with additional set of objects specified on the command line, and prunes all unpacked objects unreachable from any of these head objects from the object database. It also removes entries from .git/shallow that are not reachable by any ref.",
            "api_name_original": "git-prune",
            "api_arguments_original": [
                "-n",
                "-v",
                "--progress",
                "--expire <time>",
                "<head>"
            ]
        }
    },
    {
        "query": "I would like to get examples of pkt-line actual values for the common protocols used in Git.",
        "model_answer": "gitprotocol_common()",
        "original": {
            "domain": "github",
            "framework": "git",
            "functionality": "Common Protocols",
            "api_name": "gitprotocol_common(",
            "api_call": "gitprotocol-common",
            "api_arguments": [],
            "python_environment_requirements": [
                "git"
            ],
            "example_code": [
                {
                    "description": "Example of pkt-line actual value",
                    "code": "\"0006a\\n\" \"a\\n\"\n\"0005a\" \"a\"\n\"000bfoobar\\n\" \"foobar\\n\"\n\"0004\" \"\""
                }
            ],
            "description": "This API is part of the Git suite and it defines things common to various over-the-wire protocols and file formats used in Git. It includes rules for ABNF notation, refname, and pkt-line format. The pkt-line is a variable length binary string with a maximum length of 65516 bytes. The API also provides examples of pkt-line actual values.",
            "api_name_original": "gitprotocol-common",
            "api_arguments_original": []
        }
    },
    {
        "query": "I want to use the git-cvsimport API to import a CVS repository into Git. I want to specify the following options: use a specific branch for HEAD, set the CVSROOT to a specific directory, use a conversion file for author names, use specific options for cvsps, specify a file for progress output, set the location of the Git repository, specify the fuzz factor for filename matching, enable ignoring CVS directories, enable processing only subdirectories, enable committing empty directories, set a substitution pattern for filenames, enable matching committed by author name, enable automatic file renames, specify a regex pattern to ignore commits, specify a regex pattern to skip imports, limit the number of commits imported, push the imported Git repository to a remote, enable resetting the branch to HEAD after import, and specify the CVS module to import.",
        "model_answer": "git.cvsimport(\"-o\", \"<branch-for-HEAD>\", \"-d\", \"<CVSROOT>\", \"-A\", \"<author-conv-file>\", \"-p\", \"<options-for-cvsps>\", \"-P\", \"<file>\", \"-C\", \"<git-repository>\", \"-z\", \"<fuzz>\", \"-i\", \"-k\", \"-u\", \"-s\", \"<subst>\", \"-a\", \"-m\", \"-M\", \"<regex>\", \"-S\", \"<regex>\", \"-L\", \"<commit-limit>\", \"-r\", \"<remote>\", \"-R\", \"<CVS-module>\")",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Import CVS repositories into Git",
            "api_name": "git.cvsimport",
            "api_call": "git cvsimport [-o <branch-for-HEAD>] [-h] [-v] [-d <CVSROOT>] [-A <author-conv-file>] [-p <options-for-cvsps>] [-P <file>] [-C <git-repository>] [-z <fuzz>] [-i] [-k] [-u] [-s <subst>] [-a] [-m] [-M <regex>] [-S <regex>] [-L <commit-limit>] [-r <remote>] [-R] [<CVS-module>]",
            "api_arguments": [
                {
                    "name": "_o_branch_for_head"
                },
                {
                    "name": "_h"
                },
                {
                    "name": "_v"
                },
                {
                    "name": "_d_cvsroot"
                },
                {
                    "name": "_a_author_conv_file"
                },
                {
                    "name": "_p_options_for_cvsps"
                },
                {
                    "name": "_p_file"
                },
                {
                    "name": "_c_git_repository"
                },
                {
                    "name": "_z_fuzz"
                },
                {
                    "name": "_i"
                },
                {
                    "name": "_k"
                },
                {
                    "name": "_u"
                },
                {
                    "name": "_s_subst"
                },
                {
                    "name": "_a"
                },
                {
                    "name": "_m"
                },
                {
                    "name": "_m_regex"
                },
                {
                    "name": "_s_regex"
                },
                {
                    "name": "_l_commit_limit"
                },
                {
                    "name": "_r_remote"
                },
                {
                    "name": "_r"
                },
                {
                    "name": "cvs_module"
                }
            ],
            "python_environment_requirements": [
                "git"
            ],
            "example_code": [],
            "description": "The git-cvsimport API is used to import a CVS repository into Git. It can create a new repository or incrementally import into an existing one. This API uses cvsps version 2, which is considered deprecated and does not work with cvsps version 3 and later. For one-shot import of a CVS repository, consider using cvs2git or cvs-fast-export. This API provides a variety of options to customize the import process.",
            "api_name_original": "git-cvsimport",
            "api_arguments_original": [
                "-o <branch-for-HEAD>",
                "-h",
                "-v",
                "-d <CVSROOT>",
                "-A <author-conv-file>",
                "-p <options-for-cvsps>",
                "-P <file>",
                "-C <git-repository>",
                "-z <fuzz>",
                "-i",
                "-k",
                "-u",
                "-s <subst>",
                "-a",
                "-m",
                "-M <regex>",
                "-S <regex>",
                "-L <commit-limit>",
                "-r <remote>",
                "-R",
                "<CVS-module>"
            ]
        }
    },
    {
        "query": "I want to write a multi-pack-index file for the packfiles in the current .git directory without a corresponding bitmap.",
        "model_answer": "git.multi_pack_index.write(bitmap=False)",
        "original": {
            "domain": "git",
            "framework": "Git",
            "functionality": "Write and verify multi-pack-indexes in Git",
            "api_name": "git.multi_pack_index.write",
            "api_call": "git multi-pack-index [--object-dir=<dir>] [--[no-]bitmap] <sub-command>",
            "api_arguments": [
                {
                    "name": "object_dir"
                },
                {
                    "name": "[no_]bitmap"
                },
                {
                    "name": "sub_command"
                }
            ],
            "python_environment_requirements": [
                "Git"
            ],
            "example_code": [
                {
                    "description": "Write a MIDX file for the packfiles in the current .git directory.",
                    "code": "git multi-pack-index write"
                },
                {
                    "description": "Write a MIDX file for the packfiles in the current .git directory with a corresponding bitmap.",
                    "code": "git multi-pack-index write --preferred-pack=<pack> --bitmap"
                },
                {
                    "description": "Write a MIDX file for the packfiles in an alternate object store.",
                    "code": "git multi-pack-index --object-dir <alt> write"
                },
                {
                    "description": "Verify the MIDX file for the packfiles in the current .git directory.",
                    "code": "git multi-pack-index verify"
                }
            ],
            "description": "The git-multi-pack-index API is used to write or verify a multi-pack-index (MIDX) file in Git. The MIDX file is a compact version of the .idx index files for packfiles. The MIDX file stores the offsets and CRCs for all objects in all packfiles and can span across multiple packfiles. This API provides options to specify the directory for the location of Git objects, to turn progress on/off explicitly, and to control whether or not a multi-pack bitmap is written.",
            "api_name_original": "git-multi-pack-index",
            "api_arguments_original": [
                "--object-dir=<dir>",
                "--[no-]bitmap",
                "<sub-command>"
            ]
        }
    },
    {
        "query": "I want to use the git-cvsserver to connect to a CVS server using the ssh connection.",
        "model_answer": "git.cvsserver(pserver=False)",
        "original": {
            "domain": "git",
            "framework": "Git",
            "functionality": "CVS server emulator for Git",
            "api_name": "git.cvsserver",
            "api_call": "git cvsserver [<options>] [pserver|server] [<directory> \u2026\u200b]",
            "api_arguments": [
                {
                    "name": "options"
                },
                {
                    "name": "pserver|server"
                },
                {
                    "name": "directory"
                }
            ],
            "python_environment_requirements": "Python 3.6 or later",
            "example_code": [
                {
                    "description": "SSH connection",
                    "code": "export CVS_SERVER=\"git cvsserver\"\ncvs -d :ext:user@server/path/repo.git co <HEAD_name>"
                },
                {
                    "description": "pserver connection",
                    "code": "cvspserver stream tcp nowait nobody /usr/bin/git-cvsserver git-cvsserver pserver"
                }
            ],
            "description": "The git-cvsserver is a CVS emulation layer for Git. It is highly functional, however, not all methods are implemented, and for those methods that are implemented, not all switches are implemented. It has been tested using both the CLI CVS client, and the Eclipse CVS plugin. Most functionality works fine with both of these clients.",
            "api_name_original": "git-cvsserver",
            "api_arguments_original": [
                "options",
                "pserver|server",
                "directory"
            ]
        }
    },
    {
        "query": "I want to store passwords in memory using git-credential-cache, with a timeout of 120 seconds.",
        "model_answer": "git.config('credential.helper', 'cache --timeout=120')",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Temporarily store passwords in memory",
            "api_name": "git.config('credential.helper', 'cache __timeout=60'",
            "api_call": "git config credential.helper 'cache [<options>]'",
            "api_arguments": [
                {
                    "name": "timeout_seconds"
                },
                {
                    "name": "socket_path"
                }
            ],
            "python_environment_requirements": "git",
            "example_code": [
                {
                    "description": "Example usage of git-credential-cache",
                    "code": "$ git config credential.helper cache\n$ git push http://example.com/repo.git\nUsername: <type your username>\nPassword: <type your password>\n[work for 5 more minutes]\n$ git push http://example.com/repo.git\n[your credentials are used automatically]\nYou can provide options via the credential.helper configuration\nvariable (this example increases the cache time to 1 hour):\n$ git config credential.helper 'cache --timeout=3600'"
                }
            ],
            "description": "This command caches credentials for use by future Git programs. The stored credentials are kept in memory of the cache-daemon process (instead of written to a file) and are forgotten after a configurable timeout. Credentials are forgotten sooner if the cache-daemon dies, for example if the system restarts. The cache is accessible over a Unix domain socket, restricted to the current user by filesystem permissions.",
            "api_name_original": "git-credential-cache",
            "api_arguments_original": [
                "--timeout <seconds>",
                "--socket <path>"
            ]
        }
    },
    {
        "query": "I want to format the commit-graph data in my Git repository.",
        "model_answer": "git.format_commit_graph(\"$GIT_DIR/objects/info/commit-graph\", \"$GIT_DIR/objects/info/commit-graphs/*\")",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Commit-graph format",
            "api_name": "git.format_commit_graph",
            "api_call": "git format-commit-graph",
            "api_arguments": [
                {
                    "name": "$git_dir/objects/info/commit_graph"
                },
                {
                    "name": "$git_dir/objects/info/commit_graphs/*"
                }
            ],
            "python_environment_requirements": [
                "gitpython"
            ],
            "example_code": [],
            "description": "The Git commit-graph API is used to store a list of commit OIDs and some associated metadata. It includes the generation number of the commit, the root tree OID, the commit date, the parents of the commit, and the Bloom filter of the commit. The API is designed to allow extensions that add extra data to the graph, and organizes the body into 'chunks' with a binary lookup table at the beginning of the body. The header includes certain values, such as the number of chunks and the hash type. The API also includes optional chunks for additional data.",
            "api_name_original": "gitformat-commit-graph",
            "api_arguments_original": [
                "$GIT_DIR/objects/info/commit-graph",
                "$GIT_DIR/objects/info/commit-graphs/*"
            ]
        }
    },
    {
        "query": "I want to create a new branch named \"feature-123\" in my Git repository.",
        "model_answer": "git.branch('feature-123')",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "list, create, or delete branches",
            "api_name": "git.branch",
            "api_call": "git branch [--color[=<when>] | --no-color] [--show-current] [-v [--abbrev=<n> | --no-abbrev]] [--column[=<options>] | --no-column] [--sort=<key>] [--merged [<commit>]] [--no-merged [<commit>]] [--contains [<commit>]] [--no-contains [<commit>]] [--points-at <object>] [--format=<format>] [(-r | --remotes) | (-a | --all)] [--list] [<pattern>\u2026\u200b]",
            "api_arguments": [
                {
                    "name": "color"
                },
                {
                    "name": "show_current"
                },
                {
                    "name": "_v"
                },
                {
                    "name": "abbrev"
                },
                {
                    "name": "column"
                },
                {
                    "name": "sort"
                },
                {
                    "name": "merged"
                },
                {
                    "name": "no_merged"
                },
                {
                    "name": "contains"
                },
                {
                    "name": "no_contains"
                },
                {
                    "name": "points_at"
                },
                {
                    "name": "format"
                },
                {
                    "name": "_r"
                },
                {
                    "name": "_a"
                },
                {
                    "name": "list"
                },
                {
                    "name": "pattern"
                }
            ],
            "python_environment_requirements": [
                "gitpython"
            ],
            "example_code": [
                {
                    "description": "Start development from a known tag",
                    "code": "$ git clone git://git.kernel.org/pub/scm/.../linux-2.6 my2.6\n$ cd my2.6\n$ git branch my2.6.14 v2.6.14 (1)\n$ git switch my2.6.14"
                },
                {
                    "description": "Delete an unneeded branch",
                    "code": "$ git clone git://git.kernel.org/.../git.git my.git\n$ cd my.git\n$ git branch -d -r origin/todo origin/html origin/man (1)\n$ git branch -D test (2)"
                },
                {
                    "description": "Listing branches from a specific remote",
                    "code": "$ git branch -r -l '<remote>/<pattern>' (1)\n$ git for-each-ref 'refs/remotes/<remote>/<pattern>' (2)"
                }
            ],
            "description": "The git-branch command is used to list, create, or delete branches. It allows you to manage your branches in your repository. You can create a new branch, delete an unneeded one, or list all the branches. This command is also used to delete remote-tracking branches.",
            "api_name_original": "git-branch",
            "api_arguments_original": [
                "--color",
                "--show-current",
                "-v",
                "--abbrev",
                "--column",
                "--sort",
                "--merged",
                "--no-merged",
                "--contains",
                "--no-contains",
                "--points-at",
                "--format",
                "-r",
                "-a",
                "--list",
                "<pattern>"
            ]
        }
    },
    {
        "query": "How do I check the version of git installed on my system?",
        "model_answer": "git.version()",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Git Wire Protocol, Version 2",
            "api_name": "git.version",
            "api_call": "git --version",
            "api_arguments": [
                {
                    "name": "version"
                }
            ],
            "python_environment_requirements": [
                "git"
            ],
            "example_code": [
                {
                    "description": "Check your version of git",
                    "code": "git --version"
                }
            ],
            "description": "The gitprotocol-v2 API is used for managing and interacting with Git repositories. It allows for various operations such as branching, merging, creating projects, and more. The API is designed to be easily extendable and supports multiple commands by a single service. It is designed with HTTP and stateless-rpc in mind, with clear flush semantics the HTTP remote helper can simply act as a proxy. Communication in protocol v2 is command oriented, where a client can request for commands to be executed. The API is part of the git suite and is a member of Software Freedom Conservancy.",
            "api_name_original": "gitprotocol-v2",
            "api_arguments_original": [
                "version"
            ]
        }
    },
    {
        "query": "I want to apply a quilt patchset located in the directory \"my-patches/\" and the series file \"my-series.txt\" onto the current branch in Git, while preserving the patch boundaries, order, and descriptions. I also want to keep non-patch files as well.",
        "model_answer": "git.quiltimport(patches=\"my-patches/\", series=\"my-series.txt\", keep_non_patch=True)",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Apply quilt patchset onto current branch",
            "api_name": "git.quiltimport(patches=\"patches/\", series=\"series.txt\", keep_non_patch=True",
            "api_call": "git.quiltimport(--dry-run | -n, --author <author>, --patches <dir>, --series <file>, --keep-non-patch)",
            "api_arguments": [
                {
                    "name": "dry_run_|__n"
                },
                {
                    "name": "author_author"
                },
                {
                    "name": "patches_dir"
                },
                {
                    "name": "series_file"
                },
                {
                    "name": "keep_non_patch"
                }
            ],
            "python_environment_requirements": [
                "git"
            ],
            "example_code": [],
            "description": "The git-quiltimport API applies a quilt patchset onto the current Git branch, preserving the patch boundaries, patch order, and patch descriptions present in the quilt patchset. For each patch the code attempts to extract the author from the patch description. If that fails it falls back to the author specified with --author. If the --author flag was not given the patch description is displayed and the user is asked to interactively enter the author of the patch. If a subject is not found in the patch description the patch name is preserved as the 1 line subject in the Git description.",
            "api_name_original": "git-quiltimport",
            "api_arguments_original": [
                "--dry-run | -n",
                "--author <author>",
                "--patches <dir>",
                "--series <file>",
                "--keep-non-patch"
            ]
        }
    },
    {
        "query": "I want to run a three-way file merge with the files file1.txt, file2.txt, and file3.txt and write the result into merged-file.txt.",
        "model_answer": "git.merge_file(\"-L file1.txt\", \"-L file2.txt\", \"-L file3.txt\", \"--stdout\", \"--quiet\", \"merged-file.txt\", \"file1.txt\", \"file2.txt\", \"file3.txt\")",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Merging files",
            "api_name": "git.merge_file(\"_L README.my\", \"__stdout\", \"__quiet\", \"README.my\", \"README\", \"README.upstream\"",
            "api_call": "git merge-file [-L <current-name> [-L <base-name> [-L <other-name>]]] [--ours|--theirs|--union] [-p|--stdout] [-q|--quiet] [--marker-size=<n>] [--[no-]diff3] <current-file> <base-file> <other-file>",
            "api_arguments": [
                {
                    "name": "_l_current_name"
                },
                {
                    "name": "_l_base_name"
                },
                {
                    "name": "_l_other_name"
                },
                {
                    "name": "ours"
                },
                {
                    "name": "theirs"
                },
                {
                    "name": "union"
                },
                {
                    "name": "_p"
                },
                {
                    "name": "stdout"
                },
                {
                    "name": "_q"
                },
                {
                    "name": "quiet"
                },
                {
                    "name": "marker_size"
                },
                {
                    "name": "[no_]diff3"
                },
                {
                    "name": "current_file"
                },
                {
                    "name": "base_file"
                },
                {
                    "name": "other_file"
                }
            ],
            "python_environment_requirements": [
                "git"
            ],
            "example_code": [
                {
                    "description": "Combines the changes of README.my and README.upstream since README, tries to merge them and writes the result into README.my.",
                    "code": "git merge-file README.my README README.upstream"
                },
                {
                    "description": "Merges tmp/a123 and tmp/c345 with the base tmp/b234, but uses labels a and c instead of tmp/a123 and tmp/c345.",
                    "code": "git merge-file -L a -L b -L c tmp/a123 tmp/b234 tmp/c345"
                }
            ],
            "description": "The git merge-file API is used to run a three-way file merge. It incorporates all changes that lead from the base-file to the other-file into the current-file. It is useful for combining separate changes to an original. Conflicts are handled by bracketing with lines containing <<<<<<< and >>>>>>> markers. The user is expected to resolve these conflicts by editing the resulting file. The API provides options for resolving conflicts by favoring lines from either the current-file, the other-file, or both. The length of the conflict markers can be adjusted using the --marker-size option. The API is designed to be a minimal clone of RCS merge.",
            "api_name_original": "git-merge-file",
            "api_arguments_original": [
                "-L <current-name>",
                "-L <base-name>",
                "-L <other-name>",
                "--ours",
                "--theirs",
                "--union",
                "-p",
                "--stdout",
                "-q",
                "--quiet",
                "--marker-size=<n>",
                "--[no-]diff3",
                "<current-file>",
                "<base-file>",
                "<other-file>"
            ]
        }
    },
    {
        "query": "Can you provide a Python function call to copy the 'Makefile' file from the index to the working directory using the 'git checkout-index' command?",
        "model_answer": "git.checkout_index(\"--prefix=.merged-\", \"Makefile\")",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Copy files from the index to the working tree",
            "api_name": "git.checkout_index(\"__prefix=.merged_\", \"Makefile\"",
            "api_call": "git checkout-index --prefix=.merged- Makefile",
            "api_arguments": [
                {
                    "name": "_u"
                },
                {
                    "name": "_q"
                },
                {
                    "name": "_a"
                },
                {
                    "name": "_f"
                },
                {
                    "name": "_n"
                },
                {
                    "name": "prefix"
                },
                {
                    "name": "stage"
                },
                {
                    "name": "temp"
                },
                {
                    "name": "ignore_skip_worktree_bits"
                },
                {
                    "name": "_z"
                },
                {
                    "name": "stdin"
                },
                {
                    "name": ""
                },
                {
                    "name": "file\u2026\u200b"
                }
            ],
            "python_environment_requirements": [],
            "example_code": [
                {
                    "description": "To update and refresh only the files already checked out",
                    "code": "git checkout-index -n -f -a && git update-index --ignore-missing --refresh"
                },
                {
                    "description": "Using git checkout-index to 'export an entire tree'",
                    "code": "git checkout-index --prefix=git-export-dir/ -a"
                },
                {
                    "description": "Export files with a prefix",
                    "code": "git checkout-index --prefix=.merged- Makefile"
                }
            ],
            "description": "The git-checkout-index command copies files from the index to the working tree. It provides various options to control the copying process, such as updating stat information for the checked out entries, forcing overwrite of existing files, checking out all files in the index except for those with the skip-worktree bit set, and more. The command can also read list of paths from the standard input, and it can write the content to temporary files instead of copying the files to the working directory. The command is useful in scripts and for tasks like exporting an entire tree or exporting files with a prefix.",
            "api_name_original": "git-checkout-index",
            "api_arguments_original": [
                "-u",
                "-q",
                "-a",
                "-f",
                "-n",
                "--prefix=<string>",
                "--stage=<number>|all",
                "--temp",
                "--ignore-skip-worktree-bits",
                "-z",
                "--stdin",
                "--",
                "<file>\u2026\u200b"
            ]
        }
    },
    {
        "query": "I want to show the branches and their commits in a semi-visual graph format for my Git repository.",
        "model_answer": "git.show_branch()",
        "original": {
            "domain": "github",
            "framework": "git",
            "functionality": "Show branches and their commits",
            "api_name": "git.show_branch",
            "api_call": "git show-branch",
            "api_arguments": [
                {
                    "name": "_a_|_all"
                },
                {
                    "name": "_r_|_remotes"
                },
                {
                    "name": "topo_order_|_date_order"
                },
                {
                    "name": "current"
                },
                {
                    "name": "color["
                },
                {
                    "name": "sparse"
                },
                {
                    "name": "more"
                },
                {
                    "name": "no_name_|_sha1_name"
                },
                {
                    "name": "topics"
                },
                {
                    "name": "rev_|_glob\u2026\u200b"
                },
                {
                    "name": "_g_|_reflog["
                }
            ],
            "python_environment_requirements": [
                "git"
            ],
            "example_code": [
                {
                    "description": "Show three branches, 'master', 'fixes' and 'mhf'",
                    "code": "git show-branch master fixes mhf"
                },
                {
                    "description": "Show 10 reflog entries going back from the tip as of 1 hour ago",
                    "code": "git show-branch --reflog=\"10,1 hour ago\" --list master"
                }
            ],
            "description": "The 'git-show-branch' is a Git command that shows the commit ancestry graph starting from the commits named with <rev>s or <glob>s (or all refs under refs/heads and/or refs/tags) semi-visually. It cannot show more than 29 branches and commits at a time. It uses showbranch.default multi-valued configuration items if no <rev> or <glob> is given on the command line.",
            "api_name_original": "git-show-branch",
            "api_arguments_original": [
                "-a | --all",
                "-r | --remotes",
                "--topo-order | --date-order",
                "--current",
                "--color[=<when>] | --no-color",
                "--sparse",
                "--more=<n> | --list | --independent | --merge-base",
                "--no-name | --sha1-name",
                "--topics",
                "(<rev> | <glob>)\u2026\u200b",
                "(-g | --reflog)[=<n>[,<base>]] [--list] [<ref>]"
            ]
        }
    },
    {
        "query": "I want to find the common ancestor between commit GHI789 and commit JKL012 in my Git repository.",
        "model_answer": "git.merge_base(\"GHI789\", \"JKL012\")",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Find common ancestors for a merge",
            "api_name": "git.merge_base",
            "api_call": "git merge-base [-a | --all] <commit> <commit>\u2026\u200b",
            "api_arguments": [
                {
                    "name": "_a"
                },
                {
                    "name": "all"
                },
                {
                    "name": "commit"
                }
            ],
            "python_environment_requirements": "None",
            "example_code": [
                {
                    "description": "Check if A is an ancestor of B",
                    "code": "if git merge-base --is-ancestor A B\nthen\n\t... A is an ancestor of B ...\nfi"
                }
            ],
            "description": "The git merge-base API is used to find the best common ancestor(s) between two commits to use in a three-way merge. A common ancestor is better than another common ancestor if the latter is an ancestor of the former. A common ancestor that does not have any better common ancestor is a best common ancestor, i.e., a merge base. Note that there can be more than one merge base for a pair of commits. The API supports various options including --octopus, --independent, --is-ancestor, and --fork-point, each serving a specific purpose.",
            "api_name_original": "git-merge-base",
            "api_arguments_original": [
                "-a",
                "--all",
                "<commit>"
            ]
        }
    },
    {
        "query": "I want to find redundant pack files in my Git repository.",
        "model_answer": "git.pack_redundant()",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Find redundant pack files",
            "api_name": "git.pack_redundant",
            "api_call": "git pack-redundant [--verbose] [--alt-odb] (--all | <pack-filename>)",
            "api_arguments": [
                {
                    "name": "all"
                },
                {
                    "name": "alt_odb"
                },
                {
                    "name": "verbose"
                },
                {
                    "name": "pack_filename"
                }
            ],
            "python_environment_requirements": "git",
            "example_code": [
                {
                    "description": "Command to remove packs which contain unreachable objects",
                    "code": "git fsck --full --unreachable | cut -d ' ' -f3 | git pack-redundant --all | xargs rm"
                }
            ],
            "description": "The git-pack-redundant API is used to compute which packs in your repository are redundant. The output is suitable for piping to xargs rm if you are in the root of the repository. It accepts a list of objects on standard input. Any objects given will be ignored when checking which packs are required. This API has been deprecated and is scheduled for removal in a future version of Git.",
            "api_name_original": "git-pack-redundant",
            "api_arguments_original": [
                "--all",
                "--alt-odb",
                "--verbose",
                "<pack-filename>"
            ]
        }
    },
    {
        "query": "I want to show logs with the difference each commit introduces for the git repository, specifically for the commits that changed any file in the doc or src subdirectories.",
        "model_answer": "git.whatchanged(option=\"-p HEAD.. -- doc/ src/\")",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Show logs with difference each commit introduces",
            "api_name": "git.whatchanged(option=\"_p v2.6.12.. include/scsi drivers/scsi\"",
            "api_call": "git whatchanged <option>\u2026\u200b",
            "api_arguments": [
                {
                    "name": "option"
                }
            ],
            "python_environment_requirements": [],
            "example_code": [
                {
                    "description": "Show as patches the commits since version v2.6.12 that changed any file in the include/scsi or drivers/scsi subdirectories",
                    "code": "git whatchanged -p v2.6.12.. include/scsi drivers/scsi"
                },
                {
                    "description": "Show the changes during the last two weeks to the file gitk. The \"--\" is necessary to avoid confusion with the branch named gitk",
                    "code": "git whatchanged --since=\"2 weeks ago\" -- gitk"
                }
            ],
            "description": "The git-whatchanged command shows commit logs and diff output each commit introduces. It is essentially the same as git-log but defaults to show the raw format diff output and to skip merges. The command is kept primarily for historical reasons.",
            "api_name_original": "git-whatchanged",
            "api_arguments_original": [
                "<option>"
            ]
        }
    },
    {
        "query": "I want to optimize my Git repository data using the Git Maintenance API.",
        "model_answer": "git.maintenance.run()",
        "original": {
            "domain": "https://git-scm.com/docs/git-maintenance",
            "framework": "python",
            "functionality": "Optimize Git repository data",
            "api_name": "git.maintenance.run",
            "api_call": "git maintenance run [<options>]",
            "api_arguments": [
                {
                    "name": "run"
                },
                {
                    "name": "start"
                },
                {
                    "name": "stop"
                },
                {
                    "name": "register"
                },
                {
                    "name": "unregister"
                },
                {
                    "name": "auto"
                },
                {
                    "name": "schedule"
                },
                {
                    "name": "quiet"
                },
                {
                    "name": "task"
                },
                {
                    "name": "scheduler"
                }
            ],
            "python_environment_requirements": [
                "GitPython"
            ],
            "example_code": [],
            "description": "The Git Maintenance API is designed to optimize Git repository data, speeding up other Git commands and reducing storage requirements for the repository. It provides flexibility for how to optimize the Git repository through various commands and options. The API is part of the git suite and can be accessed through the GitPython library in a Python environment.",
            "api_name_original": "Git Maintenance API",
            "api_arguments_original": [
                "run",
                "start",
                "stop",
                "register",
                "unregister",
                "--auto",
                "--schedule",
                "--quiet",
                "--task",
                "--scheduler"
            ]
        }
    },
    {
        "query": "I want to generate a credential description based on the context and fill it for Git user credentials management.",
        "model_answer": "git.credential.fill()",
        "original": {
            "domain": "git",
            "framework": "Git",
            "functionality": "Manage user credentials",
            "api_name": "git.credential.fill",
            "api_call": "'git credential' (fill|approve|reject)",
            "api_arguments": [
                {
                    "name": "fill"
                },
                {
                    "name": "approve"
                },
                {
                    "name": "reject"
                }
            ],
            "python_environment_requirements": [],
            "example_code": [
                {
                    "description": "Generate a credential description based on the context",
                    "code": "protocol=https\nhost=example.com\npath=foo.git"
                },
                {
                    "description": "Ask git-credential to give us a username and password for this description",
                    "code": "git credential fill"
                },
                {
                    "description": "Use the credential and see if it\u2019s accepted",
                    "code": "username=bob\npassword=secr3t"
                },
                {
                    "description": "Report on the success or failure of the password",
                    "code": "git credential approve"
                }
            ],
            "description": "Git-credential is a tool that comes with Git, and its role is to retrieve and store user credentials. It has an internal interface for storing and retrieving credentials from system-specific helpers, as well as prompting the user for usernames and passwords. The git-credential command exposes this interface to scripts which may want to retrieve, store, or prompt for credentials in the same manner as Git. The design of this scriptable interface models the internal C API.",
            "api_name_original": "git-credential",
            "api_arguments_original": [
                "fill",
                "approve",
                "reject"
            ]
        }
    },
    {
        "query": "I want to migrate a CVS repository to Git and import the CVS archive into a new Git repository.",
        "model_answer": "git.cvsimport('*')",
        "original": {
            "domain": "git",
            "framework": "Git",
            "functionality": "Migration from CVS to Git",
            "api_name": "git.cvsimport",
            "api_call": "git cvsimport *",
            "api_arguments": [
                {
                    "name": "*"
                }
            ],
            "python_environment_requirements": [
                "Git"
            ],
            "example_code": [
                {
                    "description": "Cloning a shared repository",
                    "code": "git clone foo.com:/pub/repo.git/ my-project"
                },
                {
                    "description": "Updating the shared repository with your changes",
                    "code": "git push origin master"
                },
                {
                    "description": "Creating a new 'bare' repository and fetching your project into it",
                    "code": "git --bare init --shared\ngit --bare fetch /home/alice/myproject master:master"
                },
                {
                    "description": "Importing a CVS archive",
                    "code": "git cvsimport -C <destination> <module>"
                }
            ],
            "description": "The gitcvs-migration API provides a way for CVS users to migrate to Git. It allows users to create a shared repository, clone it, commit changes, and push them to the shared repository. Moreover, it provides a way to import a CVS archive into a Git repository. The API is part of the Git suite and requires the Git framework to be installed in the Python environment.",
            "api_name_original": "gitcvs-migration",
            "api_arguments_original": [
                "*"
            ]
        }
    },
    {
        "query": "I want to export git data using the git-fast-export command with the options --progress=50 and --full-tree.",
        "model_answer": "git.fast_export(progress=50, full_tree=True)",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Export git data",
            "api_name": "git.fast_export",
            "api_call": "git fast-export [<options>]",
            "api_arguments": [
                {
                    "name": "progress"
                },
                {
                    "name": "signed_tags"
                },
                {
                    "name": "tag_of_filtered_object"
                },
                {
                    "name": "_m"
                },
                {
                    "name": "_c"
                },
                {
                    "name": "export_marks"
                },
                {
                    "name": "import_marks"
                },
                {
                    "name": "mark_tags"
                },
                {
                    "name": "fake_missing_tagger"
                },
                {
                    "name": "use_done_feature"
                },
                {
                    "name": "no_data"
                },
                {
                    "name": "full_tree"
                },
                {
                    "name": "anonymize"
                },
                {
                    "name": "anonymize_map"
                },
                {
                    "name": "reference_excluded_parents"
                },
                {
                    "name": "show_original_ids"
                },
                {
                    "name": "reencode"
                },
                {
                    "name": "refspec"
                },
                {
                    "name": "[git_rev_list_args\u2026\u200b]"
                }
            ],
            "python_environment_requirements": [
                "git"
            ],
            "example_code": [
                {
                    "description": "Export the whole repository and import it into the existing empty repository",
                    "code": "git fast-export --all | (cd /empty/repository && git fast-import)"
                },
                {
                    "description": "Make a new branch called other from master~5..master",
                    "code": "git fast-export master~5..master | sed \"s|refs/heads/master|refs/heads/other|\" | git fast-import"
                }
            ],
            "description": "The git-fast-export command is used to export git data in a form suitable to be piped into git fast-import. It is useful as a human-readable bundle replacement or as a format that can be edited before being fed to git fast-import in order to do history rewrites.",
            "api_name_original": "git-fast-export",
            "api_arguments_original": [
                "--progress=<n>",
                "--signed-tags=(verbatim|warn|warn-strip|strip|abort)",
                "--tag-of-filtered-object=(abort|drop|rewrite)",
                "-M",
                "-C",
                "--export-marks=<file>",
                "--import-marks=<file>",
                "--mark-tags",
                "--fake-missing-tagger",
                "--use-done-feature",
                "--no-data",
                "--full-tree",
                "--anonymize",
                "--anonymize-map=<from>[:<to>]",
                "--reference-excluded-parents",
                "--show-original-ids",
                "--reencode=(yes|no|abort)",
                "--refspec",
                "[<git-rev-list-args>\u2026\u200b]"
            ]
        }
    },
    {
        "query": "I want to download from a remote Git repository via HTTP and save it to a local file named \"downloaded.git\". The remote repository URL is \"https://github.com/example/repo.git\".",
        "model_answer": "git.http_fetch(\"-w\", \"downloaded.git\", \"https://github.com/example/repo.git\")",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Download from a remote Git repository via HTTP",
            "api_name": "git.http_fetch(\"_w\", \"downloaded.git\", \"https://github.com/example/repo.git\"",
            "api_call": "git http-fetch [-c] [-t] [-a] [-d] [-v] [-w <filename>] [--recover] [--stdin | --packfile=<hash> | <commit>] <URL>",
            "api_arguments": [
                {
                    "name": "commit_id",
                    "description": "Either the hash or the filename under [URL]/refs/ to pull."
                },
                {
                    "name": "_a,__c,__t",
                    "description": "These options are ignored for historical reasons."
                },
                {
                    "name": "_v",
                    "description": "Report what is downloaded."
                },
                {
                    "name": "_w_filename",
                    "description": "Writes the commit-id into the filename under $GIT_DIR/refs/<filename> on the local end after the transfer is complete."
                },
                {
                    "name": "stdin",
                    "description": "Instead of a commit id on the command line (which is not expected in this case), git http-fetch expects lines on stdin in the format <commit-id>['\t'<filename-as-in--w>]"
                },
                {
                    "name": "packfile",
                    "description": "For internal use only. Instead of a commit id on the command line (which is not expected in this case), git http-fetch fetches the packfile directly at the given URL and uses index-pack to generate corresponding .idx and .keep files."
                },
                {
                    "name": "index_pack_args",
                    "description": "For internal use only. The command to run on the contents of the downloaded pack. Arguments are URL-encoded separated by spaces."
                },
                {
                    "name": "recover",
                    "description": "Verify that everything reachable from target is fetched. Used after an earlier fetch is interrupted."
                }
            ],
            "python_environment_requirements": "git",
            "example_code": [],
            "description": "The git-http-fetch command is used to download from a remote Git repository via HTTP. This command always gets all objects. The options to choose which objects to download are now silently ignored. The command can report what is downloaded, write the commit-id into a filename on the local end after the transfer is complete, fetch a packfile directly at a given URL, run a command on the contents of the downloaded pack, and verify that everything reachable from target is fetched.",
            "api_name_original": "git-http-fetch",
            "api_arguments_original": {
                "commit-id": "Either the hash or the filename under [URL]/refs/ to pull.",
                "-a, -c, -t": "These options are ignored for historical reasons.",
                "-v": "Report what is downloaded.",
                "-w <filename>": "Writes the commit-id into the filename under $GIT_DIR/refs/<filename> on the local end after the transfer is complete.",
                "--stdin": "Instead of a commit id on the command line (which is not expected in this case), git http-fetch expects lines on stdin in the format <commit-id>['\t'<filename-as-in--w>]",
                "--packfile=<hash>": "For internal use only. Instead of a commit id on the command line (which is not expected in this case), git http-fetch fetches the packfile directly at the given URL and uses index-pack to generate corresponding .idx and .keep files.",
                "--index-pack-args=<args>": "For internal use only. The command to run on the contents of the downloaded pack. Arguments are URL-encoded separated by spaces.",
                "--recover": "Verify that everything reachable from target is fetched. Used after an earlier fetch is interrupted."
            }
        }
    },
    {
        "query": "I want to restore the file named goodbye.py in the working tree of my git repository.",
        "model_answer": "git.restore(pathspec=\"goodbye.py\")",
        "original": {
            "domain": "github",
            "framework": "git",
            "functionality": "Restore working tree files",
            "api_name": "git.restore(pathspec=\"hello.c\"",
            "api_call": "git restore [<options>] [--source=<tree>] [--staged] [--worktree] [--] <pathspec>\u2026\u200b",
            "api_arguments": [
                {
                    "name": "options"
                },
                {
                    "name": "source"
                },
                {
                    "name": "staged"
                },
                {
                    "name": "worktree"
                },
                {
                    "name": "pathspec"
                }
            ],
            "python_environment_requirements": "git",
            "example_code": [
                {
                    "description": "The following sequence switches to the master branch, reverts the Makefile to two revisions back, deletes hello.c by mistake, and gets it back from the index.",
                    "code": "$ git switch master\n$ git restore --source master~2 Makefile (1)\n$ rm -f hello.c\n$ git restore hello.c (2)"
                },
                {
                    "description": "If you want to restore all C source files to match the version in the index, you can say",
                    "code": "$ git restore '*.c'"
                },
                {
                    "description": "To restore all files in the current directory",
                    "code": "$ git restore ."
                }
            ],
            "description": "The git-restore API is used to restore specified paths in the working tree with some contents from a restore source. If a path is tracked but does not exist in the restore source, it will be removed to match the source. The command can also be used to restore the content in the index with --staged, or restore both the working tree and the index with --staged --worktree. By default, if --staged is given, the contents are restored from HEAD, otherwise from the index. Use --source to restore from a different commit.",
            "api_name_original": "git-restore",
            "api_arguments_original": [
                "options",
                "source",
                "staged",
                "worktree",
                "pathspec"
            ]
        }
    },
    {
        "query": "Perform a merge without touching index or working tree between branch1 and branch2 in Git.",
        "model_answer": "git.merge_tree(\"branch1\", \"branch2\")",
        "original": {
            "domain": "git",
            "framework": "Git",
            "functionality": "Perform merge without touching index or working tree",
            "api_name": "git.merge_tree",
            "api_call": "git merge-tree [--write-tree] [<options>] <branch1> <branch2>",
            "api_arguments": [
                {
                    "name": "write_tree"
                },
                {
                    "name": "options"
                },
                {
                    "name": "branch1"
                },
                {
                    "name": "branch2"
                }
            ],
            "python_environment_requirements": [
                "Git"
            ],
            "example_code": [
                {
                    "description": "Perform a merge without touching index or working tree",
                    "code": "NEWTREE=$(git merge-tree --write-tree $BRANCH1 $BRANCH2)\ntest $? -eq 0 || die \"There were conflicts...\"\nNEWCOMMIT=$(git commit-tree $NEWTREE -p $BRANCH1 -p $BRANCH2)\ngit update-ref $BRANCH1 $NEWCOMMIT"
                }
            ],
            "description": "The git-merge-tree command is a part of the Git suite. It is designed to perform a merge operation without affecting the index or the working tree. It uses the same features as the 'real' git-merge, including three-way content merges of individual files, rename detection, proper directory/file conflict handling, and recursive ancestor consolidation. The command creates a new top-level tree object after the merge operation is complete. It has a modern --write-tree mode and a deprecated --trivial-merge mode. The command provides various options for handling different scenarios and generating specific output.",
            "api_name_original": "git-merge-tree",
            "api_arguments_original": [
                "--write-tree",
                "<options>",
                "<branch1>",
                "<branch2>"
            ]
        }
    },
    {
        "query": "I want to set the global git attribute file to \"~/.gitattributes\".",
        "model_answer": "git.config('--global', 'core.attributesfile', '~/.gitattributes')",
        "original": {
            "domain": "git",
            "framework": "Git",
            "functionality": "Performing text diffs of binary files, Marking files as binary, Performing a three-way merge, Checking whitespace errors, Creating an archive, Packing objects, Viewing files in GUI tools",
            "api_name": "git.config('__global', 'core.attributesfile', '~/.gitattributes'",
            "api_call": "git config --global core.attributesfile ~/.gitattributes",
            "api_arguments": [
                {
                    "name": "global"
                },
                {
                    "name": "core.attributesfile"
                },
                {
                    "name": "~/.gitattributes"
                }
            ],
            "python_environment_requirements": [
                "GitPython"
            ],
            "example_code": [
                {
                    "description": "Example of setting advanced gitattributes",
                    "code": "from git import Repo\n\nrepo = Repo()\ngit = repo.git\ngit.config('--global', 'core.attributesfile', '~/.gitattributes')"
                }
            ],
            "description": "The advanced gitattributes API allows you to perform more sophisticated operations like performing text diffs of binary files, marking files as binary, performing a three-way merge, checking whitespace errors, creating an archive, packing objects, and viewing files in GUI tools. You can also define custom merge drivers, specify the character encoding for GUI tools, and use macro attributes for convenience. The attributes are set in a .gitattributes file where each line is of the form: pattern attr1 attr2 ...",
            "api_name_original": "gitattributes_advanced",
            "api_arguments_original": [
                "--global",
                "core.attributesfile",
                "~/.gitattributes"
            ]
        }
    },
    {
        "query": "I want to add all files in the current directory to the staging area and commit the changes using Git.",
        "model_answer": "git.add_all_files()\ngit.commit()",
        "original": {
            "domain": "github",
            "framework": "git",
            "functionality": "git tutorial",
            "api_name": "git.init",
            "api_call": "git <command>",
            "api_arguments": [
                {
                    "name": "command"
                }
            ],
            "python_environment_requirements": [
                "git"
            ],
            "example_code": [
                {
                    "description": "Initialize a new Git repository",
                    "code": "git init"
                },
                {
                    "description": "Add files to the staging area",
                    "code": "git add ."
                },
                {
                    "description": "Commit changes",
                    "code": "git commit"
                },
                {
                    "description": "View project history",
                    "code": "git log"
                },
                {
                    "description": "Create a new branch",
                    "code": "git branch experimental"
                },
                {
                    "description": "Switch to a branch",
                    "code": "git switch experimental"
                },
                {
                    "description": "Merge branches",
                    "code": "git merge experimental"
                }
            ],
            "description": "The gittutorial API is a tutorial introduction to Git. It explains how to import a new project into Git, make changes to it, and share changes with other developers. It provides commands for initializing a new Git repository, adding files to the staging area, committing changes, viewing project history, creating a new branch, switching to a branch, and merging branches.",
            "api_name_original": "gittutorial",
            "api_arguments_original": [
                "command"
            ]
        }
    },
    {
        "query": "I want to limit the displayed commits in a git repository to only the ancestors of a specific commit with the commit ID \"abc123\".",
        "model_answer": "git.log(ancestry_path=\"abc123\")",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Limit displayed commits to ancestors or descendants of a commit",
            "api_name": "git.log",
            "api_call": "git log --ancestry-path=<commit>",
            "api_arguments": [
                {
                    "name": "ancestry_path["
                }
            ],
            "python_environment_requirements": "Python 3.5 or higher",
            "example_code": [
                {
                    "description": "Limit displayed commits to ancestors of a commit",
                    "code": "git log --ancestry-path=<commit>"
                }
            ],
            "description": "The git-ancestry-path command is used to limit the displayed commits to those which are an ancestor of a commit, or which are a descendant of a commit, or are the commit itself. This can be useful for analyzing commit history, finding out what commits in a range are contaminated with a bug and need fixing, or viewing only the subset of commits which contain a certain topic in their ancestry path.",
            "api_name_original": "git-ancestry-path",
            "api_arguments_original": [
                "--ancestry-path[=<commit>]"
            ]
        }
    },
    {
        "query": "I want to fetch the latest changes from the default branch of a remote repository and update my current branch in my local repository.",
        "model_answer": "git.pull()",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Fetch from and update the current branch in a local repository with the latest changes from the default branch (or any other branch) of a remote repository",
            "api_name": "git.pull",
            "api_call": "git pull [<repository> [<refspec>\u2026\u200b]]",
            "api_arguments": [
                {
                    "name": "repository"
                },
                {
                    "name": "refspec"
                }
            ],
            "python_environment_requirements": [
                "gitpython"
            ],
            "example_code": [
                {
                    "description": "Update the remote-tracking branches for the repository you cloned from, then merge one of them into your current branch",
                    "code": "$ git pull\n$ git pull origin"
                },
                {
                    "description": "Merge into the current branch the remote branch next",
                    "code": "$ git pull origin next"
                },
                {
                    "description": "The same can be done by invoking fetch and merge",
                    "code": "$ git fetch origin\n$ git merge origin/next"
                }
            ],
            "description": "The git-pull API is used to fetch from and integrate with another repository or a local branch. It incorporates changes from a remote repository into the current branch. It can handle complex merges and conflicts, and supports different merge strategies. This advanced version of the git-pull API also supports fetching and merging from multiple remote repositories, and provides more options for handling merge conflicts and choosing merge strategies. It can also handle scenarios where the remote branch is regularly rewound and rebased.",
            "api_name_original": "git-pull-advanced",
            "api_arguments_original": [
                "repository",
                "refspec"
            ]
        }
    },
    {
        "query": "I want to push the changes to the remote repository named \"origin\" and update the \"master\" branch on Git.",
        "model_answer": "git.push(repository=\"origin\", refspec=\"master\")",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Push updates to remote repository with advanced configurations",
            "api_name": "git.push",
            "api_call": "git push [options] <repository> [<refspec>...]",
            "api_arguments": [
                {
                    "name": "options"
                },
                {
                    "name": "repository"
                },
                {
                    "name": "refspec"
                }
            ],
            "python_environment_requirements": [
                "gitpython"
            ],
            "example_code": [
                {
                    "description": "Push changes to the remote repository",
                    "code": "git push origin master"
                },
                {
                    "description": "Push the current branch to the remote ref matching master in the origin repository",
                    "code": "git push origin HEAD:master"
                },
                {
                    "description": "Create the branch experimental in the origin repository by copying the current master branch",
                    "code": "git push origin master:refs/heads/experimental"
                },
                {
                    "description": "Find a ref that matches experimental in the origin repository and delete it",
                    "code": "git push origin :experimental"
                },
                {
                    "description": "Update the origin repository\u2019s master branch with the dev branch, allowing non-fast-forward updates",
                    "code": "git push origin +dev:master"
                }
            ],
            "description": "The git-push-advanced API provides more advanced configurations for pushing updates to the remote repository. It includes options for defining push and fetch refspecs, using different URLs for fetch and push operations, and specifying branch mappings. It also provides detailed information about the output of the 'git push' command, including the status of each ref and the reasons for any failures. This API is particularly useful for complex workflows and when working with large repositories.",
            "api_name_original": "git-push-advanced",
            "api_arguments_original": [
                "options",
                "repository",
                "refspec"
            ]
        }
    },
    {
        "query": "I want to commit changes to a Git repository with the message \"Updating README file\".",
        "model_answer": "repo.git.commit('-m', 'Updating README file')",
        "original": {
            "domain": "git",
            "framework": "Git",
            "functionality": "Version control and developer interfaces",
            "api_name": "repo.git.commit",
            "api_call": "git commit -m 'commit_message'",
            "api_arguments": [
                {
                    "name": "_m_'commit_message'"
                }
            ],
            "python_environment_requirements": [
                "gitpython"
            ],
            "example_code": [
                {
                    "description": "Commit changes",
                    "code": "from git import Repo\n\nrepo = Repo('path_to_repo')\nrepo.git.commit('-m', 'commit_message')"
                }
            ],
            "description": "The Git Core API provides functionalities for version control and for handling developer interfaces. It allows users to track changes in their code over time and collaborate with other developers. The API is capable of storing multiple entries for a given pathname. These stages are used to hold the various unmerged version of a file when a merge is in progress. The API also provides functionalities for handling file formats, protocols, and other developer interfaces. The API is widely used in many development environments.",
            "api_name_original": "Git Core API",
            "api_arguments_original": [
                "-m 'commit_message'"
            ]
        }
    },
    {
        "query": "I want to compare two files using the advanced options provided by the git-diff-files-advanced API in the GitHub framework.",
        "model_answer": "git.diff_files_advanced()",
        "original": {
            "domain": "github",
            "framework": "git",
            "functionality": "File comparison with advanced options",
            "api_name": "git.diff_files_advanced",
            "api_call": "git diff-files [--relative[=<path>]] [--ignore-cr-at-eol] [--ignore-space-at-eol] [--ignore-space-change] [--ignore-all-space] [--ignore-blank-lines] [--ignore-matching-lines=<regex>] [--ignore-submodules[=<when>]] [--src-prefix=<prefix>] [--dst-prefix=<prefix>] [--no-prefix] [--default-prefix] [--line-prefix=<prefix>]] [<path>\u2026\u200b]",
            "api_arguments": [
                {
                    "name": "relative["
                },
                {
                    "name": "ignore_cr_at_eol"
                },
                {
                    "name": "ignore_space_at_eol"
                },
                {
                    "name": "ignore_space_change"
                },
                {
                    "name": "ignore_all_space"
                },
                {
                    "name": "ignore_blank_lines"
                },
                {
                    "name": "ignore_matching_lines"
                },
                {
                    "name": "ignore_submodules["
                },
                {
                    "name": "src_prefix"
                },
                {
                    "name": "dst_prefix"
                },
                {
                    "name": "no_prefix"
                },
                {
                    "name": "default_prefix"
                },
                {
                    "name": "line_prefix"
                },
                {
                    "name": "path"
                }
            ],
            "python_environment_requirements": [
                "gitpython"
            ],
            "example_code": [],
            "description": "The git-diff-files-advanced API is an extension of the git-diff-files API, providing additional options for comparing files in the working tree and the index. These options include ignoring certain types of changes, such as whitespace changes, changes in blank lines, or changes matching a specific regular expression. It also provides options for handling submodules, specifying prefixes for source and destination files, and more. This API is part of the Git framework, and can be used in a Python environment with the gitpython library.",
            "api_name_original": "git-diff-files-advanced",
            "api_arguments_original": [
                "--relative[=<path>]",
                "--ignore-cr-at-eol",
                "--ignore-space-at-eol",
                "--ignore-space-change",
                "--ignore-all-space",
                "--ignore-blank-lines",
                "--ignore-matching-lines=<regex>",
                "--ignore-submodules[=<when>]",
                "--src-prefix=<prefix>",
                "--dst-prefix=<prefix>",
                "--no-prefix",
                "--default-prefix",
                "--line-prefix=<prefix>",
                "<path>"
            ]
        }
    },
    {
        "query": "I want to clone a Subversion repository with the URL \"https://svn.example.com/repo/trunk\" using git-svn.",
        "model_answer": "git.svn.clone(url=\"https://svn.example.com/repo/trunk\")",
        "original": {
            "domain": "git",
            "framework": "git-svn",
            "functionality": "Provides additional commands for interaction with Subversion repositories",
            "api_name": "git.svn.clone(url=\"http://svn.example.com/project/trunk\"",
            "api_call": "git svn <command> [<options>] [<arguments>]",
            "api_arguments": [
                {
                    "name": "command"
                },
                {
                    "name": "options"
                },
                {
                    "name": "arguments"
                }
            ],
            "python_environment_requirements": "Python not required",
            "example_code": [
                {
                    "description": "Clone a repo (like git clone)",
                    "code": "git svn clone http://svn.example.com/project/trunk"
                },
                {
                    "description": "Enter the newly cloned directory",
                    "code": "cd trunk"
                },
                {
                    "description": "You should be on master branch, double-check with 'git branch'",
                    "code": "git branch"
                },
                {
                    "description": "Do some work and commit locally to Git",
                    "code": "git commit ..."
                },
                {
                    "description": "Something is committed to SVN, rebase your local changes against the latest changes in SVN",
                    "code": "git svn rebase"
                },
                {
                    "description": "Now commit your changes (that were committed previously using Git) to SVN, as well as automatically updating your working HEAD",
                    "code": "git svn dcommit"
                },
                {
                    "description": "Append svn:ignore settings to the default Git exclude file",
                    "code": "git svn show-ignore >> .git/info/exclude"
                }
            ],
            "description": "The additional commands of git-svn provide more advanced options for interaction with Subversion repositories. They allow for specific handling of authors, verbosity, merges, dry runs, author strings, advanced options like setting the GIT_SVN_ID, specifying the svn-remote, following parent branches, and handling of SVN branches. They also provide configuration options for handling metadata, SVM properties, Svnsync properties, URL rewriting, push URLs, workaround for broken symlinks, pathname encoding, and automatic directory creation. These commands also come with caveats and bugs that users should be aware of.",
            "api_name_original": "git-svn additional commands",
            "api_arguments_original": [
                "<command>",
                "<options>",
                "<arguments>"
            ]
        }
    },
    {
        "query": "I want to fetch and prune branches and tags from my Git repository.",
        "model_answer": "git.fetch(prune=True)",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Fetch and prune branches and/or tags from one or more other repositories",
            "api_name": "git.fetch",
            "api_call": "git fetch --prune [<options>] [<repository> [<refspec>\u2026\u200b]]",
            "api_arguments": [
                {
                    "name": "options"
                },
                {
                    "name": "repository"
                },
                {
                    "name": "refspec"
                }
            ],
            "python_environment_requirements": "gitpython",
            "example_code": [
                {
                    "description": "Update the remote-tracking branches",
                    "code": "$ git fetch origin"
                },
                {
                    "description": "Using refspecs explicitly",
                    "code": "$ git fetch origin +seen:seen maint:tmp"
                },
                {
                    "description": "Peek at a remote\u2019s branch, without configuring the remote in your local repository",
                    "code": "$ git fetch git://git.kernel.org/pub/scm/git/git.git maint\n$ git log FETCH_HEAD"
                }
            ],
            "description": "The git-fetch-prune API is used to fetch and prune branches and/or tags from one or more other repositories, along with the objects necessary to complete their histories. This API can fetch from either a single named repository or URL, or from several repositories at once if a group is given and there is a remotes.<group> entry in the configuration file. When no remote is specified, by default the origin remote will be used, unless there\u2019s an upstream branch configured for the current branch. The API also provides functionality for pruning stale references, managing remote-tracking branches, and configuring fetch options.",
            "api_name_original": "git-fetch-prune",
            "api_arguments_original": [
                "options",
                "repository",
                "refspec"
            ]
        }
    },
    {
        "query": "I want to optimize the import performance in my Git repository by handling crash reports.",
        "model_answer": "git.fast_import_optimization()",
        "original": {
            "domain": "git",
            "framework": "Git",
            "functionality": "Handling crash reports and optimizing import performance",
            "api_name": "git.fast_import_optimization",
            "api_call": "git fast-import [<options>]",
            "api_arguments": [
                {
                    "name": "from"
                },
                {
                    "name": "merge"
                },
                {
                    "name": "filemodify"
                },
                {
                    "name": "filedelete"
                },
                {
                    "name": "filecopy"
                },
                {
                    "name": "filerename"
                },
                {
                    "name": "filedeleteall"
                },
                {
                    "name": "notemodify"
                },
                {
                    "name": "mark"
                },
                {
                    "name": "original_oid"
                },
                {
                    "name": "tag"
                },
                {
                    "name": "reset"
                },
                {
                    "name": "blob"
                },
                {
                    "name": "data"
                },
                {
                    "name": "alias"
                },
                {
                    "name": "checkpoint"
                },
                {
                    "name": "progress"
                },
                {
                    "name": "get_mark"
                },
                {
                    "name": "cat_blob"
                },
                {
                    "name": "ls"
                },
                {
                    "name": "feature"
                },
                {
                    "name": "option"
                },
                {
                    "name": "done"
                }
            ],
            "python_environment_requirements": [
                "git"
            ],
            "example_code": [
                {
                    "description": "Example of a crash report",
                    "code": "cat .git/fast_import_crash_8434"
                }
            ],
            "description": "This enhanced API is used for handling crash reports, optimizing import performance, handling file or directory renames, and managing tags. It provides a variety of commands for different tasks. It also supports features like checkpoints and progress tracking, and can handle data in different formats. It is designed to be efficient and flexible, allowing for a wide range of operations with a minimum amount of memory usage and processing time. The API also provides tips and tricks for repository conversion, skipping around branches, handling renames, using tag fixup branches, and repacking the repository after import.",
            "api_name_original": "git-fast-import_optimization",
            "api_arguments_original": [
                "from",
                "merge",
                "filemodify",
                "filedelete",
                "filecopy",
                "filerename",
                "filedeleteall",
                "notemodify",
                "mark",
                "original-oid",
                "tag",
                "reset",
                "blob",
                "data",
                "alias",
                "checkpoint",
                "progress",
                "get-mark",
                "cat-blob",
                "ls",
                "feature",
                "option",
                "done"
            ]
        }
    },
    {
        "query": "I want to check the version of Git installed on my system.",
        "model_answer": "git.version_info",
        "original": {
            "domain": "git",
            "framework": "Git",
            "functionality": "Version Control",
            "api_name": "git.version_inf",
            "api_call": "git <command> [<args>]",
            "api_arguments": [
                {
                    "name": "command"
                },
                {
                    "name": "args"
                }
            ],
            "python_environment_requirements": [
                "gitpython"
            ],
            "example_code": [
                {
                    "description": "Checking your version of git",
                    "code": "git --version"
                }
            ],
            "description": "This update provides more detail on the Git project structure and its components. A Git project normally consists of a working directory with a '.git' subdirectory at the top level. The .git directory contains a compressed object database representing the project's complete history, an 'index' file which links that history to the current contents of the working tree, and named pointers into that history such as tags and branch heads. The object database contains blobs, trees, and commits, which hold file data, build up directory hierarchies, and represent steps in the project\u2019s history, respectively. All objects are named by the SHA-1 hash of their contents, which are globally unique. The index file is initialized with a list of all paths and, for each path, a blob object and a set of attributes. The index may be updated with new content, and new commits may be created from the content stored in the index. The index is also capable of storing multiple entries (called 'stages') for a given pathname. These stages are used to hold the various unmerged version of a file when a merge is in progress.",
            "api_name_original": "Git API",
            "api_arguments_original": [
                "command",
                "args"
            ]
        }
    },
    {
        "query": "I want to use the advanced merge strategy in Git to merge branches while ignoring all whitespace changes and enabling rename detection.",
        "model_answer": "git.merge(ignore_space_change=True, rename_threshold=50)",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Advanced merge strategies and configuration",
            "api_name": "git.merge",
            "api_call": "git merge [--ignore-space-change] [--ignore-all-space] [--ignore-space-at-eol] [--ignore-cr-at-eol] [--renormalize] [--no-renormalize] [--find-renames[=<n>]] [--rename-threshold=<n>] [--subtree[=<path>]] [--recursive] [--patience] [--diff-algorithm=[patience|minimal|histogram|myers]] [--no-renames] [--resolve] [--octopus] [--ours] [--subtree]",
            "api_arguments": [
                {
                    "name": "ignore_space_change"
                },
                {
                    "name": "ignore_all_space"
                },
                {
                    "name": "ignore_space_at_eol"
                },
                {
                    "name": "ignore_cr_at_eol"
                },
                {
                    "name": "renormalize"
                },
                {
                    "name": "no_renormalize"
                },
                {
                    "name": "find_renames["
                },
                {
                    "name": "rename_threshold"
                },
                {
                    "name": "subtree["
                },
                {
                    "name": "recursive"
                },
                {
                    "name": "patience"
                },
                {
                    "name": "diff_algorithm"
                },
                {
                    "name": "no_renames"
                },
                {
                    "name": "resolve"
                },
                {
                    "name": "octopus"
                },
                {
                    "name": "ours"
                },
                {
                    "name": "subtree"
                }
            ],
            "python_environment_requirements": [
                "gitpython"
            ],
            "example_code": [],
            "description": "The 'git-merge-advanced' API provides more complex strategies for merging branches in Git. These include options for ignoring certain types of whitespace changes, enabling or disabling rename detection, and specifying a custom diff algorithm. The API also includes several configuration options that can be set to control the behavior of merges. These can be used to adjust the default merge strategy, specify the number of file renames to consider during a merge, and control the output of the merge process.",
            "api_name_original": "git-merge-advanced",
            "api_arguments_original": [
                "--ignore-space-change",
                "--ignore-all-space",
                "--ignore-space-at-eol",
                "--ignore-cr-at-eol",
                "--renormalize",
                "--no-renormalize",
                "--find-renames[=<n>]",
                "--rename-threshold=<n>",
                "--subtree[=<path>]",
                "--recursive",
                "--patience",
                "--diff-algorithm=[patience|minimal|histogram|myers]",
                "--no-renames",
                "--resolve",
                "--octopus",
                "--ours",
                "--subtree"
            ]
        }
    },
    {
        "query": "I want to parse and normalize options for Git commands using the git-rev-parse API.",
        "model_answer": "git.rev_parse()",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Parse and normalize options, Revision Range Summary, SQ-QUOTE",
            "api_name": "git.rev_parse",
            "api_call": "git rev-parse [<options>] <args>",
            "api_arguments": [
                {
                    "name": "options"
                },
                {
                    "name": "args"
                }
            ],
            "python_environment_requirements": [
                "GitPython"
            ],
            "example_code": [
                {
                    "description": "Parse the date string, and output the corresponding --max-age= parameter for git rev-list.",
                    "code": "git rev-parse --since=datestring"
                },
                {
                    "description": "Parse the date string, and output the corresponding --min-age= parameter for git rev-list.",
                    "code": "git rev-parse --until=datestring"
                },
                {
                    "description": "Print the object name of the current commit",
                    "code": "git rev-parse --verify HEAD"
                },
                {
                    "description": "Print the commit object name from the revision in the $REV shell variable",
                    "code": "git rev-parse --verify --end-of-options $REV^{commit}"
                },
                {
                    "description": "Similar to above, but if $REV is empty, the commit object name from master will be printed",
                    "code": "git rev-parse --default master --verify --end-of-options $REV"
                }
            ],
            "description": "The git-rev-parse API is used to parse and normalize options for Git commands. It can be used to distinguish between flags and parameters meant for the underlying git rev-list command and flags and parameters for other commands. The API supports a variety of options for operation modes, filtering, output, objects, files, and others. It also provides several ways to specify revisions and ranges. In --sq-quote mode, git rev-parse echoes on the standard output a single line suitable for sh(1) eval. This line is made by normalizing the arguments following --sq-quote. Nothing other than quoting the arguments is done.",
            "api_name_original": "git-rev-parse",
            "api_arguments_original": [
                "<options>",
                "<args>"
            ]
        }
    },
    {
        "query": "I want to generate a patch series for email submission using the git-format-patch command. I would like to add a cover letter, include custom headers, and change the subject prefix. Please generate the patch series for the commits since the last revision.",
        "model_answer": "aws.git.format_patch(thread=\"advanced\", cover_letter=True, add_header=\"X-MyHeader: Value\", subject_prefix=\"[PATCH]\", base=\"HEAD~10\")",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Prepare patches for email submission with additional features",
            "api_name": "aws.git.format_patch",
            "api_call": "git format-patch [options] [<since> | <revision range>]",
            "api_arguments": [
                {
                    "name": "thread["
                },
                {
                    "name": "in_reply_to"
                },
                {
                    "name": "ignore_if_in_upstream"
                },
                {
                    "name": "always"
                },
                {
                    "name": "cover_from_description"
                },
                {
                    "name": "subject_prefix"
                },
                {
                    "name": "filename_max_length"
                },
                {
                    "name": "rfc"
                },
                {
                    "name": "reroll_count"
                },
                {
                    "name": "to"
                },
                {
                    "name": "cc"
                },
                {
                    "name": "from"
                },
                {
                    "name": "force_in_body_from"
                },
                {
                    "name": "add_header"
                },
                {
                    "name": "cover_letter"
                },
                {
                    "name": "encode_email_headers"
                },
                {
                    "name": "interdiff"
                },
                {
                    "name": "range_diff"
                },
                {
                    "name": "creation_factor"
                },
                {
                    "name": "notes["
                },
                {
                    "name": "signature"
                },
                {
                    "name": "signature_file"
                },
                {
                    "name": "suffix"
                },
                {
                    "name": "quiet"
                },
                {
                    "name": "no_binary"
                },
                {
                    "name": "zero_commit"
                },
                {
                    "name": "base["
                },
                {
                    "name": "root"
                },
                {
                    "name": "progress"
                }
            ],
            "python_environment_requirements": [
                "gitpython"
            ],
            "example_code": [],
            "description": "The git-format-patch command generates a patch series for email submission with additional features. It allows threading, adding custom headers, changing subject prefix, filename length, adding a cover letter, encoding email headers, interdiff, range-diff, adding notes, signatures, custom suffix, and more. The output of this command is convenient for email submission or for use with git am. The message generated by the command consists of three parts: a brief metadata header, the second and subsequent paragraphs of the commit log message, and the patch, which is the diff -p --stat output between the commit and its parent. The log message and the patch are separated by a line with a three-dash line.",
            "api_name_original": "git-format-patch-advanced",
            "api_arguments_original": [
                "--thread[=<style>]",
                "--in-reply-to=<message id>",
                "--ignore-if-in-upstream",
                "--always",
                "--cover-from-description=<mode>",
                "--subject-prefix=<subject prefix>",
                "--filename-max-length=<n>",
                "--rfc",
                "--reroll-count=<n>",
                "--to=<email>",
                "--cc=<email>",
                "--from=<ident>",
                "--force-in-body-from",
                "--add-header=<header>",
                "--cover-letter",
                "--encode-email-headers",
                "--interdiff=<previous>",
                "--range-diff=<previous>",
                "--creation-factor=<percent>",
                "--notes[=<ref>]",
                "--signature=<signature>",
                "--signature-file=<file>",
                "--suffix=.<sfx>",
                "--quiet",
                "--no-binary",
                "--zero-commit",
                "--base[=<commit>]",
                "--root",
                "--progress"
            ]
        }
    },
    {
        "query": "I want to list the commit objects with the email and commit message for the current branch in Git.",
        "model_answer": "git.rev_list(format=\"medium\", commit=\"HEAD\")",
        "original": {
            "domain": "git",
            "framework": "Git",
            "functionality": "Lists commit objects with various formats and options",
            "api_name": "git.rev_list",
            "api_call": "git rev-list --format=<format> <commit>\u2026\u200b [--] [<path>\u2026\u200b]",
            "api_arguments": [
                {
                    "name": "format"
                },
                {
                    "name": "commit"
                },
                {
                    "name": "path"
                }
            ],
            "python_environment_requirements": [],
            "example_code": [
                {
                    "description": "Print the list of commits reachable from the current branch",
                    "code": "git rev-list HEAD"
                },
                {
                    "description": "Print the list of commits on this branch, but not present in the upstream branch",
                    "code": "git rev-list @{upstream}..HEAD"
                },
                {
                    "description": "Format commits with their author and commit message",
                    "code": "git rev-list --format=medium HEAD"
                },
                {
                    "description": "Print the list of commits on the current branch that touched any file in the Documentation directory",
                    "code": "git rev-list HEAD -- Documentation/"
                },
                {
                    "description": "Print the list of commits authored by you in the past year, on any branch, tag, or other ref",
                    "code": "git rev-list --author=you@example.com --since=1.year.ago --all"
                }
            ],
            "description": "The git-rev-list command lists commit objects in various formats. It supports a wide range of placeholders for extracting information from the commit, including commit hash, author name, author date, and commit message. The format can be customized using a printf-like syntax. The command also supports several built-in formats such as 'oneline', 'short', 'medium', 'full', 'fuller', 'email', 'mboxrd', 'raw', and 'format'. This command is very essential in Git, since it provides the ability to build and traverse commit ancestry graphs with a high degree of customization and flexibility in formatting.",
            "api_name_original": "git-rev-list advanced formatting",
            "api_arguments_original": [
                "format",
                "commit",
                "path"
            ]
        }
    },
    {
        "query": "I want to show the changes between commits using the advanced options in Git, including finding renames, copies, and complete rewrites.",
        "model_answer": "git.diff(find_copies_harder=True, B=True, C=True)",
        "original": {
            "domain": "https://git-scm.com/docs/git-diff",
            "framework": "git",
            "functionality": "Show changes between commits, commit and working tree, etc. with advanced options",
            "api_name": "git.diff",
            "api_call": "git diff --find-copies-harder -B -C",
            "api_arguments": [
                {
                    "name": "find_copies_harder"
                },
                {
                    "name": "_b"
                },
                {
                    "name": "_c"
                }
            ],
            "python_environment_requirements": [
                "GitPython"
            ],
            "example_code": [
                {
                    "description": "Spend extra cycles to find renames, copies and complete rewrites (very expensive)",
                    "code": "git diff --find-copies-harder -B -C"
                },
                {
                    "description": "Output diff in reverse",
                    "code": "git diff -R"
                },
                {
                    "description": "Limit the width of the graph part in --stat output",
                    "code": "git diff --statGraphWidth"
                }
            ],
            "description": "The git-diff-advanced API is an extension of the git-diff API with advanced options. It can be used to find renames, copies and complete rewrites, output diff in reverse, limit the width of the graph part in --stat output, and more. The API provides flexibility with numerous configuration options to tailor the diff output according to user requirements. It also includes features to handle diff output for submodules, external diff programs, and custom diff drivers.",
            "api_name_original": "git-diff-advanced",
            "api_arguments_original": [
                "--find-copies-harder",
                "-B",
                "-C"
            ]
        }
    },
    {
        "query": "Can you provide a Python function call to show the contents of the file main.py as they were current in the 5th last commit of the branch feature/new_feature?",
        "model_answer": "git.show(\"feature/new_feature~5:main.py\")",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Show various types of objects with advanced features and generate patch text",
            "api_name": "git.show",
            "api_call": "git show [<options>] [<object>\u2026\u200b]",
            "api_arguments": [
                {
                    "name": "options"
                },
                {
                    "name": "object"
                }
            ],
            "python_environment_requirements": [],
            "example_code": [
                {
                    "description": "Shows the tag v1.0.0, along with the object the tags points at.",
                    "code": "git show v1.0.0"
                },
                {
                    "description": "Shows the tree pointed to by the tag v1.0.0.",
                    "code": "git show v1.0.0^{tree}"
                },
                {
                    "description": "Shows the subject of the commit pointed to by the tag v1.0.0.",
                    "code": "git show -s --format=%s v1.0.0^{commit}"
                },
                {
                    "description": "Shows the contents of the file Documentation/README as they were current in the 10th last commit of the branch next.",
                    "code": "git show next~10:Documentation/README"
                },
                {
                    "description": "Concatenates the contents of said Makefiles in the head of the branch master.",
                    "code": "git show master:Makefile master:t/Makefile"
                }
            ],
            "description": "The git-show command shows one or more objects (blobs, trees, tags and commits). For commits it shows the log message and textual diff. It also presents the merge commit in a special format as produced by git diff-tree --cc. This advanced version includes additional options for controlling the output such as raw format, patch with raw, tree objects in diff output, heuristic for shifting diff hunk boundaries, minimal diff, patience diff, histogram diff, anchored diff, diff algorithm, diffstat, compact summary, numstat, shortstat, dirstat, summary, patch with stat, name only, name status, submodule diff, color diff, word diff, diff filter, find object, pickaxe all, pickaxe regex, relative path, ignore whitespace, ignore blank lines, inter-hunk context, function context, external diff, text conversion filter. This version also includes the ability to generate patch text with the -p option.",
            "api_name_original": "git-show-advanced-patch",
            "api_arguments_original": [
                "options",
                "object"
            ]
        }
    },
    {
        "query": "I want to compare changes between the branch \"feature/foo\" and the branch \"main\" in my git repository.",
        "model_answer": "git.diff_extended(\"feature/foo\", \"main\")",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Show changes between commits, commit and working tree, etc.",
            "api_name": "git.diff_extended",
            "api_call": "git diff [<options>] [<commit>] [--] [<path>\u2026\u200b]",
            "api_arguments": [
                {
                    "name": "options",
                    "description": "Options to modify the behavior of the command, including limit diff output, comparing branches, comparing with arbitrary commits, and various ways to check your working tree",
                    "type": "string"
                },
                {
                    "name": "commit",
                    "description": "Specific commit to show changes from",
                    "type": "string"
                },
                {
                    "name": "path",
                    "description": "Specific path to show changes in",
                    "type": "string"
                }
            ],
            "python_environment_requirements": [],
            "example_code": [
                {
                    "description": "Comparing branches",
                    "code": "git diff topic master"
                },
                {
                    "description": "Limiting the diff output",
                    "code": "git diff --diff-filter=MRC"
                },
                {
                    "description": "Munging the diff output",
                    "code": "git diff --find-copies-harder -B -C"
                },
                {
                    "description": "Output diff in reverse",
                    "code": "git diff -R"
                }
            ],
            "description": "The git-diff-extended API allows users to view changes between commits, the commit and the working tree, etc. It provides several options to modify the behavior of the command and allows specifying a specific commit or path to show changes. This API also allows for limiting the diff output, comparing branches, comparing with arbitrary commits, and various ways to check your working tree. This can be useful for reviewing changes made in a specific commit or a specific part of the codebase. This updated version includes the ability to munge the diff output and reverse the output.",
            "api_name_original": "git-diff-extended",
            "api_arguments_original": [
                {
                    "name": "<options>",
                    "type": "string",
                    "description": "Options to modify the behavior of the command, including limit diff output, comparing branches, comparing with arbitrary commits, and various ways to check your working tree"
                },
                {
                    "name": "<commit>",
                    "type": "string",
                    "description": "Specific commit to show changes from"
                },
                {
                    "name": "<path>",
                    "type": "string",
                    "description": "Specific path to show changes in"
                }
            ]
        }
    },
    {
        "query": "Please provide a detailed understanding of Git's architecture, including the components and their relationships.",
        "model_answer": "N/A",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Detailed understanding of Git architecture",
            "api_name": "N/",
            "api_call": "N/A",
            "api_arguments": [
                {
                    "name": "n/a"
                }
            ],
            "python_environment_requirements": [
                "gitpython"
            ],
            "example_code": [],
            "description": "The new page content provides a detailed understanding of Git's architecture. A Git project normally consists of a working directory with a '.git' subdirectory at the top level. The .git directory contains a compressed object database representing the complete history of the project, an 'index' file which links that history to the current contents of the working tree, and named pointers into that history such as tags and branch heads. The object database contains objects of three main types: blobs, which hold file data; trees, which point to blobs and other trees to build up directory hierarchies; and commits, which each reference a single tree and some number of parent commits. The commit, equivalent to what other systems call a 'changeset' or 'version', represents a step in the project\u2019s history, and each parent represents an immediately preceding step. Commits with more than one parent represent merges of independent lines of development. The entire history leading up to a commit can be vouched for by signing just that commit. A fourth object type, the tag, is provided for this purpose. When first created, objects are stored in individual files, but for efficiency may later be compressed together into 'pack files'. The index file is initialized with a list of all paths and, for each path, a blob object and a set of attributes. The blob object represents the contents of the file as of the head of the current branch. The attributes (last modified time, size, etc.) are taken from the corresponding file in the working tree. Subsequent changes to the working tree can be found by comparing these attributes. The index may be updated with new content, and new commits may be created from the content stored in the index.",
            "api_name_original": "Git Architecture",
            "api_arguments_original": [
                "N/A"
            ]
        }
    },
    {
        "query": "I want to compare the content and mode of the blobs found in a tree object with the corresponding tracked files in the working tree using the git-diff-index-advanced API from GitPython. I want to ignore all spaces and show function context.",
        "model_answer": "git.diff_index_advanced(\"--ignore-all-space\", \"--function-context\")",
        "original": {
            "domain": "git",
            "framework": "Git",
            "functionality": "Compare a tree to the working tree or index with advanced options",
            "api_name": "git.diff_index_advanced",
            "api_call": "git diff-index [--cached] [--merge-base] [--relative[=<path>]] [--ignore-space-at-eol] [--ignore-all-space] [--ignore-blank-lines] [--ignore-matching-lines=<regex>] [--inter-hunk-context=<lines>] [--function-context] [--exit-code] [--quiet] [--ext-diff] [--no-ext-diff] [--textconv] [--no-textconv] [--ignore-submodules[=<when>]] [--src-prefix=<prefix>] [--dst-prefix=<prefix>] [--no-prefix] [--default-prefix] [--line-prefix=<prefix>] [--ita-invisible-in-index] <tree-ish> [<path>\u2026\u200b]",
            "api_arguments": [
                {
                    "name": "cached"
                },
                {
                    "name": "merge_base"
                },
                {
                    "name": "relative["
                },
                {
                    "name": "ignore_space_at_eol"
                },
                {
                    "name": "ignore_all_space"
                },
                {
                    "name": "ignore_blank_lines"
                },
                {
                    "name": "ignore_matching_lines"
                },
                {
                    "name": "inter_hunk_context"
                },
                {
                    "name": "function_context"
                },
                {
                    "name": "exit_code"
                },
                {
                    "name": "quiet"
                },
                {
                    "name": "ext_diff"
                },
                {
                    "name": "no_ext_diff"
                },
                {
                    "name": "textconv"
                },
                {
                    "name": "no_textconv"
                },
                {
                    "name": "ignore_submodules["
                },
                {
                    "name": "src_prefix"
                },
                {
                    "name": "dst_prefix"
                },
                {
                    "name": "no_prefix"
                },
                {
                    "name": "default_prefix"
                },
                {
                    "name": "line_prefix"
                },
                {
                    "name": "ita_invisible_in_index"
                },
                {
                    "name": "tree_ish"
                },
                {
                    "name": "path"
                }
            ],
            "python_environment_requirements": [
                "GitPython"
            ],
            "example_code": [],
            "description": "The git-diff-index-advanced API allows you to compare the content and mode of the blobs found in a tree object with the corresponding tracked files in the working tree, or with the corresponding paths in the index. When <path> arguments are present, it compares only paths matching those patterns. Otherwise all tracked files are compared. This API provides advanced options such as ignoring spaces at end of lines, ignoring all spaces, ignoring blank lines, ignoring matching lines with a regular expression, showing inter-hunk context, showing function context, exiting with codes similar to diff(1), quiet mode, allowing or disallowing external diff drivers, allowing or disallowing external text conversion filters, ignoring changes to submodules, specifying source and destination prefixes, not showing any source or destination prefix, using the default source and destination prefixes, prepending an additional prefix to every line of output, and making entries added by 'git add -N' appear as a new file in 'git diff' and non-existent in 'git diff --cached'.",
            "api_name_original": "git-diff-index-advanced",
            "api_arguments_original": [
                "--cached",
                "--merge-base",
                "--relative[=<path>]",
                "--ignore-space-at-eol",
                "--ignore-all-space",
                "--ignore-blank-lines",
                "--ignore-matching-lines=<regex>",
                "--inter-hunk-context=<lines>",
                "--function-context",
                "--exit-code",
                "--quiet",
                "--ext-diff",
                "--no-ext-diff",
                "--textconv",
                "--no-textconv",
                "--ignore-submodules[=<when>]",
                "--src-prefix=<prefix>",
                "--dst-prefix=<prefix>",
                "--no-prefix",
                "--default-prefix",
                "--line-prefix=<prefix>",
                "--ita-invisible-in-index",
                "<tree-ish>",
                "<path>"
            ]
        }
    },
    {
        "query": "I want to push the current branch to the remote ref matching master in the origin repository.",
        "model_answer": "git.push(origin, \"HEAD:master\")",
        "original": {
            "domain": "github",
            "framework": "git",
            "functionality": "configure and push updates to remote repository",
            "api_name": "git.push",
            "api_call": "git push [--all | --mirror | --tags] [--follow-tags] [--atomic] [--receive-pack=<git-receive-pack>] [--repo=<repository>] [-f | --force] [--prune] [-v | --verbose] [-u | --set-upstream] [--[no-]signed|--signed=(true|false|if-asked)] [--force-with-lease[=<refname>[:<expect>]] [--force-if-includes] [--no-verify] [<repository> [<refspec>\u2026\u200b]]",
            "api_arguments": [
                {
                    "name": "all"
                },
                {
                    "name": "mirror"
                },
                {
                    "name": "tags"
                },
                {
                    "name": "follow_tags"
                },
                {
                    "name": "atomic"
                },
                {
                    "name": "receive_pack"
                },
                {
                    "name": "repo"
                },
                {
                    "name": "_f"
                },
                {
                    "name": "force"
                },
                {
                    "name": "prune"
                },
                {
                    "name": "_v"
                },
                {
                    "name": "verbose"
                },
                {
                    "name": "_u"
                },
                {
                    "name": "set_upstream"
                },
                {
                    "name": "[no_]signed"
                },
                {
                    "name": "signed"
                },
                {
                    "name": "force_with_lease"
                },
                {
                    "name": "force_if_includes"
                },
                {
                    "name": "no_verify"
                },
                {
                    "name": "repository"
                },
                {
                    "name": "refspec"
                }
            ],
            "python_environment_requirements": [
                "gitpython"
            ],
            "example_code": [
                {
                    "description": "Push the current branch to the remote ref matching master in the origin repository",
                    "code": "git push origin HEAD:master"
                },
                {
                    "description": "Create the branch experimental in the origin repository by copying the current master branch",
                    "code": "git push origin master:refs/heads/experimental"
                },
                {
                    "description": "Find a ref that matches experimental in the origin repository and delete it",
                    "code": "git push origin :experimental"
                },
                {
                    "description": "Update the origin repository\u2019s master branch with the dev branch, allowing non-fast-forward updates",
                    "code": "git push origin +dev:master"
                }
            ],
            "description": "The git-push command is used to update remote refs along with associated objects. It pushes the changes from the local repository to the remote repository. The command takes various arguments to specify the nature of the push operation, such as whether to push all branches, mirror the local repository to the remote one, force the push operation, and so on. The command also takes an optional repository argument to specify the remote repository to push to, and a refspec argument to specify what destination ref to update with what source object. This page also provides detailed configuration options for git push, such as push.default, push.followTags, push.gpgSign, and more.",
            "api_name_original": "git-push-config",
            "api_arguments_original": [
                "--all",
                "--mirror",
                "--tags",
                "--follow-tags",
                "--atomic",
                "--receive-pack",
                "--repo",
                "-f",
                "--force",
                "--prune",
                "-v",
                "--verbose",
                "-u",
                "--set-upstream",
                "--[no-]signed",
                "--signed",
                "--force-with-lease",
                "--force-if-includes",
                "--no-verify",
                "<repository>",
                "<refspec>"
            ]
        }
    },
    {
        "query": "I want to show the tag 'v2.0.0' along with the object the tag points at.",
        "model_answer": "git.show(tag='v2.0.0')",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Show various types of objects with advanced options including ignoring submodules and prefix customization",
            "api_name": "git.show(tag='v1.0.0'",
            "api_call": "git show [--ignore-submodules[=<when>]] [--src-prefix=<prefix>] [--dst-prefix=<prefix>] [--no-prefix] [--default-prefix] [--line-prefix=<prefix>] [--ita-invisible-in-index] [<options>] [<object>\u2026\u200b]",
            "api_arguments": [
                {
                    "name": "options"
                },
                {
                    "name": "object"
                },
                {
                    "name": "when"
                },
                {
                    "name": "prefix"
                }
            ],
            "python_environment_requirements": [
                "git"
            ],
            "example_code": [
                {
                    "description": "Show the tag v1.0.0, along with the object the tags points at",
                    "code": "git show v1.0.0"
                },
                {
                    "description": "Show the contents of the file Documentation/README as they were current in the 10th last commit of the branch next",
                    "code": "git show next~10:Documentation/README"
                },
                {
                    "description": "Concatenates the contents of said Makefiles in the head of the branch master",
                    "code": "git show master:Makefile master:t/Makefile"
                }
            ],
            "description": "The git-show-advanced-enhanced API is an extension of the git-show-advanced API with additional options for advanced usage. It allows users to display various types of objects with added control over the format of the output. It includes options to ignore submodules, customize prefix, and control the display of index. This API is useful for users who need more control over the output of git-show for scripting or other advanced use cases.",
            "api_name_original": "git-show-advanced-enhanced",
            "api_arguments_original": [
                "<options>",
                "<object>",
                "<when>",
                "<prefix>"
            ]
        }
    },
    {
        "query": "I want to limit the number of commits to show to 5 using the git-log-encoding API.",
        "model_answer": "git.log(\"-5\")",
        "original": {
            "domain": "git",
            "framework": "git",
            "functionality": "Limit the number of commits to show, encoding of commit log messages, configuration of commit encoding and output encoding",
            "api_name": "git.log",
            "api_call": "git log -3",
            "api_arguments": [
                {
                    "name": "_3"
                }
            ],
            "python_environment_requirements": [
                "gitpython"
            ],
            "example_code": [
                {
                    "description": "Limit the number of commits to show to 3",
                    "code": "git log -3"
                }
            ],
            "description": "The git-log-encoding API allows you to limit the number of commits to show, and manage the encoding of commit log messages. It supports a wide range of character encoding for commit log messages, including UTF-8, ISO-8859-x, CP125x and others. It also provides configurations for commit encoding and output encoding. This API is particularly useful for projects with international collaborators, as it ensures that commit messages are correctly displayed for everyone.",
            "api_name_original": "git-log-encoding",
            "api_arguments_original": [
                "-3"
            ]
        }
    }
]