[
    {"domain": "linux", "framework": "OS", "functionality": "Get the current working directory", "api_name": "Get Current Working Directory", "api_call": "os.getcwd()", "api_arguments": "None", "python_environment_requirements": "import os", "description": "This linux API is used to get the current working directory. The API returns a string representing the current working directory.", "example_code": [{"description": "Example to show usage of getcwd()", "code": "import os\nprint(os.getcwd())"}]},
{"domain": "linux", "framework": "RPM (RedHat Package Manager)", "functionality": "Package management", "api_name": "RPM commands", "api_call": "rpm -ivh [package_name]", "api_arguments": ["package_name"], "python_environment_requirements": "Python not required", "example_code": [{"description": "Install an RPM package", "code": "rpm -ivh pidgin-2.7.9-5.el6.2.i686.rpm"}], "description": "RPM is used for installing, uninstalling, upgrading, querying, verifying, and managing software packages in linux. It deals with .rpm files, which contain the actual information about the packages such as what it is, from where it comes, dependencies info, version info etc. It keeps the information of all the installed packages under /var/lib/rpm database."},
{"domain": "linux", "framework": "Command-Line", "functionality": "Process Management", "api_name": "Kill Command", "api_call": "kill -9 3139", "api_arguments": ["-9", "3139"], "python_environment_requirements": "Python not required", "example_code": [{"description": "To kill a process with process id 3139", "code": "kill -9 3139"}], "description": "The kill command in linux is used to send a signal to a process. By default, it sends a TERM signal, which requests the process to terminate. However, the process may choose to ignore this signal. The -9 option sends a KILL signal, which forces the process to terminate immediately. The process cannot ignore a KILL signal. The kill command requires the process id (PID) as an argument. The PID can be found using commands such as ps, pidof, or pgrep."},
{"domain": "linux", "framework": "os", "functionality": "Change the root directory of the current process", "api_name": "chroot", "api_call": "os.chroot(path)", "api_arguments": [{"name": "path", "type": "string", "description": "The path to the new root directory."}], "python_environment_requirements": [{"name": "os", "version": "Python Standard Library"}], "example_code": [{"description": "Change the root directory to '/tmp'", "code": "import os\nos.chroot('/tmp')"}], "description": "The chroot method in the os module of Python Standard Library is used to change the root directory of the current process to the path specified. This can be useful in creating a sandbox environment for the process where it can't access files outside the new root directory."},
{"domain": "linux", "framework": "Command Line", "functionality": "Remove Directory", "api_name": "rmdir", "api_call": "rmdir directory_name", "api_arguments": ["directory_name"], "python_environment_requirements": ["linux OS"], "example_code": [{"description": "Remove an empty directory", "code": "rmdir dir1"}, {"description": "Remove multiple directories", "code": "rmdir dir1 dir2 dir3"}, {"description": "Remove directory in verbose mode", "code": "rmdir -v dir1"}, {"description": "Remove directory and all its ancestors", "code": "rmdir -p -v dir1/dir2/dir3/dir4/dir5"}, {"description": "Ignore failure on non-empty directory", "code": "rmdir --ignore-fail-on-non-empty dir1"}, {"description": "Use regular expressions to remove directories", "code": "rmdir -v dir?"}], "description": "The rmdir command in linux is used to remove directories. It can only remove empty directories. The command can be used with various options like -v for verbose mode, -p to remove a directory and all its ancestors and --ignore-fail-on-non-empty to suppress errors when trying to remove non-empty directories. Regular expressions can also be used with the rmdir command to match and remove directories."},
{"domain": "linux", "framework": "Shell", "functionality": "Print Working Directory", "api_name": "pwd", "api_call": "/bin/pwd", "api_arguments": ["-L", "-P", "--help", "--version"], "python_environment_requirements": "Python not required", "example_code": [{"description": "Print your current working directory", "code": "/bin/pwd"}, {"description": "Print working directory from environment even if it contains symlinks", "code": "/bin/pwd -L"}, {"description": "Print actual physical current working directory by resolving all symbolic links", "code": "/bin/pwd -P"}, {"description": "Print version of your \u2018pwd\u2019 command", "code": "/bin/pwd --version"}], "description": "The 'pwd' command in linux prints the current working directory or simply the directory user is, at present. It prints the current directory name with the complete path starting from root (/). This command is built in shell command and is available on most of the shell \u2013 bash, Bourne shell, ksh,zsh, etc."},
{"domain": "linux", "framework": "Shell", "functionality": "Search and Find Files", "api_name": "dpkg and grep", "api_call": "dpkg -l | grep -i python", "api_arguments": ["-l", "|", "grep", "-i", "python"], "python_environment_requirements": "None", "example_code": [{"description": "Finding Files with Grep Command", "code": "dpkg -l | grep -i python"}], "description": "The dpkg command with grep is used to list and filter installed *.deb packages on your system. It is particularly useful when you want to find out if a specific package, like python, is installed on your system. The '-l' argument lists the installed packages, the '|' pipes that output to grep, and the '-i' argument ignores case when filtering out and returning everything with 'python' in it."},
{"domain": "linux", "framework": "Command Line", "functionality": "File Navigation", "api_name": "more and less commands", "api_call": "more /var/log/auth.log", "api_arguments": "File path", "python_environment_requirements": "Python not required", "example_code": [{"description": "Using more command to view file content", "code": "more /var/log/auth.log"}, {"description": "Using less command to view file content", "code": "less /var/log/auth.log"}], "description": "The 'more' and 'less' commands in linux are used to view the contents of a file and navigate through the file. The main difference between 'more' and 'less' is that 'less' command is faster because it does not load the entire file at once and allows navigation through the file using page up/down keys. 'more' command, on the other hand, loads the entire file but allows navigation only in the forward direction."},
{"domain": "linux", "framework": "Command Line", "functionality": "File manipulation", "api_name": "head, tail, cat commands", "api_call": "head [options] [file(s)], tail [options] [file(s)], cat [options] [filenames]", "api_arguments": {"options": "Optional parameters that modify the command behavior", "file(s)": "The file(s) to be read", "filenames": "The filenames to be concatenated or read"}, "python_environment_requirements": "Python is not required for these commands as they are native to the linux command line", "example_code": [{"description": "Display the first ten lines of a file", "code": "head /etc/passwd"}, {"description": "Display the last ten lines of a file", "code": "tail access.log"}, {"description": "Concatenate and display the contents of files", "code": "cat 1 2 3 4 > 5"}], "description": "The 'head', 'tail', and 'cat' commands are used for file manipulation in linux. The 'head' command reads the first ten lines of any given file. The 'tail' command displays the last ten lines of any text file. The 'cat' command is used to read the contents of files, concatenate files, and redirect output in terminal or files."},
{"domain": "linux", "framework": "Command Line", "functionality": "Delay command execution", "api_name": "sleep", "api_call": "sleep <NUMBER>[SUFFIX]", "api_arguments": ["NUMBER: Time to sleep", "SUFFIX: Optional suffix to specify time unit (s for seconds, m for minutes, h for hours, d for days)"], "python_environment_requirements": ["linux environment"], "example_code": [{"description": "Delay command execution for 5 seconds", "code": "date '+%r'; sleep 5; date '+%r'"}, {"description": "Delay command execution for 1 minute", "code": "date '+%r'; sleep 1m; date '+%r'"}, {"description": "Delay command execution for 1 minute and 20 seconds", "code": "date '+%r'; sleep 1m 20s; date '+%r'"}, {"description": "Delay command execution for half a second", "code": "date '+%r'; sleep 0.5s; date '+%r'"}, {"description": "Simulate an alarm clock to set alarm after 5 seconds", "code": "sleep 5; cvlc alarm.mp3"}, {"description": "Simulate a digital clock", "code": "while [ 1 ]\ndo\nclear\ntput cup 5 30\ndate '+%r'\nsleep 1\ndone"}], "description": "The sleep command in linux is used to pause command execution for a specified period of time. It accepts a number parameter to specify the time to sleep and an optional suffix to specify the time unit. The time unit can be seconds (s), minutes (m), hours (h), or days (d). The command can be used to delay command execution, simulate an alarm clock, or simulate a digital clock."},
{"domain": "linux", "framework": "Shell", "functionality": "Process Management", "api_name": "ps command", "api_call": "ps", "api_arguments": ["-A", "-e", "au", "axu", "-ef", "-eF", "-x", "-fU", "-fu", "-U", "-fG", "-fg", "-fp", "--ppid", "-t", "--forest", "-fL", "L", "-eo", "-p", "-C", "-eo", "--context", "--format"], "python_environment_requirements": "Python subprocess module", "example_code": [{"description": "List all processes in current shell", "code": "ps"}, {"description": "Display every active process in generic format", "code": "ps -A"}, {"description": "Display all processes in BSD format", "code": "ps au"}, {"description": "Perform a full-format listing", "code": "ps -ef"}, {"description": "Select all processes owned by you", "code": "ps -x"}, {"description": "Display a user\u2019s processes by real user ID (RUID) or name", "code": "ps -fU tecmint"}], "description": "The ps command in linux is used to provide information about the currently running processes, including their process identification numbers (PIDs)."},
{"domain": "linux", "framework": "Python", "functionality": "To read the contents of a file", "api_name": "read_file", "api_call": "open('filename', 'r').read()", "api_arguments": [{"name": "filename", "type": "string", "description": "The name of the file to be read"}, {"name": "mode", "type": "string", "description": "The mode in which the file is to be opened. 'r' stands for read mode"}], "python_environment_requirements": [{"name": "Python", "version": "Any"}], "example_code": [{"description": "Reading a file named 'example.txt'", "code": "file = open('example.txt', 'r')\ncontent = file.read()\nfile.close()\nprint(content)"}], "description": "The 'read_file' API in linux allows you to read the contents of a file. You need to specify the name of the file and the mode in which it is to be opened. In this case, 'r' stands for read mode. After reading the contents, don't forget to close the file using the 'close()' function."},
{"domain": "linux", "framework": "N/A", "functionality": "Creating and using aliases", "api_name": "alias", "api_call": "alias shortName='your custom command here'", "api_arguments": ["shortName", "your custom command here"], "python_environment_requirements": "N/A", "example_code": [{"description": "Creating a temporary alias", "code": "alias wr='cd /var/www/html'"}, {"description": "Creating a permanent alias", "code": "alias home='ssh -i ~/.ssh/mykep.pem [email protected]'"}, {"description": "Removing an alias", "code": "unalias alias_name"}], "description": "The 'alias' command in linux is used to create shortcuts or abbreviations for longer commands. This can help to save time and reduce the amount of typing required. You can create temporary aliases that last for the duration of the current terminal session, or permanent aliases that are saved in your user's shell configuration profile file and persist across sessions. To remove an alias, you can use the 'unalias' command."},
{"domain": "linux", "framework": "Shell", "functionality": "Display directory contents", "api_name": "dir command", "api_call": "dir [options] [file|dir]", "api_arguments": ["-1", "-a", "-l", "-d", "-i", "-s", "-S", "-t", "-g", "-G", "--author", "--group-directories-first", "-R", "-n", "-m"], "python_environment_requirements": "Shell environment", "example_code": [{"description": "List files and directories under the /etc directory", "code": "dir /etc"}, {"description": "List one file per line", "code": "dir -1 /etc"}, {"description": "List all files including hidden files", "code": "dir -a"}, {"description": "List only directory entries", "code": "dir -d /etc"}, {"description": "List index number of each file", "code": "dir -il"}, {"description": "View files sizes", "code": "dir -shl"}, {"description": "Sort files by modification time", "code": "dir -ashlt /home/kone"}, {"description": "List files without their owners", "code": "dir -ahgG /home/kone"}, {"description": "View author of a file", "code": "dir -al --author /home/kone"}, {"description": "View directories before all other files", "code": "dir -l --group-directories-first"}, {"description": "View subdirectories recursively", "code": "dir -R"}, {"description": "View user and group IDs", "code": "dir -nl --author"}, {"description": "List files separated by commas", "code": "dir -am"}], "description": "The dir command is used in linux to display the contents of a directory. It supports a variety of options to enhance its functionality, such as listing files in a specific order, displaying hidden files, showing detailed information about each file, and more."},
{"domain": "linux", "framework": "Command Line", "functionality": "Display file contents", "api_name": "head command", "api_call": "head [OPTIONS] [FILE-1] [FILE-2] ..", "api_arguments": ["OPTIONS", "FILE-1", "FILE-2"], "python_environment_requirements": "Python not required, this is a linux command line API", "example_code": [{"description": "Show First 10 Lines Of File in linux", "code": "$ head file-1.txt"}, {"description": "Show First N Lines of File in linux", "code": "$ head -n 5 file-1.txt"}, {"description": "Remove Last N Lines of a File in linux", "code": "$ head -n -10 file-1.txt"}, {"description": "Show First N Characters of the File", "code": "$ head -c 8 file-1.txt"}, {"description": "Remove Last N Characters of File", "code": "$ head -c -9 file-1.txt"}, {"description": "Show File Name in Header of File", "code": "$ head -n 5 -v file-1.txt"}, {"description": "Show File Name in Header in Multiple Files", "code": "$ head -n 3 file-1.txt file-2.txt"}, {"description": "How to Disable the Display Header", "code": "$ head -n 3 -q file-1.txt file-2.txt"}], "description": "The head command in linux is used to print the top N lines of data of the given input. It can be used to print the first N lines, first N characters, or the file name in the header of the file. It can also be used to remove the last N lines or characters of a file. By default, it prints the first 10 lines of the specified files. If more than one file name is provided then data from each file is preceded by its file name."},
{"domain": "linux", "framework": "Shell", "functionality": "Create directories and manage permissions", "api_name": "mkdir", "api_call": "mkdir directory_name", "api_arguments": ["-p", "-m", "-v"], "python_environment_requirements": ["Shell"], "example_code": [{"description": "Create a directory", "code": "mkdir rpm-distros"}, {"description": "Create multiple directories", "code": "mkdir deb-distros/kali deb-distros/mint deb-distros/ubuntu"}, {"description": "Create multiple directories using brace expansion", "code": "mkdir rpm-distros/{alma,centos,fedora}"}, {"description": "Create a nested sub-directory structure", "code": "mkdir -p rpm-distros/centos/8.x/8.1/8.1-1911"}, {"description": "Create a directory with permissions", "code": "mkdir -m 777 dir-1"}, {"description": "Enable verbose with mkdir command", "code": "mkdir -p -v dir-1/dir-2/dir-3/dir-4/dir-5"}], "description": "The mkdir command in linux is used to create directories. It can create a single directory, multiple directories, and nested directory structures. It also allows to set permissions for the directories at the time of creation. The command also supports verbose mode to print messages for each created directory."},
{"domain": "linux", "framework": "wget", "functionality": "Download files from the internet", "api_name": "Wget", "api_call": "wget [option] [URL]", "api_arguments": ["option: various options to modify the behavior of wget", "URL: the URL of the file to download"], "python_environment_requirements": "Python is not required for this API.", "example_code": [{"description": "Download a single file and store it in the current directory", "code": "wget http://ftp.gnu.org/gnu/wget/wget2-2.0.0.tar.gz"}, {"description": "Download multiple files using HTTP and FTP protocol", "code": "wget http://ftp.gnu.org/gnu/wget/wget2-2.0.0.tar.gz ftp://ftp.gnu.org/gnu/wget/wget2-2.0.0.tar.gz.sig"}, {"description": "Download multiple files from a file containing list of URLs", "code": "wget -i download-linux.txt"}], "description": "Wget is a free utility available for Unix-like operating systems and Windows OS. It is used to download files from the internet. It supports downloading via HTTP, HTTPS, and FTP protocols. It offers a set of commands that allow you to download files, download in the background, mirror a website, resume a download, etc. It also supports downloading files from password-protected websites."},
{"domain": "linux", "framework": "Command Line", "functionality": "Text extraction and manipulation", "api_name": "cut Command", "api_call": "cut <OPTIONS>... [FILE-1] [FILE-2] ...", "api_arguments": ["OPTIONS", "FILE-1", "FILE-2"], "python_environment_requirements": "linux Terminal", "example_code": [{"description": "Extract the first byte from each line of the file", "code": "cut -b 1 file.txt"}, {"description": "Select the first four bytes from the file", "code": "cut -b 1,2,3,4 file.txt"}, {"description": "Select the first twelve bytes from each line", "code": "cut -b 1-12 file.txt"}, {"description": "Print all bytes starting from position 17", "code": "cut -b 17- file.txt"}, {"description": "Print all the bytes from the start of the line till the 12th column", "code": "cut -b -12 file.txt"}, {"description": "Cut the first byte from the following multi-byte string", "code": "echo \u00e9cole | cut -b 1"}, {"description": "Cut the same multi-byte character and observe the result", "code": "echo \u00e9cole | cut -c 1"}, {"description": "Use the space character as a delimiter and print the first two fields", "code": "cut -d \" \" -f 1,2 file.txt"}, {"description": "Print all the characters except the first character", "code": "cut -c 1 --complement file.txt"}], "description": "The 'cut' command in linux is a command line utility used for text processing. It is used to extract sections from each line of input, usually from a file. It can be used to cut parts of a line by byte position, character and field. The 'cut' command can be used in conjunction with other commands in linux for more complex text processing or data extraction tasks."},
{"domain": "linux", "framework": "fd", "functionality": "File search", "api_name": "fd", "api_call": "fd *pattern*", "api_arguments": ["pattern"], "python_environment_requirements": ["linux operating system"], "example_code": [{"description": "Find all jpg files", "code": "fd -e jpg"}, {"description": "Search for string in all PHP files", "code": "fd -e php index"}, {"description": "Exclude some results", "code": "fd -e php index -E wp-content"}, {"description": "Find all JPG files and modify permission", "code": "fd -e jpg -x chmod 644 {}"}], "description": "The fd command is a fast and user-friendly alternative to the find command in linux. It comes with features like easy to use syntax, colorful output, smart search with case-insensitive by default, and does not look in hidden files and directories by default. It also supports Unicode and does not look into .gitignore by default."},
{"domain": "linux", "framework": "Command Line", "functionality": "User management", "api_name": "Useradd Command", "api_call": "useradd [options] username", "api_arguments": ["options: Various options to customize the user account", "username: The name of the user account to be created"], "python_environment_requirements": "Python is not required for this API as it is a linux command line utility.", "example_code": [{"description": "Create a new user called 'tecmint'", "code": "useradd tecmint"}, {"description": "Create a user 'anusha' with a home directory '/data/projects'", "code": "useradd -d /data/projects anusha"}, {"description": "Create a user 'navin' with custom userid '1002'", "code": "useradd -u 1002 navin"}, {"description": "Add a user 'tarunika' with a specific UID and GID", "code": "useradd -u 1005 -g tecmint tarunika"}, {"description": "Add a user 'tecmint' to multiple groups", "code": "usermod -a -G admins,webadmin,developers tecmint"}], "description": "The useradd command in linux is a utility for adding users to a system. It can be used to create a new user account with a unique username, set a home directory for the user, assign a specific user ID or group ID, and add the user to multiple groups. The command also includes options for setting an account expiry date, creating a user without a home directory, and adding custom comments to the user account."},
{"domain": "linux", "framework": "gzip", "functionality": "File Compression and Decompression", "api_name": "gzip", "api_call": "gzip [OPTIONS]... [FILES]...", "api_arguments": ["OPTIONS", "FILES"], "python_environment_requirements": "linux", "example_code": [{"description": "Create a Gzip File in linux", "code": "gzip alma-linux.iso"}, {"description": "Create Gzip and Keep Original File", "code": "gzip -k alma-linux.iso"}, {"description": "View Contents of a .gz File", "code": "zcat demo.gz"}, {"description": "View Info of a .gz File", "code": "gzip -l alma-linux.iso.gz"}, {"description": "Overwrite Gzip File Without Confirmation", "code": "gzip -f -k alma-linux.iso"}, {"description": "Compress Multiple Files with Gzip", "code": "gzip alma-linux-1.iso alma-linux-2.iso alma-linux-3.iso"}, {"description": "Gzip All Files in a Directory", "code": "gzip -r dir-1/"}, {"description": "Decompress a Gzip File in linux", "code": "gzip -d alma-linux.iso.gz"}, {"description": "Compress Tar File to Gzip", "code": "gzip sample.tar"}, {"description": "Speeding Up gzip Compression", "code": "gzip --fast alma-linux.iso"}, {"description": "Speeding Up Gzip Compression Ratio", "code": "gzip --best alma-linux.iso"}, {"description": "Set Gzip Compression Level", "code": "gzip -2 alma-linux.iso"}, {"description": "Change Gzip File Extension Suffix", "code": "gzip --suffix .gnuzip alma-linux.iso"}], "description": "The gzip command in linux is used for file compression and decompression. The command syntax is divided into two parts: OPTIONS and FILES. OPTIONS are used to alter the behavior of the command and FILES represent the input files. The gzip command can compress a single file, multiple files, or all files in a directory. It can also decompress files, view the contents of a compressed file, and change the file extension suffix. The gzip command can operate in an interactive or non-interactive way, and it can be used to regulate the speed of compression."},
{"domain": "linux", "framework": "Command Line Interface", "functionality": "Write output to files, append output to files, write output to multiple files, send output of one command to another, hide output of file, write output to privileged file, edit privileged file, ignore interrupt signals", "api_name": "tee command", "api_call": "tee [OPTIONS] [FILE1] [FILE2] [FILE3] ...", "api_arguments": "OPTIONS, FILE1, FILE2, FILE3", "python_environment_requirements": "Python not required", "example_code": [{"description": "Save Output to a File in linux", "code": "$ echo \"tecmint.com\" | tee output.txt"}, {"description": "Append Output to File in linux", "code": "$ echo \"tecmint.com\" | tee -a output.txt"}, {"description": "Write Output to Multiple Files in linux", "code": "$ echo \"tecmint.com\" | tee file-1.txt file-2.txt file-3.txt"}, {"description": "Send Output of One Command to Another", "code": "$ echo \"tecmint.com\" | tee example.txt | wc -c"}, {"description": "Hide Output of File in linux", "code": "$ echo \"tecmint.com\" | tee output.txt > /dev/null"}, {"description": "Write Output to Privileged File", "code": "$ echo \"tecmint.com\" | sudo tee -a output.txt"}, {"description": "Edit Privileged File in linux", "code": ":w !sudo tee %"}, {"description": "Ignore Interrupts Signal (SIGINT)", "code": "$ echo \"tecmint.com\" | tee -i example.txt"}], "description": "The tee command in linux is used to read from standard input and write to standard output and files. It can be used to perform various operations such as saving output to a file, appending output to a file, writing output to multiple files, sending output of one command to another, hiding output of a file, writing output to a privileged file, editing a privileged file, and ignoring interrupt signals."},
{"domain": "linux", "framework": "network", "functionality": "network interface configuration", "api_name": "ifconfig", "api_call": "ifconfig", "api_arguments": ["-a", "interface_name", "up", "down", "ip_address", "netmask", "broadcast", "mtu", "promisc", "-promisc", "hw ether", "interface_name:0 down"], "python_environment_requirements": "linux environment", "example_code": [{"description": "View all network interface settings", "code": "ifconfig"}, {"description": "Display information of all network interfaces", "code": "ifconfig -a"}, {"description": "View network settings of specific interface", "code": "ifconfig eth0"}, {"description": "Enable a network interface", "code": "ifconfig eth0 up"}, {"description": "Disable a network interface", "code": "ifconfig eth0 down"}, {"description": "Assign an IP address to network interface", "code": "ifconfig eth0 172.16.25.125"}, {"description": "Assign a netmask to network interface", "code": "ifconfig eth0 netmask 255.255.255.224"}, {"description": "Assign a broadcast to network interface", "code": "ifconfig eth0 broadcast 172.16.25.63"}, {"description": "Change MTU for a network interface", "code": "ifconfig eth0 mtu 1000"}, {"description": "Enable promiscuous mode", "code": "ifconfig eth0 promisc"}, {"description": "Disable promiscuous mode", "code": "ifconfig eth0 -promisc"}, {"description": "Add new alias to network interface", "code": "ifconfig eth0:0 172.16.25.127"}, {"description": "Remove alias to network interface", "code": "ifconfig eth0:0 down"}, {"description": "Change the MAC address of network interface", "code": "ifconfig eth0 hw ether AA:BB:CC:DD:EE:FF"}], "description": "The 'ifconfig' command in linux is a widely used tool for interfacing network settings. It is used to check the network interface details, enable or disable interfaces, assign IP address, netmask, broadcast address, and much more. It also allows the configuration of advanced network interface settings such as promiscuous mode and MAC address configuration."},
{"domain": "linux", "framework": "Command Line", "functionality": "Remove duplicate lines in text files", "api_name": "uniq command", "api_call": "uniq [OPTIONS] [INPUT] [OUTPUT]", "api_arguments": ["OPTIONS", "INPUT", "OUTPUT"], "python_environment_requirements": "Python not required", "example_code": [{"description": "Remove duplicate lines from a text file", "code": "$ uniq linux-distributions.txt"}, {"description": "Count duplicated lines in a text file", "code": "$ uniq -c linux-distributions.txt"}, {"description": "Remove duplicates with case insensitive", "code": "$ uniq -i linux-distributions.txt"}, {"description": "Print only duplicate lines from a file", "code": "$ uniq -d linux-distributions.txt"}, {"description": "Print all duplicate lines from a file", "code": "$ uniq -D linux-distributions.txt"}, {"description": "Show duplicate lines by groups in a new line", "code": "$ uniq --all-repeated=separate linux-distributions.txt"}, {"description": "Print only unique lines from a file", "code": "$ uniq -u linux-distributions.txt"}, {"description": "Remove non-adjacent duplicate lines in file", "code": "$ sort linux-distributions.txt | uniq"}], "description": "The uniq command in linux is used to remove duplicate lines from input in files or pipelines. It can be used with various options to count duplicate lines, ignore case when comparing lines, only print duplicate lines, and more. The uniq command only removes adjacent duplicate lines, so it is often used with the sort command to sort lines before making them adjacent."},
{"domain": "linux", "framework": "Command Line", "functionality": "Get system uptime", "api_name": "Uptime Command", "api_call": "uptime", "api_arguments": ["-p", "-s", "-h", "-V"], "python_environment_requirements": "linux OS", "example_code": [{"description": "Check linux Server Uptime", "code": "uptime -p"}, {"description": "Check linux Server Starting Time", "code": "uptime -s"}, {"description": "Uptime Version & Help", "code": "uptime -h"}], "description": "The uptime command in linux gives the time for which the system has been up (i.e., running). It displays the current time, the total time for which the system has been running, the user count (number of logged on users), and the system load averages. The '-p' option can be used to display the running time in a pretty format, the '-s' option displays the start time of the system, and the '-h' option displays help information."},
{"domain": "linux", "framework": "os", "functionality": "Change the current working directory", "api_name": "Change Directory", "api_call": "os.chdir(path)", "api_arguments": ["path"], "python_environment_requirements": ["import os"], "example_code": [{"description": "Change to directory /home/user", "code": "os.chdir('/home/user')"}], "description": "The os.chdir() method in Python is used to change the current working directory to specified path. It takes only a single argument as new directory path. This method does not return any value."},
{"domain": "linux", "framework": "df command", "functionality": "Check Disk Space", "api_name": "df", "api_call": "df", "api_arguments": ["-a", "-h", "-hT", "-k", "-m", "-h", "-i", "-T", "-t", "-x", "--help"], "python_environment_requirements": ["linux OS"], "example_code": [{"description": "Display Information of all File System Disk Space Usage", "code": "df -a"}, {"description": "Show Disk Space Usage in Human Readable Format", "code": "df -h"}, {"description": "Display Information of /home File System", "code": "df -hT /home"}, {"description": "Display Information of File System in Bytes", "code": "df -k"}, {"description": "Display Information of File System in MB", "code": "df -m"}, {"description": "Display Information of File System in GB", "code": "df -h"}, {"description": "Display File System Inodes", "code": "df -i"}, {"description": "Display File System Type", "code": "df -T"}, {"description": "Include Certain File System Type", "code": "df -t ext3"}, {"description": "Exclude Certain File System Type", "code": "df -x ext3"}, {"description": "Display Information of df Command", "code": "df --help"}], "description": "The 'df' command in linux provides information about the file system disk space usage. It includes total blocks, total disk space, used disk space, available disk space, and mount points on a file system. It has various flags such as '-a' to display all information, '-h' to display in human-readable format, '-i' to display the number of used inodes, '-T' to display the file system type, '-t' to display a certain file system type, '-x' to exclude certain file system type, and '--help' to display information about the df command."},
{"domain": "linux", "framework": "tar", "functionality": "Creating, extracting, and managing tar files", "api_name": "tar command", "api_call": "tar -cvf tecmint-14-09-12.tar /home/tecmint/", "api_arguments": ["-c: Creates a new .tar archive file.", "-v: Verbosely show the .tar file progress.", "-f: File name type of the archive file."], "python_environment_requirements": "linux environment", "example_code": [{"description": "Create a tar File in linux", "code": "tar -cvf tecmint-14-09-12.tar /home/tecmint/"}, {"description": "Extract Tar File in linux", "code": "tar -xvf public_html-14-09-12.tar"}, {"description": "List Tar Files in linux", "code": "tar -tvf uploadprogress.tar"}, {"description": "Extract a File from Tar in linux", "code": "tar -xvf cleanfiles.sh.tar cleanfiles.sh"}, {"description": "Add Files or Directories to Tar in linux", "code": "tar -rvf tecmint-14-09-12.tar xyz.txt"}, {"description": "Check Tar File Size in linux", "code": "tar -czf - tecmint-14-09-12.tar | wc -c"}, {"description": "Exclude Files and Directories in Tar File", "code": "tar --exclude='file1.txt' -zcvf backup.tar.gz /home/tecmint"}, {"description": "Extract File Extension in Tar File", "code": "tar -xvf backup.tar.gz --wildcards '*.png'"}], "description": "The tar command in linux is used to create, maintain, modify, and extract files that are archived in the tar format. It offers a versatile command line interface for managing archived files, and it is used in various scenarios including backup scripts, copying directories, and others. The tar command provides various options such as -c for creating a new archive, -x for extracting files from an archive, -v for displaying progress, -f for specifying the archive file, and others. The tar command is a crucial tool for managing file archives in a linux environment."},
{"domain": "linux", "framework": "Command Line", "functionality": "File Creation and Modification", "api_name": "Touch Command", "api_call": "touch [options] [file_name]", "api_arguments": {"-a": "change the access time only", "-c": "if the file does not exist, do not create it", "-d": "update the access and modification times", "-m": "change the modification time only", "-r": "use the access and modification times of the file", "-t": "creates a file using a specified time"}, "python_environment_requirements": "Python not required", "example_code": [{"description": "Create an empty file", "code": "touch sheena"}, {"description": "Create multiple files", "code": "touch sheena meena leena"}, {"description": "Change file access and modification time", "code": "touch -a leena"}, {"description": "Avoid creating new file", "code": "touch -c leena"}, {"description": "Change file modification time", "code": "touch -m leena"}, {"description": "Explicitly set the access and modification times", "code": "touch -c -t YYDDHHMM leena"}, {"description": "Use the time stamp of another file", "code": "touch -r leena meena"}, {"description": "Create a file using a specified time", "code": "touch -t YYMMDDHHMM.SS tecmint"}], "description": "The touch command in linux is used to create, change and modify timestamps of a file. It has various options that allow you to change the access and modification times, avoid creating a new file if it doesn't exist, and create a file with a specified time. Examples include creating an empty file, creating multiple files, changing file access and modification time, avoiding creating a new file, changing file modification time, explicitly setting the access and modification times, using the timestamp of another file and creating a file using a specified time."},
{"domain": "linux", "framework": "Command Line", "functionality": "File and Directory Operations", "api_name": "mv Command", "api_call": "mv [OPTIONS] <SOURCE> <DEST>", "api_arguments": ["OPTIONS", "SOURCE", "DEST"], "python_environment_requirements": "linux OS, Terminal", "example_code": [{"description": "Rename a file", "code": "mv file-1.txt file-2.txt"}, {"description": "Enable Verbose Mode", "code": "mv -v file-2.txt file-1.txt"}, {"description": "Rename a directory", "code": "mv -v src dst"}, {"description": "Move multiple files to a directory", "code": "mv -v 1.mp3 2.txt 3.dat misc"}, {"description": "Move multiple directories", "code": "mv -v dir-1 dir-2 dir-3 dir-4"}, {"description": "Avoid overwriting files", "code": "mv -v -n file-1.txt file-2.txt"}, {"description": "Overwrite files interactively", "code": "mv -v -i file-1.txt file-2.txt"}, {"description": "Overwrite file only when the source is newer", "code": "mv -v -u file-1.txt file-2.txt"}, {"description": "Create a backup before overwriting files", "code": "mv --backup=numbered -v file-1.txt file-2.txt"}], "description": "The mv command in linux is used for moving and renaming files and directories. It can be used with various options for different functionalities such as enabling verbose mode, avoiding overwriting files, overwriting files interactively, moving multiple files or directories, and creating a backup before overwriting files."},
{"domain": "linux", "framework": "os", "functionality": "Create a child process", "api_name": "fork", "api_call": "pid = os.fork()", "api_arguments": "None", "python_environment_requirements": "Python 3.6+, linux OS, 'os' module", "example_code": [{"description": "Create a child process and print the process id", "code": "import os\n\npid = os.fork()\n\nif pid > 0 :\n    print(f'I am parent process: \n    - My actual pid is : {os.getpid()}\n    - My child's pid is : {pid}')\nelse :\n    print(f'I am the child process: \n    - My pid is : {os.getpid()}\n    - My parent's pid is : {os.getppid()}')"}], "description": "The 'fork' API in linux is used to create a new process. The new process, called the child, is an exact copy of the calling process, called the parent, except for the returned process ID. The child process has a unique process ID and it executes independently of the parent process."},
{"domain": "linux", "framework": "egrep", "functionality": "Pattern search in files", "api_name": "egrep", "api_call": "egrep [options] [PATTERN] [FILE]", "api_arguments": ["options", "PATTERN", "FILE"], "python_environment_requirements": "linux environment", "example_code": [{"description": "Search for a string in a file", "code": "egrep 'professionals' sample.txt"}, {"description": "Highlight matched patterns in file", "code": "egrep --color=auto 'professionals' sample.txt"}, {"description": "Search for a pattern in multiple files", "code": "egrep 'professionals' sample.txt sample-copy.txt"}, {"description": "Count matching lines in file", "code": "egrep -c 'professionals' sample.txt"}, {"description": "Print only matched lines in file", "code": "egrep -o 'professionals' sample.txt"}], "description": "The egrep command in linux is used to search for a pattern in files. The pattern can be simple or complex, involving regular expressions. egrep is a version of grep that supports extended regular expressions. It supports a variety of options such as case-insensitive search, whole word matching, line numbering, and more. It can also handle multiple files and directories, making it a powerful tool for searching for specific patterns of text within files."},
{"domain": "linux", "framework": "Command Line Interface", "functionality": "Listing directory contents", "api_name": "ls Command Options", "api_call": "ls [options] /path/to/directory", "api_arguments": ["-m: Lists directory contents separated by a comma", "-Q: Displays directory contents enclosed by quotation marks", "-l: Displays files in a long-list format", "-lh: Display file size in a human-readable format", "-g: Omits group ownership column", "-F: Adds a forward slash to directories", "-i: Display inode number of files and directories", "-a: Display all files including hidden files", "*.: Filters files according to the file extension", "-la: Displays all files and directories in long list format", "-R: Display files and directories recursively", "-r: Sort Files in reverse", "-X: Sort files alphabetically by file extension", "-tl: Display files according to file creation date and time", "-n: List UIDs and GIDs"], "python_environment_requirements": "Python is not required for this API call", "example_code": [{"description": "List Files and Directories", "code": "ls"}, {"description": "Long Listing of Files", "code": "ls -l"}, {"description": "List Hidden Files and Directories", "code": "ls -a"}, {"description": "List All Files", "code": "ls -la"}, {"description": "Display File Size in a Human-readable Format", "code": "ls -lh"}, {"description": "Distinguish Directories and Files", "code": "ls -F"}, {"description": "Sorting Files in Reverse Order", "code": "ls -lr"}, {"description": "List Files Recursively", "code": "ls -R"}, {"description": "Sort Files By Modification Time", "code": "ls -ltr"}, {"description": "Sort Files By Newest to Oldest", "code": "ls -tl"}, {"description": "Sort Files by File Size", "code": "ls -lS"}, {"description": "List File Inode Number", "code": "ls -i"}, {"description": "List Files and Directories Separated by Commas", "code": "ls -m"}, {"description": "Omit Group Ownership in a Long-List Format", "code": "ls -g"}, {"description": "List Specific File Types or Extensions", "code": "ls *.jpg"}, {"description": "List the UID and GID of Files", "code": "ls -n"}], "description": "The 'ls' command in linux is used to list directory contents. It can be used with various options to manipulate the output of the command. These options include displaying directory contents in a long-list format, displaying file size in a human-readable format, sorting files in reverse, displaying files recursively, and more."},
{"domain": "linux", "framework": "Python", "functionality": "Check if a file exists and is accessible", "api_name": "os.path.isfile", "api_call": "os.path.isfile(path)", "api_arguments": [{"name": "path", "type": "str", "description": "Path of the file"}], "python_environment_requirements": ["os"], "example_code": [{"description": "Check if a file exists and is accessible", "code": "import os\n\npath = '/path/to/file'\n\nif os.path.isfile(path):\n    print('File exists and is accessible')\nelse:\n    print('File does not exist or is not accessible')"}], "description": "The os.path.isfile(path) function in Python is used to check whether the specified path is an existing regular file or not. It returns a boolean value: True if the path is an existing regular file; otherwise, False. This function follows symbolic links, so if the path is a symbolic link pointing to a regular file, this function will return True."},
{"domain": "linux", "framework": "Command Line Interface", "functionality": "Change file ownership", "api_name": "chown command", "api_call": "chown [OPTION]... [OWNER][:[GROUP]] [FILE-1] [FILE-2]...[FILE-N]", "api_arguments": ["OPTION", "OWNER", "GROUP", "FILE-1", "FILE-2", "FILE-N"], "python_environment_requirements": "Python is not required for this API as it is a command line utility", "example_code": [{"description": "Change ownership of file", "code": "$ sudo chown narendra file-1.txt"}, {"description": "Change group ownership of file", "code": "$ sudo chown :narendra file-1.txt"}, {"description": "Change ownership and group of file", "code": "$ sudo chown tecmint:tecmint file-1.txt"}, {"description": "Change ownership of symbolic link", "code": "$ sudo chown -h narendra:narendra symlink"}, {"description": "Transfer file ownership to the user", "code": "$ sudo chown -h --from narendra:narendra tecmint:tecmint symlink"}, {"description": "Copy ownership from another file", "code": "$ sudo chown --reference=file-1.txt file-2.txt"}, {"description": "Change ownership of directory recursively", "code": "$ sudo chown -R narendra:narendra dir-1"}, {"description": "Print chown command process details", "code": "$ sudo chown -Rv tecmint:tecmint dir-1"}, {"description": "Suppress chown command errors", "code": "$ sudo chown -f narendra:narendra non-existing-file.txt"}, {"description": "Change file user and group ID", "code": "$ sudo chown 1001:1001 file-1.txt"}], "description": "The chown command in linux is used to change the ownership and group of files and directories. It can be used to change the owner, group, or both, and can also be used to change the ownership of symbolic links. The command can be used in a variety of ways, including changing the ownership of a file or directory, changing the group of a file or directory, changing the ownership and group of a file or directory, and changing the ownership of a symbolic link. The command also includes options for changing the ownership of a file or directory recursively, copying the ownership from another file, and suppressing error messages."},
{"domain": "linux", "framework": "IP Command", "functionality": "Network Configuration and Management", "api_name": "IP Command", "api_call": "ip", "api_arguments": ["addr", "link", "route", "neigh"], "python_environment_requirements": "Python 3.x, linux Operating System", "example_code": [{"description": "Assign a temporary static IP address", "code": "ip addr add 172.19.1.10/24 dev eth2"}, {"description": "Display all network interfaces", "code": "ip link show"}, {"description": "Display IP address of a specific network interface", "code": "ip addr show eth2"}, {"description": "Remove an IP address from a network interface", "code": "ip addr del 172.19.1.10/24 dev eth2"}, {"description": "Enable a network interface", "code": "ip link set eth2 up"}, {"description": "Disable a network interface", "code": "ip link set eth2 down"}, {"description": "Flush all IP addresses of a network interface", "code": "ip addr flush eth2"}, {"description": "Display routing table", "code": "ip route show"}, {"description": "Add a new static route", "code": "ip route add 172.19.1.0/24 dev eth2 proto kernel scope link src 172.19.1.2"}, {"description": "Remove a static route", "code": "ip route del 172.19.1.0/24"}, {"description": "Add a default gateway", "code": "ip route add default via 172.17.0.1"}, {"description": "Remove a default gateway", "code": "ip route del default"}, {"description": "Display ARP cache", "code": "ip neigh show"}, {"description": "Add an ARP entry", "code": "ip neigh add 172.19.1.0 lladdr 02:42:e3:40:a6:b1 dev eth2"}, {"description": "Remove an ARP entry", "code": "ip neigh del 172.19.1.0 dev eth2"}, {"description": "Flush the ARP entries", "code": "ip neigh flush all"}, {"description": "Set MTU for a network interface", "code": "ip link set mtu 3000 dev eth2"}, {"description": "Change the network MAC address", "code": "ip link set dev eth2 address 02:42:ac:13:01:03"}], "description": "The IP command in linux is a versatile tool used for network configuration and management. It can be used to assign temporary or permanent static IP addresses, display and manage network interfaces, manage routing tables, manipulate ARP cache, and more. The IP command is widely used in network administration and can be used for a variety of tasks such as enabling or disabling network interfaces, adding or removing static routes, and more."},
{"domain": "linux", "framework": "Screen Command", "functionality": "Terminal multiplexer", "api_name": "Screen Command", "api_call": "screen [OPTIONS] [ CMD [ ARGS ] ]", "api_arguments": "OPTIONS, CMD, ARGS", "python_environment_requirements": "Python not required", "example_code": [{"description": "Start Screen for the First Time", "code": "$ screen"}, {"description": "Show Screen Parameter", "code": "Ctrl-A and ?"}, {"description": "List All Open Windows", "code": "ctrl-a + \" key combination"}, {"description": "Terminate Screen Window Session", "code": "ctrl-a + k key combinations"}, {"description": "Start a Screen Session with Name", "code": "$ screen -S demo-screen"}, {"description": "Detach the Terminal Session with Screen", "code": "$ screen"}, {"description": "Re-attach the Terminal Session with Screen", "code": "$ screen -r"}, {"description": "Using Multiple Screen Terminal Windows", "code": "ctrl-a + c key combination"}, {"description": "Rename a Screen Window", "code": "ctrl-a + A key combination"}, {"description": "Switching Between Screen Terminal Windows", "code": "ctrl-a + \" key combination"}, {"description": "Move to the Next Screen Window", "code": "ctrl-a + n key combination"}, {"description": "Move to the Previous Screen Window", "code": "ctrl-a + p combination"}, {"description": "Switch Between Current and Previous Window", "code": "ctrl-a + ctrl-a key combination"}, {"description": "Jump to a Particular Screen Window", "code": "ctrl-a + 2 key combination"}, {"description": "Split a Screen Window Horizontally", "code": "ctrl-a + S key combination"}, {"description": "Split a Screen Window Vertically", "code": "ctrl-a + | key combination"}, {"description": "Enable Screen Logging in linux", "code": "ctrl-a + H key combination"}, {"description": "Lock linux Terminal Screen", "code": "ctrl-a + x key combination"}, {"description": "Add Password to Screen Session", "code": "password crypt_password"}, {"description": "Leaving Screen Terminal Session", "code": "exit command"}], "description": "The screen command in linux is used to start a screen session, detach a screen, and reattach a detached screen. It allows a user to access multiple separate terminal sessions inside a single terminal window or remote terminal session. It is useful for dealing with multiple programs from a command-line interface, and for separating programs from the session of the Unix shell that started the program, particularly so a remote process continues running even when the user is disconnected."},
{"domain": "linux", "framework": "Command Line Interface", "functionality": "List all running linux processes", "api_name": "List Running Processes", "api_call": "top", "api_arguments": [], "python_environment_requirements": [], "example_code": [], "description": "The 'top' command when run in the terminal, lists all the running linux processes. It provides information about running tasks, memory, CPU, and swap. To quit the window, press 'q'."},
{"domain": "linux", "framework": "Command Line Interface", "functionality": "Sort linux processes by PID", "api_name": "Sort Processes by PID", "api_call": "top", "api_arguments": ["M", "T"], "python_environment_requirements": [], "example_code": [], "description": "To sort all linux running processes by Process ID, press M and T keys while running the 'top' command."},
{"domain": "linux", "framework": "Command Line Interface", "functionality": "Sort linux processes by Memory and CPU usage", "api_name": "Sort Processes by Memory and CPU Usage", "api_call": "top", "api_arguments": ["M", "P"], "python_environment_requirements": [], "example_code": [], "description": "To sort all linux running processes by Memory usage, press M and P keys while running the 'top' command."},
{"domain": "linux", "framework": "Command Line Interface", "functionality": "Display linux processes by specific user", "api_name": "Display Processes by Specific User", "api_call": "top -u [username]", "api_arguments": ["-u", "[username]"], "python_environment_requirements": [], "example_code": [], "description": "To display all user-specific running processes information, use the '-u' option followed by the username. This will list specific User process details."},
{"domain": "linux", "framework": "Command Line Interface", "functionality": "Kill running linux process using top command", "api_name": "Kill Process Using Top Command", "api_call": "top", "api_arguments": ["k"], "python_environment_requirements": [], "example_code": [], "description": "You can kill a process after finding the PID of the process by pressing the 'k' option in running the top command without closing the top window."},
{"domain": "linux", "framework": "Command Line Interface", "functionality": "Save top command results in file", "api_name": "Save Top Command Results in File", "api_call": "top -n 1 -b > [filename]", "api_arguments": ["-n", "1", "-b", ">", "[filename]"], "python_environment_requirements": [], "example_code": [], "description": "To save the running top command results output to a file, use the command 'top -n 1 -b > [filename]'. This will save the output to the specified file."},
{"domain": "linux", "framework": "APT", "functionality": "Package Management", "api_name": "APT Commands", "api_call": "sudo apt [command]", "api_arguments": ["install", "content", "depends", "search", "show", "check", "recommends", "version", "update", "upgrade", "autoremove", "autoclean", "clean", "purge", "deb", "help"], "python_environment_requirements": "Python 2.7 or higher", "example_code": [{"description": "Install a package", "code": "sudo apt install glances"}, {"description": "Find location of installed package", "code": "sudo apt content glances"}, {"description": "Check all dependencies of a package", "code": "sudo apt depends glances"}, {"description": "Search for a package", "code": "sudo apt search apache2"}, {"description": "View information about package", "code": "sudo apt show firefox"}, {"description": "Verify a package for any broken dependencies", "code": "sudo apt check firefox"}, {"description": "List recommended missing packages of given package", "code": "sudo apt recommends apache2"}, {"description": "Check installed package version", "code": "sudo apt version firefox"}, {"description": "Update system packages", "code": "sudo apt update"}, {"description": "Upgrade system", "code": "sudo apt upgrade"}, {"description": "Remove unused packages", "code": "sudo apt autoremove"}, {"description": "Clean old repository of downloaded packages", "code": "sudo apt autoclean"}, {"description": "Remove packages with its configuration files", "code": "sudo apt purge glances"}, {"description": "Install .Deb package", "code": "sudo apt deb atom-amd64.deb"}, {"description": "Find help while using APT", "code": "apt help"}], "description": "The Advanced Package Tool (APT) is a powerful package management solution for Debian based systems. It provides commands for installing, upgrading and cleaning up of packages. APT simplifies the process of managing software on Unix-like computer systems by automating the retrieval, configuration and installation of software packages, either from precompiled files or by compiling source code."},
{"domain": "linux", "framework": "SSH", "functionality": "Remote host connection and command execution", "api_name": "SSH Command", "api_call": "ssh -l root 192.168.19.130", "api_arguments": ["-l", "root", "192.168.19.130"], "python_environment_requirements": "Python 3.5 or higher", "example_code": [{"description": "Connect to a remote host", "code": "ssh -l root 192.168.19.130"}, {"description": "Execute command on the remote host", "code": "ssh -l root 192.168.19.130 hostname"}], "description": "The SSH command in linux is used to start a new SSH client program. It allows secure network services over an unsecured network. SSH commands are encrypted and secure in several ways. Both ends of the client/server connection are authenticated using a digital certificate, and passwords are protected by being encrypted."},
{"domain": "linux", "framework": "pv command", "functionality": "Monitor progress of data operations", "api_name": "pv command in linux", "api_call": "pv file", "api_arguments": ["file"], "python_environment_requirements": ["linux OS", "pv command installed"], "example_code": [{"description": "Copy a file and monitor progress", "code": "pv opensuse.vdi > /tmp/opensuse.vdi"}, {"description": "Make a zip file from a file and monitor progress", "code": "pv /var/log/syslog | zip > syslog.zip"}, {"description": "Count the number of lines, words, and bytes in a file while showing the progress bar", "code": "pv -p /etc/hosts | wc"}, {"description": "Monitor the progress of creating a backup file using the tar utility", "code": "tar -czf - ./Downloads/ | (pv -p --timer --rate --bytes > backup.tgz)"}, {"description": "Write the ISO file to the USB flash drive using dd command", "code": "dd if=debian-10.11.0-amd64-DVD-1.iso | pv | dd of=/dev/sda bs=4M"}, {"description": "Using pv and dialog terminal-based tool together to create a dialog progress bar", "code": "tar -czf - ./Documents/ | (pv -n > backup.tgz) 2>&1 | dialog --gauge \"Progress\" 10 70"}], "description": "The pv command in linux is used to monitor the progress of data through a pipeline. It provides a visual representation of the data flow. It can be used in combination with other commands to monitor the progress of operations such as copying, moving, backing up files etc. It is not installed by default on most linux distributions, therefore it needs to be installed first. It can be used by placing it in a pipeline between two processes, with the appropriate options available. The standard input of pv will be passed through to its standard output and progress will be printed on standard error."},
{"domain": "linux", "framework": "Command Line", "functionality": "File Searching", "api_name": "locate Command", "api_call": "$ locate LAMP-Setup.odt", "api_arguments": ["filename"], "python_environment_requirements": ["linux Operating System"], "example_code": [{"description": "Using locate command to look for a file", "code": "$ locate LAMP-Setup.odt"}, {"description": "Limit search queries to a specific number", "code": "$ locate \"*.html\" -n 20"}, {"description": "Display the number of matching entries", "code": "$ locate -c [tecmint]*"}, {"description": "Ignore case sensitive locate outputs", "code": "$ locate -i *text.txt*"}, {"description": "Refresh mlocate Database", "code": "$ sudo updatedb"}, {"description": "Display only files present in your system", "code": "$ locate -i -e *text.txt*"}, {"description": "Separate output entries without new line", "code": "$ locate -i -0 *text.txt*"}, {"description": "Review your locate database", "code": "$ locate -S"}, {"description": "Suppress error messages in locate", "code": "$ locate \"*.dat\" -q*"}, {"description": "Choose a different mlocate location", "code": "$ locate -d <new db path> <filename>"}], "description": "The locate command in linux is used to find the location of a file. It is an inbuilt command which updates its database using updatedb command. The locate command reads one or more databases prepared by updatedb and writes file names matching at least one of the pattern to standard output."},
{"domain": "linux", "framework": "OS", "functionality": "Create a new directory", "api_name": "mkdir", "api_call": "os.mkdir(path)", "api_arguments": [{"name": "path", "type": "string", "description": "The path of the directory to be created."}], "python_environment_requirements": ["import os"], "example_code": [{"description": "Create a directory named 'test'", "code": "import os\nos.mkdir('test')"}], "description": "The mkdir API in the linux OS framework is used to create a new directory at the specified path. The path argument is a string that specifies where to create the new directory."},
{"domain": "linux", "framework": "File System", "functionality": "Directory Size Retrieval", "api_name": "du command", "api_call": "du [OPTIONS]... [FILE]...", "api_arguments": ["-h (Human Readable Format)", "-s (Summary)", "-a (All files and directories)", "-k (Kilobyte blocks)", "-m (Megabyte blocks)", "-c (Grand total)", "--exclude (Exclude files)", "--time (Modification Time)"], "python_environment_requirements": "Python not required, shell environment", "example_code": [{"description": "Find the disk usage summary of a directory and its subdirectories", "code": "du /home/tecmint"}, {"description": "Find the directory size in human readable format", "code": "du -h /home/tecmint"}, {"description": "Find total size of a directory", "code": "du -sh /home/tecmint"}, {"description": "Find disk usage of all the files and directories", "code": "du -a /home/tecmint"}, {"description": "Find disk usage of all files and folders in a human-readable format", "code": "du -ah /home/tecmint"}, {"description": "Find out the disk usage of a directory tree with its subtree in Kilobyte blocks", "code": "du -k /home/tecmint"}, {"description": "Get the summary of disk usage of directory tree along with its subtrees in Megabytes", "code": "du -mh /home/tecmint"}, {"description": "Get a grand total usage disk space", "code": "du -ch /home/tecmint"}, {"description": "Exclude files with du command", "code": "du -ah --exclude=\"*.txt\" /home/tecmint"}, {"description": "Find directory usage by modification time", "code": "du -ha --time /home/tecmint"}], "description": "The 'du' command in linux is used to check the amount of disk space used by a directory or a file. It can be used with various options to customize the output, such as displaying sizes in human-readable format, summarizing the total size, including/excluding certain files, and more."},
{"domain": "linux", "framework": "DNF", "functionality": "Package management", "api_name": "DNF Commands", "api_call": "dnf <command>", "api_arguments": ["--version", "repolist", "repolist all", "list", "list installed", "list available", "search <package>", "provides <file/sub-package>", "info <package>", "install <package>", "update <package>", "check-update", "update", "upgrade", "remove <package>", "erase <package>", "autoremove", "clean all", "help <command>", "help", "history", "grouplist", "groupinstall '<group package>'", "groupupdate '<group package>'", "groupremove '<group package>'", "--enablerepo=<repo> install <package>", "distro-sync", "reinstall <package>", "downgrade <package>"], "python_environment_requirements": ["dnf"], "example_code": [{"description": "Check DNF Version", "code": "dnf --version"}, {"description": "List Enabled DNF Repositories", "code": "dnf repolist"}, {"description": "List all Enabled and Disabled DNF Repositories", "code": "dnf repolist all"}, {"description": "List all Available and Installed Packages using DNF", "code": "dnf list"}, {"description": "List all Installed Packages using DNF", "code": "dnf list installed"}, {"description": "List all Available Packages using DNF", "code": "dnf list available"}, {"description": "Search for a Package using DNF", "code": "dnf search <package>"}, {"description": "See what Provides a file/sub-package", "code": "dnf provides <file/sub-package>"}, {"description": "Get Details of a Package using DNF", "code": "dnf info <package>"}, {"description": "Install a Package with DNF", "code": "dnf install <package>"}, {"description": "Updating a Package using DNF", "code": "dnf update <package>"}, {"description": "Check for System Updates using DNF", "code": "dnf check-update"}, {"description": "Update All System Packages using DNF", "code": "dnf update"}, {"description": "Remove/Erase a Package using DNF", "code": "dnf remove <package>"}, {"description": "Remove Orphan Packages using DNF", "code": "dnf autoremove"}, {"description": "Remove Cached Packages using DNF", "code": "dnf clean all"}, {"description": "Get Help on Specific DNF Command", "code": "dnf help <command>"}, {"description": "List all DNF Commands and Options", "code": "dnf help"}, {"description": "View History of DNF", "code": "dnf history"}, {"description": "List all Group Packages", "code": "dnf grouplist"}, {"description": "Install a Group Package using DNF", "code": "dnf groupinstall '<group package>'"}, {"description": "Update a Group Package", "code": "dnf groupupdate '<group package>'"}, {"description": "Remove a Group Package", "code": "dnf groupremove '<group package>'"}, {"description": "Install a Package from Specific Repository", "code": "dnf --enablerepo=<repo> install <package>"}, {"description": "Synchronize Installed Packages to Stable Release", "code": "dnf distro-sync"}, {"description": "Reinstall a Package", "code": "dnf reinstall <package>"}, {"description": "Downgrade a Package", "code": "dnf downgrade <package>"}], "description": "DNF is a package manager for linux systems that replaces yum. It provides command-line commands for managing packages on the system, including installation, removal, updating, and listing packages and repositories. It also provides commands for managing group packages and interacting with specific repositories."},
{"domain": "linux", "framework": "lsof", "functionality": "List Open Files", "api_name": "lsof", "api_call": "lsof", "api_arguments": "None", "python_environment_requirements": "None", "example_code": [{"description": "List all open files", "code": "lsof"}, {"description": "List user specific opened files", "code": "lsof -u tecmint"}, {"description": "Find processes running on specific port", "code": "lsof -i TCP:22"}, {"description": "List only IPv4 & IPv6 open files", "code": "lsof -i 4"}, {"description": "List open files of TCP port ranges 1-1024", "code": "lsof -i TCP:1-1024"}, {"description": "Exclude user with '^' character", "code": "lsof -i -u^root"}, {"description": "Find out who's looking what files and commands", "code": "lsof -i -u tecmint"}, {"description": "List all network connections", "code": "lsof -i"}, {"description": "Search by PID", "code": "lsof -p 1"}, {"description": "Kill all activity of particular user", "code": "kill -9 `lsof -t -u tecmint`"}], "description": "The lsof command in linux displays in its output information about files that are opened by processes. It is used in many different scenarios such as troubleshooting, system tuning, and security tasks. It provides a great deal of information about open files and the processes that opened them."},
{"domain": "linux", "framework": "Shell", "functionality": "File and disk operations", "api_name": "dd Command", "api_call": "dd if=input_file of=output_file", "api_arguments": [{"name": "if", "description": "Input or source file"}, {"name": "of", "description": "Output or destination file"}, {"name": "conv", "description": "Conversion option for case conversion"}, {"name": "oflag", "description": "Output flag for append mode"}, {"name": "ibs", "description": "Input block size for skipping characters"}, {"name": "skip", "description": "Number of blocks to skip"}, {"name": "bs", "description": "Block size for backup operations"}, {"name": "count", "description": "Number of blocks to copy"}, {"name": "status", "description": "Option to show progress"}], "python_environment_requirements": [], "example_code": [{"description": "Copy a file", "code": "dd if=file-1.txt of=file-2.txt"}, {"description": "Convert text from lowercase to uppercase", "code": "dd if=file-1.txt of=upper-case.txt conv=ucase"}, {"description": "Convert text from uppercase to lowercase", "code": "dd if=upper-case.txt of=lower-case.txt conv=lcase"}, {"description": "Avoid overwriting destination file", "code": "dd if=file-1.txt of=file-2.txt conv=excl"}, {"description": "Append data in a file", "code": "dd if=file-1.txt of=dest.txt oflag=append conv=notrunc"}, {"description": "Skip bytes or characters while reading the input file", "code": "dd if=file-1.txt of=file-2.txt ibs=8 skip=1"}, {"description": "Backup linux disk partition", "code": "sudo dd if=/dev/sda1 of=partition-bkp.img"}, {"description": "Restore linux disk partition", "code": "sudo dd if=partition-bkp.img of=/dev/sdb1"}, {"description": "Backup entire linux hard drive", "code": "sudo dd if=/dev/sda of=disk-bkp.img"}, {"description": "Restore the linux hard drive", "code": "sudo dd if=disk-bkp.img of=/dev/sdb"}, {"description": "Backup Master Boot Record", "code": "sudo dd if=/dev/sda of=mbr.img bs=512 count=1"}, {"description": "Restore Master Boot Record", "code": "sudo dd if=mbr.img of=/dev/sdb"}, {"description": "Copy CD/DVD drive content", "code": "sudo dd if=/dev/cdrom of=alma-minimal.iso"}, {"description": "Create a bootable USB drive", "code": "sudo dd if=alma-minimal.iso of=/dev/sdb"}, {"description": "Show the progress bar", "code": "sudo dd if=alma-minimal.iso of=/dev/sdb status=progress"}], "description": "The dd command in linux is a versatile tool used for file and disk operations. It can copy files, convert case of text, avoid overwriting destination files, append data in a file, skip characters while reading, backup and restore disk partitions and entire hard drives, backup and restore Master Boot Record, copy CD/DVD drive content, create a bootable USB drive, and show progress of operations."},
{"domain": "linux", "framework": "os", "functionality": "Change the current working directory", "api_name": "Change Directory", "api_call": "os.chdir(path)", "api_arguments": [{"name": "path", "type": "string", "description": "Path to the new directory"}], "python_environment_requirements": [{"name": "os", "version": "built-in"}], "example_code": [{"description": "Change the current working directory to '/home'", "code": "import os\nos.chdir('/home')"}], "description": "This API is used to change the current working directory to the specified path. The new path must be an existing directory. If the directory does not exist, an error will be raised. The current working directory is the directory from which python scripts are run. It is similar to the command 'cd' in the Unix/linux shell."},
{"domain": "linux", "framework": "Command Line", "functionality": "File and Directory Copying", "api_name": "cp Command", "api_call": "cp [OPTIONS] <SOURCE> <DEST>", "api_arguments": ["OPTIONS", "SOURCE", "DEST"], "python_environment_requirements": "Python is not required", "example_code": [{"description": "Copy a file into a current directory", "code": "cp file-1.txt file-2.txt"}, {"description": "Show copy command progress", "code": "cp -v file-1.txt file-3.txt"}, {"description": "Copy multiple files into a directory", "code": "cp -v file-1.txt file-2.txt file-3.txt dir-1"}, {"description": "Avoid overwriting the file", "code": "cp -n -v file-1.txt file-2.txt"}, {"description": "Overwrite the file with confirmation", "code": "cp -i file-1.txt file-2.txt"}, {"description": "Overwrite file only if the source is newer", "code": "cp -u -v file-1.txt file-2.txt"}, {"description": "Backup file before overwriting", "code": "cp --backup=numbered -v file-1.txt file-2.txt"}, {"description": "Force copy to overwrite file", "code": "cp -f -v file-1.txt file-2.txt"}, {"description": "Remove the destination file before copying", "code": "cp --remove-destination -v file-1.txt file-2.txt"}, {"description": "Create a hard link file instead of copying", "code": "cp -l -v file-1.txt file-4.txt"}, {"description": "Create a soft link file instead of copying", "code": "cp -s -v file-1.txt file-5.txt"}, {"description": "Preserve the file attributes while copying", "code": "cp -p -v file-1.txt file-6.txt"}, {"description": "Perform copy operation recursively", "code": "cp -r -v dir-1 dir-3"}, {"description": "Copy multiple directories", "code": "cp -r -v dir-1 dir-3 dir-4"}], "description": "The cp command in linux is used to copy files and directories from one location to another. It supports various options such as showing progress, avoiding overwriting, creating hard or soft links instead of copying, preserving file attributes, and performing operations recursively. The syntax for the cp command is 'cp [OPTIONS] <SOURCE> <DEST>'. The OPTIONS are optional and can be used to modify the behavior of the command. The SOURCE and DEST are mandatory and specify the source and destination files or directories."},
{"domain": "linux", "framework": "ss command", "functionality": "Listing and managing network connections", "api_name": "ss command options", "api_call": "ss -option", "api_arguments": ["-a: list all ports", "-l: list listening sockets", "-t: list all TCP connections", "-lt: list all listening TCP connections", "-ua: list all UDP connections", "-lu: list all listening UDP connections", "-p: display PID of sockets", "-s: display summary statistics", "-4: display IPv4 socket connections", "-6: display IPv6 socket connections"], "python_environment_requirements": "Python is not required for running ss command in linux", "example_code": [{"description": "Listing all connections", "code": "ss"}, {"description": "Listing Listening and Non-listening Ports", "code": "ss -a"}, {"description": "Listing Listening Sockets", "code": "ss -l"}, {"description": "List all TCP Connections", "code": "ss -t"}, {"description": "List all Listening TCP Connections", "code": "ss -lt"}, {"description": "List all UDP Connections", "code": "ss -ua"}, {"description": "List all Listening UDP Connections", "code": "ss -lu"}, {"description": "Display PID (Process IDs) of Sockets", "code": "ss -p"}, {"description": "Display Summary Statistics", "code": "ss -s"}, {"description": "Display IPv4 and IPv6 Socket Connections", "code": "ss -4 or ss -6"}], "description": "The ss command in linux is used to display network statistics. It is used for dumping socket statistics. It allows showing information similar to netstat. It can display more TCP and state information than other tools."},
{"domain": "linux", "framework": "Kernel", "functionality": "List all loaded drivers, detected devices, print lines of output, search detected device or particular string, clear dmesg buffer logs, monitor dmesg in real time", "api_name": "dmesg", "api_call": "dmesg | more", "api_arguments": "none", "python_environment_requirements": "Python 3.x", "example_code": [{"description": "List all loaded drivers", "code": "dmesg | more"}, {"description": "List all detected devices", "code": "dmesg | grep sda"}, {"description": "Print only first 20 lines of output", "code": "dmesg | head -20"}, {"description": "Print only last 20 lines of output", "code": "dmesg | tail -20"}, {"description": "Search detected device or particular string", "code": "dmesg | grep -i memory"}, {"description": "Clear dmesg buffer logs", "code": "dmesg -c"}, {"description": "Monitoring dmesg in real time", "code": "watch \"dmesg | tail -20\""}], "description": "The dmesg command is a powerful tool available on UNIX and linux systems which is used to print and control the kernel ring buffer. This command is typically used for debugging and analyzing system start-up issues. It provides detailed information about hardware devices and drivers in the system. It can list all loaded drivers, detected devices, print specific lines of output, search for a detected device or a particular string, clear dmesg buffer logs, and monitor dmesg in real time."},
{"domain": "linux", "framework": "SFTP", "functionality": "File transfer, directory manipulation, and shell access on remote servers", "api_name": "SFTP commands", "api_call": "sftp [email\u00a0protected]", "api_arguments": ["username", "hostname"], "python_environment_requirements": "Python not required, SFTP is a command line tool", "example_code": [{"description": "Connect to SFTP", "code": "sftp [email\u00a0protected]"}, {"description": "Get help", "code": "sftp> ?"}, {"description": "Check present working directory", "code": "sftp> lpwd"}, {"description": "Upload file", "code": "sftp> put local.profile"}, {"description": "Download file", "code": "sftp> get SettlementReport_1-10th.xls"}, {"description": "Switch directories", "code": "sftp> cd test"}, {"description": "Create directory", "code": "sftp> mkdir test"}, {"description": "Remove directory", "code": "sftp> rmdir sub1"}, {"description": "Exit SFTP shell", "code": "sftp> !"}], "description": "SFTP (SSH File Transfer Protocol) is a secure file transfer protocol. It runs over the SSH protocol. It supports the full security and authentication functionality of SSH. SFTP has a set of commands that is similar to FTP. Moreover, SFTP is platform-independent and ideal for scripting tasks and for automating file transfer processes."},
{"domain": "linux", "framework": "APT", "functionality": "Package Management", "api_name": "apt-get, apt-cache and dpkg", "api_call": "sudo apt-get install packageName", "api_arguments": ["packageName"], "python_environment_requirements": ["Python", "APT library"], "example_code": [{"description": "Install a specific package", "code": "sudo apt-get install netcat"}, {"description": "Upgrade a specific package", "code": "sudo apt-get install packageName --only-upgrade"}, {"description": "Remove a specific package", "code": "sudo apt-get remove vsftpd"}, {"description": "Search for a package", "code": "apt-cache search vsftpd"}, {"description": "Check package information", "code": "apt-cache show netcat"}, {"description": "Check dependencies for specific packages", "code": "apt-cache showpkg vsftpd"}, {"description": "Check statistics of Cache", "code": "apt-cache stats"}, {"description": "Search for a specific package installed in the system", "code": "sudo apt-cache search apache"}, {"description": "Re-download all installed packages", "code": "sudo dpkg -l | grep '^ii'| awk ' {print $2} ' | xargs sudo apt-get -y install --reinstall --download-only"}], "description": "The apt-get, apt-cache and dpkg commands are part of the APT (Advanced Packaging Tool) library, which is a powerful package management system used by Ubuntu and other Debian-based operating systems. The apt-get command is used to install, upgrade, and remove software packages, while the apt-cache command is used to search the software package cache and collect information about packages. The dpkg command is used to re-download all installed packages. These commands provide a comprehensive way to manage software packages on a linux system."},
{"domain": "linux", "framework": "Command-line interface", "functionality": "File content analysis", "api_name": "wc Command", "api_call": "wc [options] filenames", "api_arguments": ["-l", "-w", "-c", "-m", "-L"], "python_environment_requirements": "No specific requirements", "example_code": [{"description": "Count number of lines in a file", "code": "wc -l tecmint.txt"}, {"description": "Count number of words in a file", "code": "wc -w tecmint.txt"}, {"description": "Count number of characters in a file", "code": "wc -m tecmint.txt"}, {"description": "Count number of bytes in a file", "code": "wc -c tecmint.txt"}, {"description": "Display length of longest line in file", "code": "wc -L tecmint.txt"}], "description": "The wc command in linux provides information about a file in terms of line count, word count, character count and byte count. The available options are -l for line count, -w for word count, -c for byte count, -m for character count and -L for longest line length. This command is useful for file content analysis."},
{"domain": "linux", "framework": "DNS", "functionality": "DNS record querying", "api_name": "dig command", "api_call": "dig yahoo.com", "api_arguments": ["domain_name", "record_type", "options"], "python_environment_requirements": ["dig command installed"], "example_code": [{"description": "Query Domain 'A' Record", "code": "dig yahoo.com"}, {"description": "Query Domain 'A' Record with +short", "code": "dig yahoo.com +short"}, {"description": "Querying MX Record for Domain", "code": "dig yahoo.com MX"}, {"description": "Querying SOA Record for Domain", "code": "dig yahoo.com SOA"}, {"description": "Querying TTL Record for Domain", "code": "dig yahoo.com TTL"}, {"description": "Querying Only Answer Section", "code": "dig yahoo.com +nocomments +noquestion +noauthority +noadditional +nostats"}, {"description": "Querying ALL DNS Records Types", "code": "dig yahoo.com ANY +noall +answer"}, {"description": "DNS Reverse Look-up", "code": "dig -x 72.30.38.140 +short"}, {"description": "Querying Multiple DNS Records", "code": "dig yahoo.com mx +noall +answer redhat.com ns +noall +answer"}, {"description": "Create .digrc file", "code": "dig yahoo.com"}], "description": "The dig command is used to query DNS servers for information. It is a flexible tool for interrogating DNS name servers. It performs DNS lookups and displays the answers that are returned from the name server(s) that were queried. It can be used to grab a host or domain's IP address. By default, it queries the 'A' record for a domain, but you can specify other records such as MX, SOA etc. It also supports reverse look-ups to find the domain name associated with an IP address."},
{"domain": "linux", "framework": "parted", "functionality": "Disk partitioning", "api_name": "Parted API", "api_call": "sudo apt-get install parted", "api_arguments": "None", "python_environment_requirements": "Python 3 and above", "example_code": [{"description": "Install parted on Debian/Ubuntu systems", "code": "$ sudo apt-get install parted"}, {"description": "Check Parted Version", "code": "$ parted"}, {"description": "Exit parted", "code": "$ quit"}, {"description": "List linux Disk Partitions", "code": "(parted) print"}, {"description": "Switch to Different Disk", "code": "(parted) select /dev/sdX"}, {"description": "Create Primary or Logical Partition in linux", "code": "(parted) mkpart"}, {"description": "Resize linux Disk Partition", "code": "(parted) resizepart"}, {"description": "Delete linux Partition", "code": "(parted) rm 1"}, {"description": "Rescue linux Disk Partition", "code": "(parted) rescue"}, {"description": "Change linux Partition Flag", "code": "(parted) set 2 lba on"}], "description": "Parted is a powerful utility that helps manage disk partitions in linux systems. It can be used to check the version, list partitions, switch between disks, create primary or logical partitions, resize partitions, delete partitions, rescue lost partitions, and change partition flags."},
{"domain": "linux", "framework": "os", "functionality": "File and Directory Access", "api_name": "os.listdir", "api_call": "os.listdir(path)", "api_arguments": ["path"], "python_environment_requirements": ["import os"], "example_code": [{"description": "List files and directories in the current directory", "code": "import os\nprint(os.listdir('.'))"}, {"description": "List files and directories in the specified directory", "code": "import os\nprint(os.listdir('/home'))"}], "description": "The os.listdir() function in Python's os module returns a list containing the names of the entries in the directory given by path. This function does not traverse subdirectories, it only provides the names of files and directories in the directory specified."},
{"domain": "linux", "framework": "Command Line", "functionality": "File and Directory Search", "api_name": "Find Command", "api_call": "find / -name filename.txt", "api_arguments": ["Path", "-name or -iname", "Filename or pattern"], "python_environment_requirements": "Python not required", "example_code": [{"description": "Find all the files whose name is tecmint.txt in a current working directory.", "code": "find . -name tecmint.txt"}, {"description": "Find all the files under /home directory with the name tecmint.txt.", "code": "find /home -name tecmint.txt"}, {"description": "Find all the files whose name is tecmint.txt and contains both capital and small letters in /home directory.", "code": "find /home -iname tecmint.txt"}, {"description": "Find all directories whose name is Tecmint in / directory.", "code": "find / -type d -name Tecmint"}, {"description": "Find all php files whose name is tecmint.php in a current working directory.", "code": "find . -type f -name tecmint.php"}, {"description": "Find all php files in a directory.", "code": "find . -type f -name \"*.php\""}], "description": "The 'find' command in linux is a powerful tool that allows you to search for files and directories in a directory hierarchy based on a user given expression and can perform user-specified action on each matched file. The expression can be made up of various search criteria including but not limited to the file name, file size, file type, file permission, etc."},
{"domain": "linux", "framework": "fgrep", "functionality": "Search for fixed string patterns in a file", "api_name": "fgrep", "api_call": "fgrep pattern file", "api_arguments": ["pattern", "file"], "python_environment_requirements": "linux environment", "example_code": [{"description": "Search for a pattern in a file", "code": "fgrep professionals input.txt"}, {"description": "Set Grep Output Color for Matched Patterns", "code": "export GREP_COLOR=32\nfgrep professionals input.txt\nunset GREP_COLOR"}, {"description": "Search for Multiple Patterns in a File", "code": "fgrep -f pattern.txt input.txt"}, {"description": "Limit the Number of Matches in a File", "code": "fgrep -m 1 professionals input.txt"}, {"description": "Print File Name When Searching Pattern", "code": "fgrep -l professionals input.txt"}, {"description": "Print File Name When Pattern Matching Fails", "code": "fgrep -L non-existing-word input.txt"}, {"description": "Suppress Error Messages", "code": "fgrep -s professionals non-existing-file.txt\necho $?"}, {"description": "Exclude Partially Matched Lines", "code": "fgrep -nx \"the same site is sometimes hard to find.\" input.txt"}, {"description": "Exclude Files While Searching Recursively", "code": "fgrep -r --exclude *.txt professionals dir-1"}, {"description": "Exclude Multiple File Types While Searching Recursively", "code": "fgrep -r --exclude-from skip-pattern.txt professionals dir-1"}, {"description": "Include Files While Searching ,Recursively", "code": "fgrep -r --include \"*.txt\" professionals dir-1"}], "description": "The fgrep command is used to search for fixed string patterns in a file. It interprets the pattern as a fixed string instead of a regular expression. It doesn't recognize regular expressions and tries to search for the non-existing pattern. It also has functionalities to set output color for matched patterns, search for multiple patterns in a file, limit the number of matches in a file, print file name when searching pattern, print file name when pattern matching fails, suppress error messages, exclude partially matched lines, exclude files while searching recursively, exclude multiple file types while searching recursively, and include files while searching recursively."},
{"domain": "linux", "framework": "Shell", "functionality": "Locate and manage processes", "api_name": "fuser", "api_call": "fuser [options] [file|socket]", "api_arguments": ["[options]", "[file|socket]"], "python_environment_requirements": "Shell environment", "example_code": [{"description": "Find which process accessing a directory", "code": "fuser ."}, {"description": "Find running processes of directory with verbose output", "code": "fuser -v"}, {"description": "Find which process accessing a file system", "code": "fuser -v -m .bashrc"}, {"description": "Kill a process accessing a file or socket", "code": "sudo fuser -k ."}, {"description": "Interactively kill a process", "code": "sudo fuser -ki ."}, {"description": "List all the signals", "code": "sudo fuser --list-signals"}, {"description": "Send a signal to processes", "code": "sudo fuser -k -SIGNAL"}], "description": "The fuser command in linux is used to identify processes using files or sockets. It can list the process IDs of processes that are using a particular file, directory or socket. It can also be used to kill these processes or send them signals. The fuser command can be used with various options to modify its behavior, such as -v for verbose output, -m to name all processes accessing a file, -k to kill a process, -i for interactive mode, and -SIGNAL to send a specific signal to a process."},
{"domain": "linux", "framework": "Python", "functionality": "Create a symbolic link", "api_name": "os.symlink", "api_call": "os.symlink(src, dst, target_is_directory=False, *, dir_fd=None)", "api_arguments": [{"name": "src", "type": "str", "description": "a string representing the path to the source file"}, {"name": "dst", "type": "str", "description": "a string representing the path where the symbolic link should be created"}, {"name": "target_is_directory", "type": "bool", "default": "False", "description": "a flag indicating whether the target is a directory"}, {"name": "dir_fd", "type": "int", "default": "None", "description": "a file descriptor referring to a directory"}], "python_environment_requirements": [{"name": "os", "version": "Any"}], "example_code": [{"description": "Create a symbolic link pointing to '/path/to/source' at '/path/to/destination'", "code": "import os\nos.symlink('/path/to/source', '/path/to/destination')"}], "description": "The os.symlink() function in Python's os module creates a symbolic link pointing to src named dst. target_is_directory is a boolean that specifies whether dst is expected to be a directory. If dir_fd is not None, it should be a file descriptor referring to a directory, and the path to the file will be relative to that directory. dir_fd may not be implemented on your platform. If it is unavailable, using it will raise a NotImplementedError."},
{"domain": "linux", "framework": "DNS", "functionality": "Domain Name Server troubleshooting", "api_name": "Nslookup", "api_call": "nslookup [option] [name | -] [server]", "api_arguments": ["option", "name", "server"], "python_environment_requirements": "Python 3.x", "example_code": [{"description": "Find out A record (IP address) of Domain", "code": "nslookup yahoo.com"}, {"description": "Find out Reverse Domain Lookup", "code": "nslookup 209.191.122.70"}, {"description": "Find out specific Domain Lookup", "code": "nslookup ir1.fp.vip.mud.yahoo.com."}, {"description": "To Query MX (Mail Exchange) record", "code": "nslookup -query=mx www.yahoo.com"}, {"description": "To query NS(Name Server) record", "code": "nslookup -query=ns www.yahoo.com"}, {"description": "To query SOA (Start of Authority) record", "code": "nslookup -type=soa www.yahoo.com"}, {"description": "To query all Available DNS records", "code": "nslookup -query=any yahoo.com"}, {"description": "Enable Debug mode", "code": "nslookup -debug yahoo.com"}], "description": "Nslookup is a network administration command-line tool available for many computer operating systems. It is used for querying the Domain Name System (DNS) to obtain domain name or IP address mapping, or other DNS records. The tool is handy for troubleshooting DNS server responses. The examples provided demonstrate how to find the A record (IP address) of a domain, perform a reverse domain lookup, query specific domain lookup, query MX (Mail Exchange) record, query NS (Name Server) record, query SOA (Start of Authority) record, query all available DNS records, and enable debug mode."},
{"domain": "linux", "framework": "Networking", "functionality": "Network Management", "api_name": "Netstat", "api_call": "netstat -a", "api_arguments": ["-a"], "python_environment_requirements": [], "example_code": [{"description": "Listing all the LISTENING Ports of TCP and UDP Connections", "code": "netstat -a"}, {"description": "Listing TCP Ports connections", "code": "netstat -at"}, {"description": "Listing UDP Ports connections", "code": "netstat -au"}, {"description": "Listing all LISTENING Connections", "code": "netstat -l"}, {"description": "Listing all TCP Listening Ports", "code": "netstat -lt"}, {"description": "Listing all UDP Listening Ports", "code": "netstat -lu"}, {"description": "Listing all UNIX Listening Ports", "code": "netstat -lx"}, {"description": "Showing Statistics by Protocol", "code": "netstat -s"}, {"description": "Showing Statistics by TCP Protocol", "code": "netstat -st"}, {"description": "Showing Statistics by UDP Protocol", "code": "netstat -su"}, {"description": "Displaying Service name with PID", "code": "netstat -tp"}, {"description": "Displaying Promiscuous Mode", "code": "netstat -ac 5"}, {"description": "Displaying Kernel IP routing", "code": "netstat -r"}, {"description": "Showing Network Interface Transactions", "code": "netstat -i"}, {"description": "Showing Kernel Interface Table", "code": "netstat -ie"}, {"description": "Displaying IPv4 and IPv6 Information", "code": "netstat -g"}, {"description": "Print Netstat Information Continuously", "code": "netstat -c"}, {"description": "Finding non-supportive Address", "code": "netstat --verbose"}, {"description": "Finding Listening Programs", "code": "netstat -ap"}, {"description": "Displaying RAW Network Statistics", "code": "netstat --statistics --raw"}], "description": "Netstat is a command-line utility that can be used to monitor network connections on a linux system. It provides information about the state of network connections, routing tables, interface statistics, masquerade connections, and multicast memberships. The utility is commonly used for troubleshooting network issues and verifying the security of network connections."},
{"domain": "linux", "framework": "System Monitoring", "functionality": "Monitor Swap Space Usage", "api_name": "Swap Space Usage Monitoring Commands", "api_call": "swapon --summary", "api_arguments": ["--all", "--summary"], "python_environment_requirements": "Python not required", "example_code": [{"description": "Check Swap Usage", "code": "swapon --summary"}], "description": "Swap space is a restricted amount of physical memory that is allocated for use by the operating system when available memory has been fully utilized. Swap space usage can be monitored using various commands and tools in linux such as 'swapon', '/proc/swaps', 'free', 'top', 'atop', 'htop', 'glances', and 'vmstat'."},
{"domain": "linux", "framework": "OS", "functionality": "Reading environment variables", "api_name": "os.environ", "api_call": "os.environ.get('HOME')", "api_arguments": [{"name": "key", "type": "string", "description": "The name of the environment variable"}], "python_environment_requirements": ["os"], "example_code": [{"description": "Get the value of the 'HOME' environment variable", "code": "print(os.environ.get('HOME'))"}, {"description": "Get the value of the 'PATH' environment variable", "code": "print(os.environ.get('PATH'))"}], "description": "The os.environ object in Python is a mapping object that represents the user\u2019s environmental variables. It returns the value of the environment variable key if it exists, and if it does not exist, it returns the default value."},
{"domain": "linux", "framework": "Debian", "functionality": "Package Management", "api_name": "dpkg", "api_call": "dpkg [options] [commands]", "api_arguments": ["-i", "-l", "-r", "-c", "-s", "-L", "-R", "--install", "--unpack", "--configure", "--update-avail", "--clear-avail", "--forget-old-unavail", "--licence", "--version", "--help"], "python_environment_requirements": "Python is not required for this API", "example_code": [{"description": "Install a Package", "code": "dpkg -i flashpluginnonfree_2.8.2+squeeze1_i386.deb"}, {"description": "List all the installed Packages", "code": "dpkg -l"}, {"description": "Remove a Package", "code": "dpkg -r flashpluginnonfree"}, {"description": "View the Content of a Package", "code": "dpkg -c flashplugin-nonfree_3.2_i386.deb"}, {"description": "Check a Package is installed or not", "code": "dpkg -s flashplugin-nonfree"}, {"description": "Check the location of Packages installed", "code": "dpkg -L flashplugin-nonfree"}, {"description": "Install all Packages from a Directory", "code": "dpkg -R --install debpackages/"}, {"description": "Unpack the Package but don\u2019t Configure", "code": "dpkg --unpack flashplugin-nonfree_3.2_i386.deb"}, {"description": "Reconfigure a Unpacked Package", "code": "dpkg --configure flashplugin-nonfree"}, {"description": "Replace available Package information", "code": "dpkg \u2013-update-avail package_name"}, {"description": "Erase Existing Available information of Package", "code": "dpkg \u2013-clear-avail"}, {"description": "Forget Uninstalled and Unavailable Packages", "code": "dpkg --forget-old-unavail"}, {"description": "Display dpkg Licence", "code": "dpkg --licence"}, {"description": "Display dpkg Version", "code": "dpkg \u2013version"}, {"description": "Get all the Help about dpkg", "code": "dpkg \u2013help"}], "description": "dpkg is the main package management program in Debian and Debian based System. It is used to install, build, remove, and manage packages. Aptitude is the primary front-end to dpkg. It allows you to install packages, view installed packages, remove packages, view the content of a package, check if a package is installed or not, check the location of installed packages, install all packages from a directory, unpack a package but don't configure it, reconfigure an unpacked package, replace available package information, erase existing available information of a package, forget uninstalled and unavailable packages, display dpkg license, display dpkg version, and get all the help about dpkg."},
{"domain": "linux", "framework": "Command Line", "functionality": "Display System Memory", "api_name": "Free Command", "api_call": "free", "api_arguments": ["-b", "-k", "-m", "-g", "-t", "-o", "-s", "-l", "-V"], "python_environment_requirements": "Python not required, this is a linux command line operation", "example_code": [{"description": "Display Memory in Bytes", "code": "free -b"}, {"description": "Display Memory in Kilo Bytes", "code": "free -k"}, {"description": "Display Memory in Megabytes", "code": "free -m"}, {"description": "Display Memory in Gigabytes", "code": "free -g"}, {"description": "Display Total Line", "code": "free -t"}, {"description": "Disable Display of Buffer Adjusted Line", "code": "free -o"}, {"description": "Display Memory Status for Regular Intervals", "code": "free -s 5"}, {"description": "Show Low and High Memory Statistics", "code": "free -l"}, {"description": "Check Free Version", "code": "free -V"}], "description": "The Free command in linux is used to check the used and available space of physical memory and swap memory. It can display the memory size in different formats such as Bytes, Kilobytes, Megabytes, Gigabytes. It also provides options to display total memory, disable buffer adjusted line, display memory status at regular intervals, show low and high memory statistics and check the version of the Free command."},
{"domain": "linux", "framework": "Crontab", "functionality": "Task scheduling", "api_name": "Crontab Commands", "api_call": "crontab -l", "api_arguments": ["-l", "-e", "-u", "-r", "-i", "&&"], "python_environment_requirements": "Python not required", "example_code": [{"description": "List Crontab Entries", "code": "crontab -l"}, {"description": "Edit Crontab Entries", "code": "crontab -e"}, {"description": "List Scheduled Cron Jobs of User", "code": "crontab -u tecmint -l"}, {"description": "Remove Crontab Entry", "code": "crontab -r"}, {"description": "Prompt Before Deleting Crontab", "code": "crontab -i -r"}, {"description": "Schedule a Job for a Specific Time", "code": "crontab -e\n30 0 * * * root find /tmp -type f -empty -delete"}, {"description": "Multiple Commands with Double ampersand(&&)", "code": "crontab -e\n@daily <command1> && <command2>"}, {"description": "Disable Email Notifications", "code": "crontab -e\n* * * * * >/dev/null 2>&1"}], "description": "Crontab is a linux utility which allows you to schedule a particular script or command to run automatically at a specific time/date. It is used for scheduling tasks to run in the background. Crontab files can be used to automate backups, system maintenance and other repetitive tasks. The commands in the crontab file are checked by the cron daemon, which executes them in the system background."},
{"domain": "linux", "framework": "fdisk", "functionality": "Disk Partitioning", "api_name": "fdisk", "api_call": "fdisk -l", "api_arguments": "-l for listing all partitions, /dev/sda for specific disk, -s for size of partition", "python_environment_requirements": "Python subprocess module", "example_code": [{"description": "View all Disk Partitions", "code": "fdisk -l"}, {"description": "View Specific Disk Partition", "code": "fdisk -l /dev/sda"}, {"description": "Check all Available fdisk Commands", "code": "fdisk /dev/sda"}, {"description": "Print all Partition Table", "code": "fdisk /dev/sda"}, {"description": "Delete a Partition", "code": "fdisk /dev/sda"}, {"description": "Create a New Partition", "code": "fdisk /dev/sda"}, {"description": "Format a Partition", "code": "mkfs.ext4 /dev/sda4"}, {"description": "Check Size of a Partition", "code": "fdisk -s /dev/sda2"}, {"description": "Fix Partition Table Order", "code": "fdisk /dev/sda"}, {"description": "Disable Boot Flag of a Partition", "code": "fdisk /dev/sda"}], "description": "The fdisk is a command-line utility that provides disk partitioning functions for linux. It allows you to view, create, resize, delete, change, copy and move partitions on a hard drive using its own user-friendly text-based menu. It's used as a powerful tool for managing disk partitions, ensuring efficient use of disk storage, separating operating systems and data, duplicating data, and many more."},
{"domain": "linux", "framework": "linux Command Line", "functionality": "File and File System Status Check", "api_name": "stat", "api_call": "stat /var/log/syslog", "api_arguments": [{"name": "file", "type": "string", "description": "The file or directory to check the status of."}, {"name": "-f", "type": "flag", "description": "Display file system status instead of file status."}, {"name": "-L", "type": "flag", "description": "Enable stat to follow links."}, {"name": "--printf", "type": "flag", "description": "Use a particular or custom format instead of the default."}, {"name": "-t", "type": "flag", "description": "Print the information in terse form."}], "python_environment_requirements": [], "example_code": [{"description": "Check the status of a file", "code": "stat /var/log/syslog"}, {"description": "Check the status of a file system", "code": "stat -f /var/log/syslog"}, {"description": "Enable stat to follow links", "code": "stat -L /"}, {"description": "Use a custom format to display information", "code": "stat --printf='%U\n%G\n%C\n%z\n' /var/log/secure"}, {"description": "Print information in terse form", "code": "stat -t /var/log/syslog"}], "description": "The 'stat' command in linux is used to check the status of a file or file system. It can display information such as the size, blocks, IO blocks, file type, inode value, number of links and much more. The command can also be customized to follow links, display file system status, use a custom format, and print information in a terse form."},
{"domain": "linux", "framework": "ls command", "functionality": "Listing and sorting directory contents", "api_name": "ls command functionalities", "api_call": "ls [options] [file|dir]", "api_arguments": ["-l", "--time-style", "--full-time", "--format", "-p", "--sort", "-n", "--width", "--tabsize"], "python_environment_requirements": "linux operating system", "example_code": [{"description": "List the contents of a directory with full-iso time style", "code": "ls -l --time-style=full-iso"}, {"description": "Output the contents of a directory in comma format", "code": "ls --format=comma"}, {"description": "Append indicators to directory content", "code": "ls -p"}, {"description": "Sort the contents of directory by size", "code": "ls --sort=size"}, {"description": "Print numeric UID and GID for directory contents", "code": "ls -n"}, {"description": "Print the contents of a directory on standard output in more columns than default", "code": "ls --width 100"}, {"description": "Include manual tab size at the contents of directory", "code": "ls --tabsize=10"}], "description": "The `ls` command in linux provides a variety of functionalities for listing and sorting the contents of a directory. It supports different time styles, output formats, appending indicators to the contents, sorting by extension, size, time and version, printing numeric UID and GID, controlling the number of output columns, and setting manual tab size."},
{"domain": "linux", "framework": "host command", "functionality": "Querying DNS Lookups", "api_name": "linux host command", "api_call": "host google.com", "api_arguments": ["-t", "-n", "-C", "-a", "-v", "-4", "-6", "-rR", "-R", "-T", "-W"], "python_environment_requirements": "linux environment", "example_code": [{"description": "Find the Domain IP Address", "code": "host google.com"}, {"description": "Find Domain Name Servers", "code": "host -t ns google.com"}, {"description": "Find Domain CNAME Record", "code": "host -t cname mail.google.com"}, {"description": "Find Domain MX Record", "code": "host -n -t mx google.com"}, {"description": "Find Domain TXT Record", "code": "host -t txt google.com"}, {"description": "Find Domain SOA Record", "code": "host -C google.com"}, {"description": "Query Particular Name Server", "code": "host google.com ns4.google.com"}, {"description": "Find All Information of Domain Records and Zones", "code": "host -a google.com"}, {"description": "Get Domain TTL Information", "code": "host -v -t a google.com"}, {"description": "Use Either IPv4 or IPv6", "code": "host -4 google.com OR host -6 google.com"}, {"description": "Perform Non-Recursive Queries", "code": "host -rR 5 google.com"}, {"description": "Set UDP Retries for a Lookup", "code": "host -R 5 google.com"}, {"description": "Set Query Time Wait for Reply", "code": "host -T -W 10 google.com"}], "description": "The host command in linux is used for DNS (Domain Name System) lookup operations. In simple terms, it's a tool that translates domain names into IP addresses. It can be used to find IP addresses of domains, find the mail server of a domain, find domain name servers, and so on."},
{"domain": "linux", "framework": "Python", "functionality": "Returns the current working directory", "api_name": "getcwd", "api_call": "os.getcwd()", "api_arguments": [], "python_environment_requirements": ["os"], "example_code": [{"description": "Get the current working directory", "code": "import os\nprint(os.getcwd())"}], "description": "The getcwd API in Python's os module returns a string representing the current working directory. This is the directory from which the Python script is being executed."},
{"domain": "linux", "framework": "os", "functionality": "Get the current working directory", "api_name": "getcwd", "api_call": "os.getcwd()", "api_arguments": [], "python_environment_requirements": ["os"], "example_code": [{"description": "Get the current working directory", "code": "import os\nprint(os.getcwd())"}], "description": "The os.getcwd() function in Python's os module returns the current working directory. This is the directory from which python scripts are run. Note that the os module needs to be imported before this function can be used."},
{"domain": "linux", "framework": "Shell", "functionality": "Show difference between two files", "api_name": "sdiff", "api_call": "sdiff file1.txt file2.txt", "api_arguments": ["file1", "file2"], "python_environment_requirements": ["linux shell"], "example_code": [{"description": "Run sdiff to compare two files", "code": "$ sdiff du.txt cal.txt"}, {"description": "Ignore all white space while comparing", "code": "$ sdiff -W du.txt cal.txt"}, {"description": "Ignore case while comparing", "code": "$ sdiff -i du.txt cal.txt"}, {"description": "Ignore blank line in files", "code": "$ sdiff -B du.txt cal.txt"}, {"description": "Set the number of columns to be printed", "code": "$ sdiff -w 150 du.txt cal.txt"}, {"description": "Expand tabs to spaces in output", "code": "$ sdiff -t du.txt cal.txt"}, {"description": "Run sdiff interactively and send output to a file", "code": "$ sdiff du.txt cal.txt -o sdiff.txt"}, {"description": "Call another command-line tool to compare files", "code": "$ sdiff --diff-program=diff du.txt cal.txt"}], "description": "The 'sdiff' command in linux is used to compare two files and show the differences side-by-side. This command has several options that allow you to ignore white spaces, case, and blank lines, set the number of columns to be printed, expand tabs to spaces in output, run interactively and send output to a file, and call another command-line tool to compare files."},
{"domain": "linux", "framework": "tcpdump", "functionality": "Packet capturing and network monitoring", "api_name": "tcpdump", "api_call": "tcpdump -i eth0", "api_arguments": ["-i (interface)", "-c (count)", "-A (ASCII)", "-D (display interfaces)", "-XX (HEX and ASCII)", "-w (write)", "-r (read)", "-n (no name resolution)", "tcp (TCP packets)", "port (specific port)", "src (source IP)", "dst (destination IP)"], "python_environment_requirements": "Python not required", "example_code": [{"description": "Capture Packets from Specific Interface", "code": "tcpdump -i eth0"}, {"description": "Capture Only N Number of Packets", "code": "tcpdump -c 5 -i eth0"}, {"description": "Print Captured Packets in ASCII", "code": "tcpdump -A -i eth0"}, {"description": "Display Available Interfaces", "code": "tcpdump -D"}, {"description": "Display Captured Packets in HEX and ASCII", "code": "tcpdump -XX -i eth0"}, {"description": "Capture and Save Packets in a File", "code": "tcpdump -w 0001.pcap -i eth0"}, {"description": "Read Captured Packets File", "code": "tcpdump -r 0001.pcap"}, {"description": "Capture IP Address Packets", "code": "tcpdump -n -i eth0"}, {"description": "Capture only TCP Packets", "code": "tcpdump -i eth0 tcp"}, {"description": "Capture Packet from Specific Port", "code": "tcpdump -i eth0 port 22"}, {"description": "Capture Packets from source IP", "code": "tcpdump -i eth0 src 192.168.0.2"}, {"description": "Capture Packets from destination IP", "code": "tcpdump -i eth0 dst 50.116.66.139"}], "description": "The tcpdump tool is a command line packet capture utility on linux. It allows users to capture network packets on specific interfaces, filter packets based on IP addresses, ports, protocols etc., and analyze the captured packets. It's a very useful tool for network troubleshooting and understanding network protocols."},
{"domain": "linux", "framework": "linux API", "functionality": "Change file attributes", "api_name": "chattr", "api_call": "chattr [operator] [flags] [filename]", "api_arguments": ["operator: +, -, =", "flags: A, S, a, i, j, t, d, u", "filename: name of the file"], "python_environment_requirements": "linux environment", "example_code": [{"description": "Set immutable bit on the files", "code": "chattr +i demo/ important_file.conf"}, {"description": "Verify the attribute with command 'lsattr'", "code": "lsattr"}, {"description": "Unset attribute", "code": "chattr -i demo/ important_file.conf"}, {"description": "Set immutable attribute on files /etc/passwd or /etc/shadow", "code": "chattr +i /etc/passwd chattr +i /etc/shadow"}, {"description": "Allow everyone to just append data on a file without changing or modifying already entered data", "code": "chattr +a example.txt"}, {"description": "Unset the append attribute", "code": "chattr -a example.txt"}, {"description": "Secure entire directory and its files", "code": "chattr -R +i myfolder"}, {"description": "Unset permission", "code": "chattr -R -i myfolder"}], "description": "The chattr command in linux is used to change file attributes. It supports various attributes and flags that can be set/unset on a file. The operator can be + to add the attribute, - to remove the attribute, or = to keep the existing attributes. Some of the attributes include 'A' for not updating atime record when a file is accessed, 'S' for updating changes synchronously on the disk when a file is modified, 'a' for opening a file only in append mode for writing, 'i' for making a file immutable, and so on. The command also supports recursive operation on directories with the -R option."},
{"domain": "linux", "framework": "Networking", "functionality": "Network configuration and troubleshooting", "api_name": "linux Networking Commands", "api_call": "N/A", "api_arguments": "N/A", "python_environment_requirements": "N/A", "example_code": [{"description": "View IP Address and Hardware / MAC address assign to interface and also MTU (Maximum transmission unit) size", "code": "# ifconfig"}, {"description": "View specific interface details", "code": "# ifconfig eth0"}, {"description": "Assign IP Address and Gateway to the interface", "code": "# ifconfig eth0 192.168.50.5 netmask 255.255.255.0"}, {"description": "Enable specific Interface", "code": "# ifup eth0"}, {"description": "Disable specific Interface", "code": "# ifdown eth0"}, {"description": "Set MTU Size", "code": "# ifconfig eth0 mtu XXXX"}, {"description": "Set Interface in Promiscuous Mode", "code": "# ifconfig eth0 - promisc"}, {"description": "Ping a hostname or ip address", "code": "# ping 4.2.2.2"}, {"description": "Ping with -c option exit after N number of requests", "code": "# ping -c 5 www.tecmint.com"}], "description": "This is a set of linux commands used for network configuration and troubleshooting. It includes commands to view and set network interface details, enable or disable interfaces, set MTU size, ping a hostname or IP address, and more. Some of these commands have been replaced by modern alternatives in recent linux distributions."},
{"domain": "linux", "framework": "Command Line", "functionality": "File and Directory Synchronization", "api_name": "Rsync Command", "api_call": "rsync options source destination", "api_arguments": ["options: additional parameters to modify the command behavior", "source: the file or directory to copy from", "destination: the file or directory to copy to"], "python_environment_requirements": "Python is not required for this API", "example_code": [{"description": "Copy a file on a local computer", "code": "rsync -zvh backup.tar.gz /tmp/backups/"}, {"description": "Copy a directory on a local computer", "code": "rsync -avzh /root/rpmpkgs /tmp/backups/"}, {"description": "Copy a directory from local server to a remote server", "code": "rsync -avzh /root/rpmpkgs [email\u00a0protected]:/root/"}, {"description": "Copy a remote directory to a local machine", "code": "rsync -avzh [email\u00a0protected]:/root/rpmpkgs /tmp/myrpms"}], "description": "The Rsync command in linux is used for copying and synchronizing files and directories locally and remotely. It is faster than scp (Secure Copy) because rsync uses a remote-update protocol which allows transferring just the differences between two sets of files. It also supports copying links, devices, owners, groups, and permissions, and consumes less bandwidth as it uses compression and decompression method while sending and receiving data."},
{"domain": "linux", "framework": "Shell", "functionality": "Create device files and pipes", "api_name": "mknod", "api_call": "$ mknod [OPTIONS] [MAJOR] [MINOR]", "api_arguments": ["OPTIONS", "MAJOR", "MINOR"], "python_environment_requirements": "Shell environment", "example_code": [{"description": "Create a named pipe", "code": "$ mknod /tmp/named-pipe p"}, {"description": "Create a character device file", "code": "$ sudo mknod /tmp/full-device c 1 7"}, {"description": "Create a block device file", "code": "$ sudo mknod /tmp/dvd-rom b 11 0"}, {"description": "Create a device file with permissions", "code": "$ sudo mknod -m 444 /tmp/pipe-with-permissions p"}], "description": "The mknod command in linux is used for creating special file types. These include character devices, block devices, and named pipes. The command takes options and major and minor numbers as arguments. The major number specifies the device driver to be used, and the minor number specifies the actual device. The command is versatile and can be used for inter-process communication, creating character and block devices, and setting file permissions."},
{"domain": "linux", "framework": "fsck", "functionality": "File System Check and Repair", "api_name": "fsck Command", "api_call": "fsck /dev/sdb", "api_arguments": ["-A", "-C", "-l", "-M", "-N", "-P", "-R", "-r", "-T", "-t", "-V"], "python_environment_requirements": "Python not required. It's a linux command line tool.", "example_code": [{"description": "Run fsck on a specific partition", "code": "fsck /dev/sdb"}, {"description": "Run fsck on all filesystems without root", "code": "fsck -AR -y"}], "description": "The fsck command in linux is used to check and repair file system inconsistencies. It can be used in several scenarios such as when the system fails to boot, files become corrupt, or an attached drive is not working as expected. The command needs to be run with superuser privileges or root and can be used with different arguments depending on the specific case. The partition to be checked should not be mounted."},
{"domain": "linux", "framework": "Shell", "functionality": "File and Directory Deletion", "api_name": "rm", "api_call": "rm [options] [file|dir]", "api_arguments": ["-r or -R: remove directories and their contents recursively", "-f: ignore nonexistent files, never prompt", "-i: prompt before every removal", "-v: explain what is being done"], "python_environment_requirements": "linux Shell", "example_code": [{"description": "Remove a single file", "code": "rm tecmint.txt"}, {"description": "Remove multiple files", "code": "rm tecmint.txt fossmint.txt"}, {"description": "Remove a directory recursively", "code": "rm -R tecmint_files/"}, {"description": "Prompt for confirmation while deleting a file", "code": "rm -i tecmint.txt"}, {"description": "Prompt for confirmation while deleting a directory and its sub-directories", "code": "rm -Ri tecmint_files/"}, {"description": "Forcefully remove a file", "code": "rm -f tecmint.txt"}, {"description": "Recursively and forcibly remove a directory and its contents without prompting for confirmation", "code": "rm -rf fossmint_files"}, {"description": "Show more information when deleting a file or directory", "code": "rm -rv fossmint_files"}, {"description": "Clear everything on your root(/) partition", "code": "rm -rf /"}], "description": "The rm command in linux is used to remove files and directories. It can be used with various options to perform different deletion operations like removing files and directories recursively, prompting for confirmation before deletion, forcefully removing files and directories, and providing verbose output. It should be used with caution as it can lead to loss of data."},
{"domain": "linux", "framework": "SCP", "functionality": "Securely transfer files", "api_name": "SCP Command", "api_call": "scp source_file_name [email protected]_host:destination_folder", "api_arguments": ["source_file_name", "username", "destination_host", "destination_folder"], "python_environment_requirements": "Python 3.x", "example_code": [{"description": "Copy file from local host to remote server", "code": "scp -v scp-cheatsheet.pdf [email protected]:/home/tecmint/."}, {"description": "Copy file from remote host to local host", "code": "scp -v [email protected]:/home/ravi/ssh-cheatsheet.pdf /home/tecmint/."}, {"description": "Copy file from remote host to another host", "code": "scp -v [email protected]:/home/ravi/ssh-cheatsheet.pdf [email protected]:/home/anusha/."}], "description": "The SCP (Secure Copy) command in linux is used to copy files and directories between hosts on a network. It uses the same authentication and security as the Secure Shell (SSH) protocol. SCP allows files to be copied to, from, or between different hosts. It uses SSH for data transfer and provides the same authentication and same level of security as SSH."},
{"domain": "linux", "framework": "Grep", "functionality": "Searching specific types of characters in a file", "api_name": "Grep Search Commands", "api_call": "$ grep \"^[[:alnum:]]\" tecmint.txt", "api_arguments": ["^[[:alnum:]]", "tecmint.txt"], "python_environment_requirements": "linux OS, Grep", "example_code": [{"description": "Search Alphanumeric Characters", "code": "$ grep \"^[[:alnum:]]\" tecmint.txt"}, {"description": "Search Alpha Characters", "code": "$ grep \"^[[:alpha:]]\" tecmint.txt"}, {"description": "Search Blank Characters", "code": "$ grep \"^[[:blank:]]\" tecmint.txt"}, {"description": "Search Digit Characters", "code": "$ grep \"^[[:digit:]]\" tecmint.txt"}, {"description": "Search Lower Letters", "code": "$ grep \"^[[:lower:]]\" tecmint.txt"}, {"description": "Search Punctuation Characters", "code": "$ grep \"^[[:punct:]]\" tecmint.txt"}, {"description": "Search Graphical Characters", "code": "$ grep \"^[[:graph:]]\" tecmint.txt"}, {"description": "Search Printable Characters", "code": "$ grep \"^[[:print:]]\" tecmint.txt"}, {"description": "Search Space Characters", "code": "$ grep \"^[[:space:]]\" tecmint.txt"}, {"description": "Search Uppercase Letters", "code": "$ grep \"^[[:upper:]]\" tecmint.txt"}, {"description": "Search Hexadecimal Digits", "code": "$ grep \"^[[:xdigit:]]\" tecmint.txt"}], "description": "The Grep command in linux is used to search text or search the given file for lines containing a match to the given strings or words. By using the grep command, you can customize how the tool searches for a pattern or multiple patterns in this case. These examples demonstrate how you can search for lines in a file that start with certain types of characters."},
{"domain": "linux", "framework": "Bash", "functionality": "Run a command from history using command numbers", "api_name": "History command", "api_call": "$ history", "api_arguments": "None", "python_environment_requirements": "Bash shell", "example_code": [{"description": "Run a command from history by its command number", "code": "$ !1551"}], "description": "The history command in linux allows you to run a command from your history of already executed commands. The '!' symbol followed by the command number allows you to run a specific command from your history. The actual command number may vary depending on your command history. You can use the history command to view the list of commands along with their line numbers."},
{"domain": "linux", "framework": "Command Line", "functionality": "File and directory deletion", "api_name": "rm -rf / Command", "api_call": "rm -rf /", "api_arguments": [{"argument": "-rf", "description": "Force deletion of everything in the root directory."}], "python_environment_requirements": "Python OS module", "example_code": [{"description": "Deleting all files and directories in the root directory", "code": "import os\nos.system('rm -rf /')"}], "description": "The rm -rf / command in linux is used to delete all files and directories from the root directory. This command should be used with extreme caution as it can result in a broken and unrecoverable system."},
{"domain": "linux", "framework": "usermod", "functionality": "Modify user accounts", "api_name": "Usermod", "api_call": "usermod [options] LOGIN", "api_arguments": ["-c: Add comment field for the user account", "-d: Modify the directory for any existing user account", "-e: Make the account expiry in specific period", "-g: Change the primary group for a User", "-G: Add a supplementary groups", "-a: Add anyone of the group to a secondary group", "-l: Change the login name", "-L: Lock the user account", "-m: Move the contents of the home directory from existing home dir to new dir", "-p: Use un-encrypted password for the new password", "-s: Create a Specified shell for new accounts", "-u: Assign UID for the user account between 0 to 999", "-U: Unlock the user accounts"], "python_environment_requirements": ["Root access", "Existing user accounts", "Knowledge of usermod command"], "example_code": [{"description": "Adding Information to User Account", "code": "usermod -c 'This is Tecmint' tecmint"}, {"description": "Change User Home Directory", "code": "usermod -d /var/www/ tecmint"}, {"description": "Set User Account Expiry Date", "code": "usermod -e 2014-11-01 tecmint"}, {"description": "Change User Primary Group", "code": "usermod -g babin tecmint_test"}, {"description": "Adding Group to an Existing User", "code": "usermod -G tecmint_test0 tecmint"}], "description": "The usermod command in linux is a powerful command used to modify user accounts in a linux system. It provides a variety of options allowing you to change various attributes of a user account, such as the home directory, shell, password, and much more. This command requires root access and should be used with caution as improper use can lead to critical system errors."},
{"domain": "linux", "framework": "File and Time Management", "functionality": "Determining file type and managing system time", "api_name": "File Type and Time Management Commands", "api_call": "file <filename>", "api_arguments": "<filename>", "python_environment_requirements": "Python 2.7 or higher, linux OS", "example_code": [{"description": "Determining the type of a file", "code": "file master.zip"}, {"description": "Set system time", "code": "sudo date -s '12:27:00'"}, {"description": "View hardware clock time", "code": "sudo hwclock"}, {"description": "Set hardware clock time", "code": "sudo hwclock --set --date='09/09/2015 12:33:00'"}, {"description": "Count number of regular files", "code": "ls -l | grep ^- | wc -l"}], "description": "The linux API provides functionalities for determining the type of a file and managing system time. The 'file' command is used to determine the type of a file. The 'date' command is used to view and set the system time, while the 'hwclock' command is used to view and set the hardware clock time. The API also provides commands for counting the number of specific types of files in a directory."},
{"domain": "linux", "framework": "lsb_release", "functionality": "Prints distribution-specific information", "api_name": "lsb_release", "api_call": "lsb_release -a", "api_arguments": ["-a"], "python_environment_requirements": [], "example_code": [{"description": "Print all the available information in respect of version, id, description, release and codename.", "code": "lsb_release -a"}], "description": "The lsb_release command is used to print distribution-specific information. When the '-a' option is used, it shows all the available information in respect of version, id, description, release and codename."},
{"domain": "linux", "framework": "MySQL", "functionality": "Database backup and restore", "api_name": "mysqldump and mysql", "api_call": "mysqldump -u [username] -p[password] [database_name] > [dump_file.sql]", "api_arguments": ["username", "password", "database_name", "dump_file.sql"], "python_environment_requirements": "MySQL server", "example_code": [{"description": "Backup a single MySQL Database", "code": "mysqldump -u root -ptecmint rsyslog > rsyslog.sql"}, {"description": "Backup multiple MySQL Databases", "code": "mysqldump -u root -ptecmint --databases rsyslog syslog > rsyslog_syslog.sql"}, {"description": "Backup all MySQL Databases", "code": "mysqldump -u root -ptecmint --all-databases > all-databases.sql"}, {"description": "Backup MySQL Database structure only", "code": "mysqldump -u root -ptecmint --no-data rsyslog > rsyslog_structure.sql"}, {"description": "Backup MySQL Database data only", "code": "mysqldump -u root -ptecmint --no-create-db --no-create-info rsyslog > rsyslog_data.sql"}, {"description": "Backup a single table of Database", "code": "mysqldump -u root -ptecmint wordpress wp_posts > wordpress_posts.sql"}, {"description": "Backup multiple tables of Database", "code": "mysqldump -u root -ptecmint wordpress wp_posts wp_comments > wordpress_posts_comments.sql"}, {"description": "Backup remote MySQL Database", "code": "mysqldump -h 172.16.25.126 -u root -ptecmint gallery > gallery.sql"}, {"description": "Restore single MySQL Database", "code": "mysql -u root -ptecmint rsyslog < rsyslog.sql"}], "description": "The mysqldump utility is a command-line tool to perform backup and restore operations on a MySQL database. It creates a SQL script file that can be used to recreate the database structure and data. The mysql command is used to restore a MySQL database from a backup file."},
{"domain": "linux", "framework": "sdiff", "functionality": "Show difference between two files", "api_name": "sdiff", "api_call": "$ sdiff file1.txt file2.txt", "api_arguments": ["-a", "-W", "-z", "-E", "-i", "-B", "-w", "-t", "-o", "--diff-program"], "python_environment_requirements": ["linux Terminal"], "example_code": [{"description": "Running sdiff with two filenames", "code": "$ sdiff du.txt cal.txt"}, {"description": "Treat all files as text files", "code": "$ sdiff -a du.txt cal.txt"}, {"description": "Ignore all white space while comparing", "code": "$ sdiff -W du.txt cal.txt"}, {"description": "Ignore any white space at line end", "code": "$ sdiff -z du.txt cal.txt"}, {"description": "Ignore changes due to tab expansion", "code": "$ sdiff -E du.txt cal.txt"}, {"description": "Ignore case while comparing difference", "code": "$ sdiff -i du.txt cal.txt"}, {"description": "Ignore blank line in files", "code": "$ sdiff -B du.txt cal.txt"}, {"description": "Set the number of columns to be printed", "code": "$ sdiff -w 150 du.txt cal.txt"}, {"description": "Expand tabs to spaces in output", "code": "$ sdiff -t du.txt cal.txt"}, {"description": "Run sdiff interactively and send output to a file", "code": "$ sdiff du.txt cal.txt -o sdiff.txt"}, {"description": "Call another command-line tool to compare files", "code": "$ sdiff --diff-program=diff du.txt cal.txt"}], "description": "The sdiff command in linux is used to compare and show the differences between two files. It displays a side-by-side comparison of the contents of file1 and file2. Lines common to both files are shown in the center, lines only in file1 are shown in the left column, and lines only in file2 are shown in the right column. The command provides several options to customize the comparison like ignoring case, whitespace, blank lines, setting number of columns for output, and even calling another program for comparison."},
{"domain": "linux", "framework": "Command Line", "functionality": "File Manipulation", "api_name": "cat command", "api_call": "cat [OPTION]... [FILE]...", "api_arguments": ["OPTION", "FILE"], "python_environment_requirements": "N/A", "example_code": [{"description": "Display contents of a file", "code": "cat Documents/tecmint1.txt"}, {"description": "Display contents of multiple files", "code": "cat tecmint1.txt tecmint2.txt"}, {"description": "Create a new file and save content in it", "code": "cat > Tecmint_tutorial.txt"}, {"description": "Append content to an existing file", "code": "cat >> Tecmint_tutorial.txt"}, {"description": "Copy file content to another file", "code": "cat Tecmint_tutorial.txt > New_file.txt"}, {"description": "Concatenate contents of multiple files into one file", "code": "cat tecmint1.txt tecmint2.txt > cat_tecmint.txt"}, {"description": "View file content with line endings", "code": "cat -E cat_tecmint.txt"}, {"description": "List contents of all specified file types", "code": "cat *.txt"}, {"description": "Display line numbers in file", "code": "cat -n Fruits.txt"}, {"description": "Print line numbers of multiple files", "code": "cat -n Fruits.txt veg.txt"}, {"description": "Show file contents with tab characters", "code": "cat -T tabfile"}, {"description": "View file contents with more command", "code": "cat tutorial.txt | more"}, {"description": "View file contents with less command", "code": "cat tutorial.txt | less"}, {"description": "Suppress repeated empty lines in output", "code": "cat -s tutorial.txt"}, {"description": "Append file content to end of another file", "code": "cat Fruits.txt >> veg.txt"}, {"description": "Display file contents in reversed order", "code": "tac Weekdays.txt"}, {"description": "Show file content in binary format", "code": "cat Weekdays.txt | xxd -b"}, {"description": "Show file content in hexadecimal format", "code": "cat Weekdays.txt | hexdump -C"}, {"description": "Display specific lines of file", "code": "cat Weekdays.txt | sed -n '3,6p'"}, {"description": "Sort the contents of file alphabetically", "code": "cat -v veg.txt | sort"}, {"description": "Display end of file marker in file", "code": "cat > month.txt << EOF"}, {"description": "View CPU info in linux", "code": "cat /proc/cpuinfo"}], "description": "The cat command in linux is used to concatenate, display, and create files. It can accept multiple options and file name arguments. The options start with a hyphen (\"-\"), such as \"-E\" is used to display line ends and \"-n\" to display numbers before lines. The file argument specifies the file which will be manipulated by the command. Users can provide names of multiple files separated by space. The cat command can also be utilized with other linux commands to perform more advanced operations like sorting content or converting the content into other file formats."},
{"domain": "linux", "framework": "Shell", "functionality": "Command Operators", "api_name": "Ampersand, Semi-colon, AND, OR, NOT, AND-OR, PIPE, Command Combination, Precedence, Concatenation Operators", "api_call": "command &", "api_arguments": "command", "python_environment_requirements": "Python shell", "example_code": [{"description": "Run one command in the background", "code": "ping \u00adc5 www.tecmint.com &"}, {"description": "Run two command in background, simultaneously", "code": "apt-get update & apt-get upgrade &"}, {"description": "Run several commands in a single go and the execution of command occurs sequentially", "code": "apt-get update ; apt-get upgrade ; mkdir test"}], "description": "These are various operators used in linux shell to control the execution of commands. The operators include the Ampersand (&) for running commands in the background, Semi-colon (;) for running multiple commands sequentially, AND (&&) for running the second command only if the first succeeds, OR (||) for running the second command only if the first fails, NOT (!) for executing all except the condition provided, AND-OR (&& - ||) for running the second command based on the success or failure of the first, PIPE (|) for piping the output of the first command as input to the second, Command Combination ({}) for combining two or more commands where the second depends on the first, Precedence () for controlling the order of command execution, and Concatenation (\\) for concatenating large commands over several lines."},
{"domain": "linux", "framework": "Command Line", "functionality": "Rename Multiple Files", "api_name": "Rename Command", "api_call": "rename -v 's/\\.pdf$/\\.doc/' *.pdf", "api_arguments": ["-v", "'s/\\.pdf$/\\.doc/'", "*.pdf"], "python_environment_requirements": ["Python 3.5 or higher", "linux environment"], "example_code": [{"description": "Rename all .pdf files to .doc", "code": "rename -v 's/\\.pdf$/\\.doc/' *.pdf"}], "description": "The rename command in linux is used to rename multiple files at once according to a specified rule. This command renames all .pdf files to .doc. The rule 's/\\.pdf$/\\.doc/' is used to specify this change."},
{"domain": "linux", "framework": "Exa", "functionality": "File and directory listing", "api_name": "Exa API", "api_call": "exa -l", "api_arguments": ["-l"], "python_environment_requirements": ["Rustc version 1.17.0 or higher", "libgit2", "cmake"], "example_code": [{"description": "Display a file\u2019s extended attributes, as well as standard filesystem information", "code": "exa"}, {"description": "Display detailed view", "code": "exa -l"}], "description": "Exa is a modern replacement for the 'ls' command in linux, written in Rust. It is small, fast, and portable. It uses colors for distinguishing information by default, can display a file\u2019s extended attributes, as well as standard filesystem information. It queries files in parallel and has Git support; allowing viewing of the Git status for a directory. It also supports recursing into directories with a tree view."},
{"domain": "linux", "framework": "bd", "functionality": "Navigate directories quickly", "api_name": "bd", "api_call": "bd <directory_name>", "api_arguments": ["directory_name"], "python_environment_requirements": ["linux OS", "bd installed"], "example_code": [{"description": "Navigate to Documents directory", "code": "bd Documents"}, {"description": "Navigate to Data directory", "code": "bd Data"}], "description": "The bd (back directory) utility allows users to quickly navigate to parent directories in the linux file system. Instead of typing 'cd ../../..' redundantly, users can simply type 'bd <directory_name>' to go back to the specified parent directory. This utility is particularly useful for navigating long directory paths. It also supports case-sensitive directory name matching and autocomplete."},
{"domain": "linux", "framework": "os", "functionality": "Create a child process", "api_name": "fork", "api_call": "pid = os.fork()", "api_arguments": "None", "python_environment_requirements": "import os", "example_code": [{"description": "Create a child process and print the process id", "code": "import os\n\npid = os.fork()\n\nif pid > 0 :\n    print('I am parent process:')\n    print('Process ID:', os.getpid())\n    print('Child's process ID:', pid)\nelse :\n    print('I am child process:')\n    print('Process ID:', os.getpid())\n    print('Parent's process ID:', os.getppid())"}], "description": "The fork function in linux is used to create a new process, which becomes the child process of the caller. After a new child process is created, both processes will execute the next instruction following the fork() system call. Therefore, we have to distinguish the parent from the child. This can be done by testing the returned value of fork():"},
{"domain": "linux", "framework": "FFmpeg", "functionality": "Video and Audio Conversion", "api_name": "FFmpeg Commands", "api_call": "$ ffmpeg -i video.flv -hide_banner", "api_arguments": ["-i video.flv", "-hide_banner"], "python_environment_requirements": "FFmpeg utility", "example_code": [{"description": "Get Video File Information", "code": "$ ffmpeg -i video.flv -hide_banner"}, {"description": "Split a video into images", "code": "$ ffmpeg -i video.flv image%d.jpg"}, {"description": "Convert images into a video", "code": "$ ffmpeg -f image2 -i image%d.jpg imagestovideo.mpg"}, {"description": "Convert a video into mp3 format", "code": "$ ffmpeg -i video.flv -vn -ar 44100 -ac 2 -ab 192 -f mp3 audio.mp3"}, {"description": "Covert flv video file to mpg format", "code": "$ ffmpeg -i video.flv video.mpg"}, {"description": "Convert video into animated gif", "code": "$ ffmpeg -i video.flv animated.gif.mp4"}, {"description": "Convert mpg video file to flv", "code": "$ ffmpeg -i video.mpg -ab 26k -f flv video1.flv"}, {"description": "Convert avi video file to mpeg", "code": "$ ffmpeg -i video.avi -target pal-dvd -ps 2000000000 -aspect 16:9 video.mpeg"}, {"description": "Convert a video to CD or DVD format", "code": "$ ffmpeg -i video.mpg -target vcd vcd_video.mpg"}, {"description": "Extract audio from video file", "code": "$ ffmpeg -i video1.avi -vn -ar 44100 -ac 2 -ab 192 -f mp3 audio3.mp3"}, {"description": "Mix a video and audio together", "code": "$ ffmpeg -i audio.mp3 -i video.avi video_audio_mix.mpg"}, {"description": "Increase/Reduce Video Playback Speed", "code": "$ ffmpeg -i video.mpg -vf \"setpts=0.5*PTS\" highspeed.mpg"}, {"description": "Compare/Test Video and Audio Quality", "code": "$ ffplay video1.mp4"}, {"description": "Add Photo or Banner to Audio", "code": "$ ffmpeg -loop 1 -i image.jpg -i Bryan\\ Adams\\ -\\ Heaven.mp3 -c:v libx264 -c:a aac -strict experimental -b:a 192k -shortest output.mp4"}, {"description": "Add subtitles to a Movie", "code": "$ ffmpeg -i video.mp4 -i subtitles.srt -map 0 -map 1 -c copy -c:v libx264 -crf 23 -preset veryfast video-output.mkv"}], "description": "FFmpeg is a powerful tool that can do almost anything you can think of with multimedia data. It can convert media files, cut or combine video, get information from them like bitrate, stream info, etc. These are some of the tasks the FFmpeg tool is capable of. The examples in the blog post describe various ways to manipulate videos."}
]